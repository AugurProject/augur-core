{
    "branches": {
        "address": "0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "# CurrentVotePeriod is the current index in eventsExpDates", 
            "# Branches' index is the hash of the branch (aka branchID)", 
            "# currentVotePeriod is a nonce that tells us which bucket of events up to be", 
            "# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)", 
            "# period parameter for reporting", 
            "# currentExpPeriod = (block.number / self.Branches[branch].periodLength)", 
            "# currentExpPeriod - 1 is what's up for reporting at any given time", 
            "# should add a min initial liquidity property, for non pm branches it'd be low and .5*minInitialLiquidity is == fee for event", 
            "# could also add an event fee parameter", 
            "data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod)", 
            "", 
            "# first param is the branch, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "data branchList[]", 
            "", 
            "data branchListCount", 
            "", 
            "def init():", 
            "    self.Branches[1010101].currentVotePeriod = (block.number / 100) - 1", 
            "    self.Branches[1010101].periodLength = 100", 
            "    self.Branches[1010101].minTradingFee = 2^57", 
            "    self.branchListCount = 1", 
            "    self.branchList[0] = 1010101", 
            "", 
            "# call once after uploading (externed method not allowed in init)", 
            "def initDefaultBranch():", 
            "    return(CASH.initiateOwner(1010101))", 
            "", 
            "def getOracleOnly(branch):", 
            "\treturn(self.Branches[branch].oracleOnly)", 
            "", 
            "def getVotePeriod(branch):", 
            "\treturn(self.Branches[branch].currentVotePeriod)", 
            "", 
            "def getPeriodLength(branch):", 
            "\treturn(self.Branches[branch].periodLength)", 
            "", 
            "# branch cash balance at start of period", 
            "def setInitialBalance(branch, period, balance):", 
            "\tself.Branches[branch].balance[period] = balance", 
            "\treturn(balance)", 
            "", 
            "def getInitialBalance(branch, period):", 
            "\treturn(self.Branches[branch].balance[period])", 
            "", 
            "# @return all markets in a branch", 
            "def getMarketsInBranch(branch):", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getNumMarketsBranch(branch):", 
            "\treturn(self.Branches[branch].numMarkets)", 
            "", 
            "def getMinTradingFee(branch):", 
            "\treturn(self.Branches[branch].minTradingFee)", 
            "", 
            "# @return all branches", 
            "def getBranches():", 
            "    b = 0", 
            "    numBranches = self.branchListCount", 
            "    branches = array(numBranches)", 
            "    while b < numBranches:", 
            "        branches[b] = self.branchList[b]", 
            "        b += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumBranches():", 
            "\treturn(self.branchListCount)", 
            "", 
            "def getBranch(branchNumber):", 
            "\treturn(self.branchList[branchNumber])", 
            "", 
            "def getCreationDate(ID):", 
            "\treturn(self.Branches[ID].creationDate)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Branches[ID].periodLength==0):", 
            "\t\tself.Branches[ID].currentVotePeriod = currentVotePeriod", 
            "\t\tself.Branches[ID].periodLength = periodLength", 
            "\t\tself.Branches[ID].minTradingFee = minTradingFee", 
            "\t\tself.branchList[self.branchListCount] = ID", 
            "\t\tself.branchListCount += 1", 
            "\t\tself.Branches[ID].creationDate = block.number", 
            "\t\tself.Branches[ID].parentPeriod = parentPeriod", 
            "\t\tself.Branches[ID].oracleOnly = oracleOnly", 
            "\t\tCASH.initiateOwner(ID)", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def getParentPeriod(branch):", 
            "    return(self.Branches[branch].parentPeriod)", 
            "", 
            "def incrementPeriod(branch):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Branches[branch].currentVotePeriod += 1", 
            "\treturn(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addMarketToBranch(branch, market):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tnumMarkets = self.Branches[branch].numMarkets", 
            "\tself.Branches[branch].markets[numMarkets] = market", 
            "\tself.Branches[branch].numMarkets += 1", 
            "\treturn(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarketToBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branchNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationDate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getNumBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarketsBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getOracleOnly(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParentPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "initDefaultBranch()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parentPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeBranch(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialBalance(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]"
    }, 
    "buy&sellShares": {
        "address": "0xb5829458bc2f3cacc32011f81529351d6a48adb2", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xb0341996eccb15f55a4a3a2e72136f25a1e4cc19", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "event updatePrice(user:indexed, market:indexed, outcome:indexed, price, cost)", 
            "", 
            "# market, reporter", 
            "data trades[][](hash, block)", 
            "", 
            "def commitTrade(market, hash):", 
            "    self.trades[market][tx.origin].hash = hash", 
            "    self.trades[market][tx.origin].block = block.number", 
            "    return(1)", 
            "", 
            "def makeMarketHash(market, outcome, amount, limit):", 
            "    buyInfo = array(4)", 
            "    buyInfo[0] = market", 
            "    buyInfo[1] = outcome", 
            "    buyInfo[2] = amount", 
            "    buyInfo[3] = limit", 
            "    buyHash = sha256(buyInfo, items=4)", 
            "    return(buyHash)", 
            "", 
            "# amount of shares should be fixed point", 
            "# @return return price + fee to buy shares", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or trading closed", 
            "    # -2: entered a -amt of shares", 
            "    # -3: not enough money / limit order too low", 
            "    # -4: invalid outcome", 
            "    # -5: bad commitment or no commitment", 
            "    # -6: oracle only branch, no trading", 
            "def buyShares(branch, market, outcome, amount, limit):", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-6)", 
            "", 
            "    buyInfo = array(4)", 
            "    buyInfo[0] = market", 
            "    buyInfo[1] = outcome", 
            "    buyInfo[2] = amount", 
            "    buyInfo[3] = limit", 
            "    buyHash = sha256(buyInfo, items=4)", 
            "    if(self.trades[market][tx.origin].hash != buyHash || block.number == self.trades[market][tx.origin].block):", 
            "        return(-5)", 
            "    self.trades[market][tx.origin].hash = 0", 
            "    # make it so trader has locked in fee from buy, so if they sell and they bought when fee was low, they can sell with that low fee as opposed to a high one", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):", 
            "        return(-4)", 
            "    n = 0", 
            "    #if event gets pushed back people can still buy / sell", 
            "    pushedBack = 0", 
            "    while n < numEvents:", 
            "        #if(EVENTS.getPushedBack(events[n])==0):", 
            "        if(1):", 
            "            n += 1", 
            "        # pushed back and not resolved", 
            "        elif(EVENTS.getOutcome(events[n])==0):", 
            "            pushedBack = 1", 
            "            n = numEvents", 
            "        else:", 
            "          n += 1", 
            "    if (outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if newCost <= oldCost:", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(0)", 
            "    price = (newCost - oldCost)", 
            "", 
            "    if(CASH.balance(tx.origin) < price*(MARKETS.getTradingFee(market) + 2^64)/2^64 or (limit!=0 and (price*2^64/amount)>limit)):", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(-3)", 
            "", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "", 
            "    # if participant doesn't exist in market, add them", 
            "    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, tx.origin)", 
            "", 
            "    MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, amount)", 
            "    # send shares of the event to user address", 
            "    # if user doesn't have enough money, revert", 
            "    # send money from user acc. to market address/account", 
            "    # cost for shares", 
            "    CASH.send(market, price)", 
            "    # half of fees to market creator", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    CASH.send(INFO.getCreator(market), fee/2)", 
            "    # other half go to branch", 
            "    CASH.send(branch, fee/2)", 
            "    # log new price & avg price paid/share", 
            "    log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), -(price+fee)*2^64/amount)", 
            "    return(1)", 
            "", 
            "# amount is amount of shares to sell", 
            "# instead of inputting particip. num could just loop through array if dont have it", 
            "# @return error msg if fail, returns amount you get paid if success", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome, trading closed, or you haven't traded in this market", 
            "    # -2: entered a -amt of shares", 
            "    # -3: you own no shares / limit price too high", 
            "", 
            "    # -5: bad commitment or no commitment", 
            "    # -6: oracle only branch, no trading", 
            "def sellShares(branch, market, outcome, amount, limit):", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-6)", 
            "    sellInfo = array(4)", 
            "    sellInfo[0] = market", 
            "    sellInfo[1] = outcome", 
            "    sellInfo[2] = amount", 
            "    sellInfo[3] = limit", 
            "    sellHash = sha256(sellInfo, items=4)", 
            "    if(self.trades[market][tx.origin].hash != sellHash || block.number == self.trades[market][tx.origin].block):", 
            "        return(-5)", 
            "", 
            "    self.trades[market][tx.origin].hash = 0", 
            "", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):", 
            "        return(-4)", 
            "    n = 0", 
            "    #if event gets pushed back people can still buy / sell", 
            "    pushedBack = 0", 
            "    while n < numEvents:", 
            "        #if(EVENTS.getPushedBack(events[n])==0):", 
            "        if(1):", 
            "            n += 1", 
            "        # pushed back and not resolved", 
            "        elif(EVENTS.getOutcome(events[n])==0):", 
            "            pushedBack = 1", 
            "            n = numEvents", 
            "        else:", 
            "          n += 1", 
            "    if (MARKETS.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, -amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if oldCost <= newCost:", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-2)", 
            "    # these prices are in fixed point", 
            "    price = oldCost - newCost", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, revert", 
            "    if (MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount or (limit!=0 and (price*2^64/amount)<limit)):", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-3)", 
            "    else:", 
            "        # send bitcoin from the market to the user acc.", 
            "        CASH.subtractCash(market, price)", 
            "        fee = MARKETS.getTradingFee(market)*price/2^64", 
            "        # half of fees go to market creator", 
            "        CASH.addCash(INFO.getCreator(market), fee/2)", 
            "        # half go to branch", 
            "        CASH.addCash(branch, fee/2)", 
            "        price -= fee", 
            "        CASH.addCash(tx.origin, price)", 
            "        MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)", 
            "        # log new price and avg. price sold / share", 
            "        log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), (price)*2^64/amount)", 
            "        return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "buyShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "hash", 
                        "type": "int256"
                    }
                ], 
                "name": "commitTrade(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "makeMarketHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "sellShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "user", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cost", 
                        "type": "int256"
                    }
                ], 
                "name": "updatePrice(int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern buy&sellShares: [buyShares:[int256,int256,int256,int256,int256]:int256, commitTrade:[int256,int256]:int256, makeMarketHash:[int256,int256,int256,int256]:int256, sellShares:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "cash": {
        "address": "0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "data cashcoinBalances[]", 
            "", 
            "data owners[]", 
            "", 
            "def init():", 
            "    # test initial funds", 
            "    self.cashcoinBalances[tx.origin] = 100000*2^64", 
            "", 
            "# @return: cash balance of address", 
            "def balance(address):", 
            "    return(self.cashcoinBalances[address])", 
            "", 
            "# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...", 
            "# needs to be called when making a market, branch, etc. or a new cash user acc.", 
            "def initiateOwner(account):", 
            "    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):", 
            "        self.owners[account] = msg.sender", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)", 
            "# @return: value sent, 0 if fails", 
            "# If you've never used cash in augur, to initiate your account call this with value as 0", 
            "def send(recver, value):", 
            "    if(self.owners[tx.origin]==0):", 
            "        self.owners[tx.origin] = tx.origin", 
            "    if(self.owners[recver]==0):", 
            "        return(0)", 
            "    sender = tx.origin", 
            "    senderBalance = self.cashcoinBalances[sender]", 
            "    if(senderBalance >= value):", 
            "        self.cashcoinBalances[sender] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of cash sent; fail is 0", 
            "def sendFrom(recver, value, from):", 
            "    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.", 
            "    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)", 
            "    if(from!=tx.origin and msg.sender!=self.owners[from]):", 
            "        return(0)", 
            "    if(self.owners[recver]==0):", 
            "        return(0)", 
            "    senderBalance = self.cashcoinBalances[from]", 
            "    if(senderBalance >= value):", 
            "        self.cashcoinBalances[from] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# make sure only coming from specific contracts", 
            "def subtractCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "        return(0)", 
            "    self.cashcoinBalances[ID] -= amount", 
            "    return(1)", 
            "", 
            "def addCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "        return(0)", 
            "    self.cashcoinBalances[ID] += amount", 
            "    return(1)", 
            "", 
            "def setCash(address, balance):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    if(msg.sender!=self.owners[address] && tx.origin!=self.owners[ID]):", 
            "        return(0)", 
            "    self.cashcoinBalances[address] = balance", 
            "    return(1)", 
            "", 
            "def depositEther():", 
            "    self.cashcoinBalances[msg.sender] += msg.value * 2^64 / 10^18", 
            "    return msg.value", 
            "", 
            "def withdrawEther(to, value):", 
            "    if self.cashcoinBalances[msg.sender] >= value * 2^64 / 10^18:", 
            "        self.cashcoinBalances[msg.sender] -= value * 2^64 / 10^18", 
            "        send(to, value)", 
            "        return 1", 
            "    else:", 
            "        return 0"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balance(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "depositEther()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "initiateOwner(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "send(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }
                ], 
                "name": "sendFrom(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "withdrawEther(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]"
    }, 
    "closeMarket": {
        "address": "0xd573353f2a147b78a5453872037db104dc521ccb", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "extern closeMarketOne: [oneOutcome:[int256,int256]:int256, valueCalcOne:[int256,int256]:int256]", 
            "CLOSEONE = 0xe4c222d5b76caca992ff1d4f6aa10d327ec02f8d", 
            "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256, valueCalcTwo:[int256,int256[],int256[]]:int256]", 
            "CLOSETWO = 0x695e4496f6f4dd71b91b05982ce069b721c97c89", 
            "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256, valueCalcFour:[int256,int256[],int256[]]:int256]", 
            "CLOSEFOUR = 0xcd14dda97ae7d4b460862ddf8f6744d3a9d3bcc1", 
            "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256, valueCalcEight:[int256,int256[],int256[]]:int256]", 
            "CLOSEEIGHT = 0x3c2f01892bd6eee02efdd6fbd3bbed4ce207e328", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, penalizeNotEnoughReports:[int256,int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x0da6ea37fcd66ab0d3865efde01ab4ec7cd235de", 
            "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "RESOLVE = 0xe2d6660f1810d5c137fc511eefc0768559f8810d", 
            "", 
            "# first param is the market, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "macro YES: 2^65", 
            "macro NO: 2^64", 
            "macro BAD: 3 * 2^63", 
            "", 
            "macro CATCH_TOLERANCE: 2^64 / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < 2^63):", 
            "        0", 
            "    elif($x > 2^63):", 
            "        2^64", 
            "    else:", 
            "        0", 
            "", 
            "# loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "# distribute coins among winning events", 
            "# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1", 
            "# Error messages otherwise", 
            "    # -1: Market has no cash anyway / already closed", 
            "    # -2: 0 outcome", 
            "    # -4: Outcome .5 once, pushback and retry", 
            "    # -6: bonded pushed forward market not ready to be resolved", 
            "    # -7: event not reportable >.99", 
            "#Use consistent 1 and 2 fixed point numbers as min and max for close market, make market, make event, buy/sell shares, and consensus on binary events - really, just use base 64 fixed point everywhere", 
            "def closeMarket(branch, market):", 
            "    if(CASH.balance(market)<=0):", 
            "        return(-1)", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 0", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getMedian(events[i])==0):", 
            "            resolved = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    i = 0", 
            "    while i < numberEvents:", 
            "        numReports = MAKEREPORTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = MAKEREPORTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(numReports == numExpected && numReports!=0 && numExpected!=0):", 
            "            reportingDone = 1", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && !resolved):", 
            "        # loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "        n = 0", 
            "        outcomeFour = 0", 
            "        outcomeSix = 0", 
            "        while n < numberEvents:", 
            "            votingPeriodEvent = EVENTS.getExpiration(events[n])/BRANCHES.getPeriodLength(branch)", 
            "            fxpOutcome = EVENTS.getOutcome(events[n])", 
            "            resolution = 1", 
            "            if(MAKEREPORTS.getReportable(votingPeriodEvent, events[n])==-1):", 
            "                return(-7)", 
            "            if(EVENTS.getUncaughtOutcome(events[n])==0):", 
            "                return(-2)", 
            "            # TODO: if round 2 event && notFinal return 0", 
            "            if(binary(events[n]) && fxpOutcome==0):", 
            "                    resolution = RESOLVE.resolveBinary(events[n], market, branch, votingPeriodEvent, period)", 
            "            elif(scalar(events[n]) && EVENTS.getMedian(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(2^64*EVENTS.getMinValue(events[n]), 2^64*EVENTS.getMaxValue(events[n]), event, market, branch, votingPeriodEvent, period)", 
            "            elif(categorical(events[n]) && EVENTS.getMedian(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(2^64, 2^64*EVENTS.getNumOutcomes(events[n]), event, market, branch, votingPeriodEvent, period)", 
            "            if(resolution==-4):", 
            "                outcomeFour = 1", 
            "            elif(resolution==-6):", 
            "                outcomeSix = 1", 
            "            n += 1", 
            "        if(outcomeFour):", 
            "            return(-4)", 
            "        elif(outcomeSix):", 
            "            return(-6)", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = RESOLVE.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)", 
            "        MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "", 
            "        self.returnLiquidity(branch, market)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return 1 if success", 
            "# Errors:", 
            "    # 0: reporting not done", 
            "    # -1: trader doesn't exist", 
            "def claimProceeds(branch, market):", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 1", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        numReports = MAKEREPORTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = MAKEREPORTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getMedian(events[i])==0):", 
            "            resolved = 0", 
            "        if(numReports != numExpected && numReports!=0 and numExpected!=0):", 
            "            reportingDone = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && resolved):", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = MARKET.getWinningOutcomes(market, outitems=8)", 
            "        outcome = 0", 
            "        if(winningOutcomes[1]==0):", 
            "            outcome = CLOSEONE.oneOutcome(market, winningOutcomes[0])", 
            "        elif(winningOutcomes[7]):", 
            "            outcome = CLOSEEIGHT.eightOutcomes(market, winningOutcomes, events)", 
            "        elif(winningOutcomes[3]):", 
            "            outcome = CLOSEFOUR.fourOutcomes(market, winningOutcomes, events)", 
            "        elif(winningOutcomes[1]):", 
            "            outcome = CLOSETWO.twoOutcomes(market, winningOutcomes, events)", 
            "        return(outcome)", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions", 
            "def returnLiquidity(branch, market):", 
            "    # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)", 
            "    # refund left over initial liquidity in market - half to market creator, other half to voters", 
            "    # *unless* it's a scaled decision, refund all initial liquidity left over to market creator", 
            "    # rest of money available in market + the additional trading fees divy up amongst reporters and market creator", 
            "    initialLiquidity = INFO.getCreationFee(market)", 
            "    winningOutcomes = array(8)", 
            "    winningOutcomes = MARKETS.getWinningOutcomes(market, outitems=8)", 
            "    valueOfShares = 0", 
            "    creator = INFO.getCreator(market)", 
            "    if(winningOutcomes[1]==0):", 
            "        valueOfShares = CLOSEONE.valueCalcOne(market, winningOutcomes[0])", 
            "    elif(winningOutcomes[7]):", 
            "        valueOfShares = CLOSEEIGHT.valueCalcEight(market, winningOutcomes, events)", 
            "    elif(winningOutcomes[3]):", 
            "        valueOfShares = CLOSEFOUR.valueCalcFour(market, winningOutcomes, events)", 
            "    elif(winningOutcomes[1]):", 
            "        valueOfShares = CLOSETWO.valueCalcTwo(market, winningOutcomes, events)", 
            "", 
            "    liquidityRemaining = CASH.balance(market) - valueOfShares", 
            "    if(liquidityRemaining<0):", 
            "        return(-1)", 
            "    # some scalar involved", 
            "    if(winningOutcomes[1]):", 
            "        if(liquidityRemaining > initialLiquidity):", 
            "            # pay back liquidity, split up excess profits", 
            "            CASH.addCash(creator, initialLiquidity)", 
            "            CASH.subtractCash(market, initialLiquidity)", 
            "            liquidityRemaining -= initialLiquidity", 
            "            CASH.addCash(branch, liquidityRemaining/2)", 
            "            CASH.addCash(creator, liquidityRemaining/2)", 
            "            CASH.subtractCash(market, liquidityRemaining)", 
            "        # send whatever's left of the initial liquidity to the creator", 
            "        else:", 
            "            CASH.addCash(creator, liquidityRemaining)", 
            "            CASH.subtractCash(market, liquidityRemaining)", 
            "    # no scalars", 
            "    else:", 
            "        # split up excess profits & liquidity", 
            "        CASH.addCash(branch, liquidityRemaining/2)", 
            "        CASH.addCash(creator, liquidityRemaining/2)", 
            "        CASH.subtractCash(market, liquidityRemaining)", 
            "    return(1)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and 2**64*EVENTS.getMaxValue($event)==2**65 and EVENTS.getMinValue($event)==1)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "claimProceeds(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "returnLiquidity(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarket: [claimProceeds:[int256,int256]:int256, closeMarket:[int256,int256]:int256, returnLiquidity:[int256,int256]:int256]"
    }, 
    "closeMarketEight": {
        "address": "0x3c2f01892bd6eee02efdd6fbd3bbed4ce207e328", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "# eight winning outcomes", 
            "def eightOutcomes(market, winningOutcome: arr, events: arr):", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)", 
            "    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare = array(7)", 
            "    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        CASH.subtractCash(market, sharesOwned*pricePerShare[n]*MARKETS.getCumScale(market)/2^64)", 
            "        CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare[n]/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcEight(market, winningOutcome: arr, events: arr):", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)", 
            "    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare = array(7)", 
            "    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    sharesTotal3 = MARKETS.getSharesPurchased(market, winningOutcome[2]) - MARKETS.initialLiquidityAmount(market, winningOutcome[2])", 
            "    sharesTotal4 = MARKETS.getSharesPurchased(market, winningOutcome[3]) - MARKETS.initialLiquidityAmount(market, winningOutcome[3])", 
            "    sharesTotal5 = MARKETS.getSharesPurchased(market, winningOutcome[4]) - MARKETS.initialLiquidityAmount(market, winningOutcome[4])", 
            "    sharesTotal6 = MARKETS.getSharesPurchased(market, winningOutcome[5]) - MARKETS.initialLiquidityAmount(market, winningOutcome[5])", 
            "    sharesTotal7 = MARKETS.getSharesPurchased(market, winningOutcome[6]) - MARKETS.initialLiquidityAmount(market, winningOutcome[6])", 
            "    sharesTotal8 = MARKETS.getSharesPurchased(market, winningOutcome[7]) - MARKETS.initialLiquidityAmount(market, winningOutcome[7])", 
            "", 
            "    value = sharesTotal1*cumScale*pricePerShare[0]/2**64 + sharesTotal2*cumScale*pricePerShare[1]/2**64 + sharesTotal3*cumScale*pricePerShare[2]/2**64 + sharesTotal4*cumScale*pricePerShare[3]/2**64 + sharesTotal5*cumScale*pricePerShare[4]/2**64 + sharesTotal6*cumScale*pricePerShare[5]/2**64 + sharesTotal7*cumScale*pricePerShare[6]/2**64 + sharesTotal8*cumScale*pricePerShare[7]/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "eightOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcEight(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256, valueCalcEight:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketFour": {
        "address": "0xcd14dda97ae7d4b460862ddf8f6744d3a9d3bcc1", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "# four winning outcomes", 
            "def fourOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalarOne = 0", 
            "    if(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by 2^64 to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low-low", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "        # high-low", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "        # low-high", 
            "        elif(n==2):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare3/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare3/2^64)", 
            "        # high-high", 
            "        elif(n==3):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare4/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare4/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcFour(market, winningOutcome: arr, events: arr):", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalarOne = 0", 
            "    if(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by 2^64 to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    sharesTotal3 = MARKETS.getSharesPurchased(market, winningOutcome[2]) - MARKETS.initialLiquidityAmount(market, winningOutcome[2])", 
            "    sharesTotal4 = MARKETS.getSharesPurchased(market, winningOutcome[3]) - MARKETS.initialLiquidityAmount(market, winningOutcome[3])", 
            "    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64 + sharesTotal3*cumScale*pricePerShare3/2**64 + sharesTotal4*cumScale*pricePerShare4/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "fourOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcFour(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256, valueCalcFour:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketOne": {
        "address": "0xe4c222d5b76caca992ff1d4f6aa10d327ec02f8d", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "", 
            "# mutex result non scalar not .5", 
            "# one winning outcome", 
            "def oneOutcome(market, winningOutcome):", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome, -sharesOwned)", 
            "    CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market))", 
            "    CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market))", 
            "    return(1)", 
            "", 
            "def valueCalcOne(market, winningOutcome):", 
            "    sharesTotal = MARKETS.getSharesPurchased(market, winningOutcome) - MARKETS.initialLiquidityAmount(market, winningOutcome)", 
            "    return(sharesTotal*MARKETS.getCumScale(market))"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "oneOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "valueCalcOne(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketOne: [oneOutcome:[int256,int256]:int256, valueCalcOne:[int256,int256]:int256]"
    }, 
    "closeMarketTwo": {
        "address": "0x695e4496f6f4dd71b91b05982ce069b721c97c89", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "# # of winningOutcomes is 2", 
            "def twoOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalar = 0", 
            "    elif(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        scalar = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = 2^64 - pricePerShare1", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(MARKETS.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low side", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare1/2^64)", 
            "        # high side (of the scalar part)", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)*pricePerShare2/2^64)", 
            "        n+=1", 
            "    return(1)", 
            "", 
            "def valueCalcTwo(market, winningOutcome: arr, events: arr):", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if(((EVENTS.getMaxValue(events[0])!=2 || EVENTS.getMinValue(events[0])!=1) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalar = 0", 
            "    elif(((EVENTS.getMaxValue(events[1])!=2 || EVENTS.getMinValue(events[1])!=1) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        scalar = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=2 || EVENTS.getMinValue(events[2])!=1) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = 2^64 - pricePerShare1", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    sharesTotal1 = MARKETS.getSharesPurchased(market, winningOutcome[0]) - MARKETS.initialLiquidityAmount(market, winningOutcome[0])", 
            "    sharesTotal2 = MARKETS.getSharesPurchased(market, winningOutcome[1]) - MARKETS.initialLiquidityAmount(market, winningOutcome[1])", 
            "    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64", 
            "    return(value)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "twoOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "valueCalcTwo(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256, valueCalcTwo:[int256,int256[],int256[]]:int256]"
    }, 
    "comments": {
        "address": "0x32361a3f92c7e50d5038da142d050f946b12fab8", 
        "code": [
            "event comment(market: indexed, ipfsHash)", 
            "", 
            "def addComment(market, ipfsHash):", 
            "    log(type=comment, market, ipfsHash)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "addComment(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "ipfsHash", 
                        "type": "int256"
                    }
                ], 
                "name": "comment(int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern comments: [addComment:[int256,int256]:int256]"
    }, 
    "createBranch": {
        "address": "0x777072b39eae5329d4d0ee0a0db0848cda724bd6", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "", 
            "# period length is given in blocks", 
            "# @return branchID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: no money for creation fee or branch already exists", 
            "def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):", 
            "    if(periodLength<=0 || !BRANCHES.getPeriodLength(parent) || description==0):", 
            "        return(-1)", 
            "", 
            "    parentPeriod = BRANCHES.getVotePeriod(parent)", 
            "", 
            "    branchInfo = string(8*32+len(description))", 
            "    branchInfo[0] = BRANCH                                      #typecode", 
            "    branchInfo[1] = tx.origin                                   #creator address", 
            "    branchInfo[2] = 47*2^64                                     #creation fee", 
            "    branchInfo[3] = periodLength                                #length of voting cycle", 
            "    branchInfo[4] = block.number                                #current block number", 
            "    branchInfo[5] = parent                                      #branchID of parent branch", 
            "    branchInfo[6] = tradingFee", 
            "    branchInfo[7] = oracleOnly", 
            "    mcopy(branchInfo+ 8*32, description, len(description))", 
            "    # people can check that these characteristics hash to the ID if they want", 
            "    # people can hand a friend their new branch hash && characteristics && say, \"don't trust me? check\"", 
            "    branchID = sha256(branchInfo, chars=len(branchInfo))", 
            "    currentVotePeriod = (block.number / periodLength) - 1", 
            "    if(INFO.getCreator(branchID)==0):", 
            "        BRANCHES.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod)", 
            "    else:", 
            "        return(-2)", 
            "    if(INFO.getCreator(parent) && CASH.send(parent, 47*2^64) && INFO.setInfo(branchID, description, tx.origin, 47*2^64) && REPORTING.setInitialReporters(parent, branchID)):", 
            "        return(branchID)", 
            "    else:", 
            "        return(-2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }
                ], 
                "name": "createSubbranch(bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createEvent": {
        "address": "0x657cdab13e8cc4313378026a099df6c0a8e2721c", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0", 
            "# to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # 0: not enough money to pay fees or event already exists", 
            "    # -2: max value < min value", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if(maxValue < minValue):", 
            "        return(-2)", 
            "    if periodLength && description != 0 && expDate > block.number:", 
            "        eventinfo = string(8*32 + len(description))", 
            "        eventinfo[0] = EVENT                                        #typecode", 
            "        eventinfo[1] = branch                                       #branchID", 
            "        eventinfo[2] = expDate                                      #expiration date", 
            "        eventinfo[3] = tx.origin                                    #creator address", 
            "        eventinfo[4] = 42*2^64                                      #creation fee", 
            "        eventinfo[5] = minValue                                     #minimum outcome value", 
            "        eventinfo[6] = maxValue                                     #maximum outcome value", 
            "        eventinfo[7] = numOutcomes                                  #number of outcomes", 
            "        mcopy(eventinfo + 8*32, description, len(description))", 
            "        eventID = sha256(eventinfo, chars=len(eventinfo))", 
            "    else:", 
            "        return(-1)", 
            "    if(numOutcomes < 2 || numOutcomes > 50):", 
            "        return(0)", 
            "    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    participationFactor = (EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-2) * 2^64) / EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-1)", 
            "    if participationFactor == 0:", 
            "        participationFactor = 1", 
            "    CASH.initiateOwner(eventID)", 
            "    # send fee and bond", 
            "    if CASH.balance(tx.origin) >= (42*2^64 + participationFactor*45):", 
            "        if !INFO.getCreator(eventID) && !EVENTS.getEventBranch(eventID) && CASH.send(eventID, 42*2^64) && CASH.send(branch, participationFactor*45):", 
            "            # see which future period it expires in && put the event in that bin", 
            "            # event voting periods - expDate / periodLength gives you the voting period #", 
            "            futurePeriod = expDate / periodLength", 
            "            if INFO.setInfo(eventID, description, tx.origin, participationFactor*45) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes):", 
            "                return(eventID)", 
            "            else:", 
            "                return(0)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createMarket": {
        "address": "0xeb2ef218b49578277013a1d1cfa3df0b67f92670", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, penalizeNotEnoughReports:[int256,int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x0da6ea37fcd66ab0d3865efde01ab4ec7cd235de", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xb0341996eccb15f55a4a3a2e72136f25a1e4cc19", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "", 
            "event creationBlock(market:indexed)", 
            "", 
            "", 
            "# alpha is a fixedpoint number / calc. it in UI", 
            "# z is the optimal initial vector for each outcome", 
            "# z = liquidity / (1+(alpha*n*ln(n)))", 
            "    # n is num outcomes", 
            "# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set", 
            "# tradingFee is a percent in fixedPoint", 
            "# same for these values", 
            "# @return marketID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: too many events", 
            "    # -3: too many outcomes", 
            "    # -4: not enough money or market already exists", 
            "    # -5: fee too low", 
            "    # -6: duplicate events", 
            "    # -7: event already expired", 
            "", 
            "# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)", 
            "def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr, forkSelection):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "", 
            "    # minimum fee 2% with initial liquidity >= $50 and < $100", 
            "    if(initialLiquidity<100*2**64):", 
            "        if(tradingFee<368934881474191032):", 
            "            return(-5)", 
            "    # minimum fee 1% with initial liquidity >= $100 and < $1000", 
            "    if(initialLiquidity<1000*2**64):", 
            "        if(tradingFee<184467440737095516):", 
            "            return(-5)", 
            "    # minimum fee 0.5% with initial liquidity < $2000", 
            "    if(initialLiquidity<2000*2**64):", 
            "        if(tradingFee<92233720368547758):", 
            "            return(-5)", 
            "    # minimum fee 0.4% with initial liquidity < $3000", 
            "    if(initialLiquidity<3000*2**64):", 
            "        if(tradingFee<73786976294838206):", 
            "            return(-5)", 
            "    # minimum fee 0.3% with initial liquidity < $4000", 
            "    if(initialLiquidity<4000*2**64):", 
            "        if(tradingFee<55340232221128654):", 
            "            return(-5)", 
            "    # minimum fee 0.2% with initial liquidity < $5000", 
            "    if(initialLiquidity<5000*2**64):", 
            "        if(tradingFee<36893488147419103):", 
            "            return(-5)", 
            "    # minimum fee 0.1% with initial liquidity >= $5000", 
            "    if(initialLiquidity>=5000*2**64):", 
            "        if(tradingFee<18446744073709551):", 
            "            return(-5)", 
            "", 
            "    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets", 
            "    if(periodLength==0 or len(description)==0 or (initialLiquidity<50*2**64 and !BRANCHES.getOracleOnly(branch)) || alpha <= 2^57 || tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "    # minimum initial liquidity for \"oracle only\" branches is less (half is a fee, half returned)", 
            "    if(initialLiquidity<2*2**64):", 
            "        return(-1)", 
            "    event = events[0]", 
            "", 
            "    # check that events have same exp. dates && branch", 
            "    i = 0", 
            "    eventNum = len(events)", 
            "", 
            "    # only supports 3 dimensional markets atm", 
            "    if(eventNum > 3):", 
            "        return(-2)", 
            "", 
            "    numOutcomes = 0", 
            "    eventsConcat = 0", 
            "    cumulativeScale = 0", 
            "    tradingPeriod = 0", 
            "    while i < eventNum:", 
            "        event = events[i]", 
            "        if(i!=0):", 
            "            if(event==events[i-1]):", 
            "                return(-6)", 
            "        expirationDate = EVENTS.getExpiration(event)", 
            "        futurePeriod = expirationDate / periodLength", 
            "        if(expirationDate < block.number):", 
            "            return(-7)", 
            "        EXPEVENTS.addEvent(branch, futurePeriod, event)", 
            "        if(expirationDate > tradingPeriod):", 
            "            tradingPeriod = expirationDate", 
            "        eventsConcat += event", 
            "        if (EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):", 
            "            return(-1)", 
            "        #scalars", 
            "        maxValue = EVENTS.getMaxValue(event)", 
            "        minValue = EVENTS.getMinValue(event)", 
            "        if((maxValue!=2 || minValue !=1) && EVENTS.getNumOutcomes(event)==2):", 
            "            # is a valid scalar", 
            "            cumulativeScale += maxValue - EVENTS.getMinValue(event)", 
            "        eventNumOutcomes = EVENTS.getNumOutcomes(event)", 
            "        if(i==0):", 
            "            numOutcomes += eventNumOutcomes", 
            "        else:", 
            "            numOutcomes *= eventNumOutcomes", 
            "        i += 1", 
            "    if(numOutcomes > 80):", 
            "        return(-3)", 
            "    if(cumulativeScale==0):", 
            "        cumulativeScale = 1", 
            "    tradingPeriod = (tradingPeriod / periodLength)", 
            "", 
            "    # formation of marketID (hash)", 
            "    marketinfo = string(11*32 + len(description))", 
            "    marketinfo[0] = MARKET", 
            "    marketinfo[1] = tx.origin", 
            "    marketinfo[2] = initialLiquidity", 
            "    marketinfo[3] = branch", 
            "    marketinfo[4] = eventsConcat", 
            "    marketinfo[5] = len(events)", 
            "    marketinfo[6] = cumulativeScale", 
            "    marketinfo[7] = alpha", 
            "    marketinfo[8] = numOutcomes", 
            "    marketinfo[9] = tradingPeriod", 
            "    marketinfo[10] = tradingFee", 
            "    mcopy(marketinfo + 11*32, description, chars=len(description))", 
            "    marketID = sha256(marketinfo, chars=len(marketinfo))", 
            "    log(type=creationBlock, marketID)", 
            "    CASH.initiateOwner(marketID)", 
            "    # pay numOutcomes fee", 
            "    # if it's already been created return 0", 
            "    if(!CASH.send(branch, numOutcomes*2^63) || INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):", 
            "        return(-4)", 
            "", 
            "    # buy some of all outcomes", 
            "    # ls-lmsr needs at least a very small initial liquidity", 
            "    y = 1", 
            "    z = initialLiquidity * 2**64 / (cumulativeScale*2**64 + alpha*numOutcomes*cumulativeScale*FXP.fx_log(numOutcomes*2**64)/2**64)", 
            "    MARKETS.initialLiquiditySetup(marketID, alpha, cumulativeScale, numOutcomes)", 
            "    while y <= numOutcomes:", 
            "        MARKETS.modifyShares(marketID, y, z)", 
            "        MARKETS.setInitialLiquidityAmount(marketID, y, z)", 
            "        y += 1", 
            "    if(INFO.setInfo(marketID, description, tx.origin, initialLiquidity) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, forkSelection) && CASH.send(marketID, initialLiquidity)):", 
            "        i = 0", 
            "        while i < len(events):", 
            "            EVENTS.addMarket(events[i], marketID)", 
            "            i += 1", 
            "        return(marketID)", 
            "", 
            "    # revert shares bought and other variables", 
            "    else:", 
            "        v = 1", 
            "        while v <= numOutcomes:", 
            "            MARKETS.modifyShares(marketID, v, -z)", 
            "            v += 1", 
            "        MARKETS.initialLiquiditySetup(marketID, 0, 0, 0)", 
            "        return(-4)", 
            "", 
            "# todo: needs to comply w/ new trading fee rules", 
            "# perhaps don't allow raising of trading fee", 
            "def updateTradingFee(branch, market, tradingFee):", 
            "    if(tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "    return(MARKETS.setTradingFee(market, tradingFee))", 
            "", 
            "#Add def moveMarket(market, newBranch, marketAuthor) in case of a fork or some other issue", 
            "#In event of fork:", 
            "#1) Market Maker chooses the fork", 
            "#2) Market is closed at current prices", 
            "#3) The market is unable to go to adjudication upon close date and closes at final prices.", 
            "#4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.", 
            "#5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex", 
            "#6) market is moved to the fork with a higher market cap as defined by centralized exchange y", 
            "def moveMarketAndAssocEvents(market, fork):", 
            "    #if(self.stuffForked()):", 
            "    if(1):", 
            "        forkChoice = MARKETS.getForkSelection(market)", 
            "", 
            "        # set market branch", 
            "        # move event", 
            "        # move market as well to whichever fork", 
            "", 
            "        #1) Market Maker chooses the fork", 
            "        if(forkChoice==1):", 
            "            if(INFO.getCreator(market)==msg.sender):", 
            "                return(0)", 
            "        #2) Market is closed at current prices", 
            "        elif(forkChoice==2):", 
            "            return(0)", 
            "        #3) The market is unable to go to adjudication upon close date and closes at final prices.", 
            "        elif(forkChoice==3):", 
            "            return(0)", 
            "        #4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.", 
            "        # should this be weighted by capital in the market? hmm", 
            "        elif(forkChoice==4):", 
            "            return(0)", 
            "        #5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex", 
            "        elif(forkChoice==5):", 
            "            return(0)", 
            "        #6) market is moved to the fork with a higher market cap as defined by centralized exchange y", 
            "        elif(forkChoice==6):", 
            "            return(0)", 
            "        #7) autonocoin style bet which fork it should go on and that's the one (like futarchy, except you don't get a refund)", 
            "        elif(forkChoice==7):", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "", 
            "# Anyone can post an \"Early Resolution Bond\"", 
            "# This bond is equal to 0.5 * Market_Fee * Market_Value", 
            "# This amount is the amount needed to pay the reporters in case this was frivolous.", 
            "# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'", 
            "    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)", 
            "# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration dateevent", 
            "# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.", 
            "def pushMarketForward(branch, market):", 
            "    # todo: if has been pushed forward in the past (see close market) don't allow it again", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    if(marketClosed):", 
            "        return(0)", 
            "    if(CASH.send(market, numEvents*MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))==0):", 
            "        return(0)", 
            "    i = 0", 
            "    # for each event in market", 
            "    while i < numEvents:", 
            "        if(eventNotResolved && eventNotInRound2Adj):", 
            "            event = MARKETS.getMarketEvent(market, i)", 
            "            # push into next vote period", 
            "            period = BRANCHES.getVotePeriod(branch)", 
            "            EXPEVENTS.addEvent(branch, period+1, event)", 
            "            # set event expiration date to be after the current reporting period ends", 
            "            EVENTS.setExpiration(event, block.number)", 
            "            MARKETS.setTradingPeriod(market, period+1)", 
            "            MARKETS.setPushedForward(market, 1)", 
            "            #MAKEREPORTS.setReportable(period+1, event)", 
            "        i += 1", 
            "    return(1)", 
            "", 
            "", 
            "# - If at anytime after expiry an event's market's odds are <.99, someone can prove it and push it into next reporting period", 
            "# (and don't allow rbrr for original exp period of this market, actually, don't allow this regardless)", 
            "# - Should probably still have an option to pay to resolve in case something somehow goes wrong here or people really want a market resolved.", 
            "#def resolve99Market(branch, market, resolveRegardless):", 
            "#    if(eventIsScalar || marketClosed):", 
            "#      return(-1)", 
            "#    if(marketNotExpired):", 
            "#      return(-2)", 
            "#    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "#    n = 0", 
            "#    ninetynine = 0", 
            "#    while n < numOutcomes:", 
            "#      if(MARKETS.price(markets, n) > 18262276632972456099):", 
            "#        ninetynine = 1", 
            "#        n = numOutcomes", 
            "#        n += 1", 
            "", 
            "#    if(ninetynine==0 || resolveRegardless):", 
            "#      if(resolveRegardless):", 
            "#        if(CASH.send(branch, 100*2**64)==0):", 
            "#            return(0)", 
            "", 
            "#    numEvents = MARKETS.getNumEvents(market)", 
            "#    i = 0", 
            "#    # for each event in market", 
            "#    while i < numEvents:", 
            "#      if(eventNotResolved && eventNotInRound2Adj):", 
            "#        event = MARKETS.getMarketEvent(market, i)", 
            "        # push into next vote period", 
            "#        period = BRANCHES.getVotePeriod(branch)", 
            "#        EXPEVENTS.addEvent(branch, period+1, event)", 
            "        # set event expiration date to be after the current reporting period ends", 
            "#        EVENTS.setExpiration(event, block.number)", 
            "#        MARKETS.setTradingPeriod(market, period+1)", 
            "#        MAKEREPORTS.setReportable(period+1, event)", 
            "#      i += 1", 
            "#    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initialLiquidity", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "forkSelection", 
                        "type": "int256"
                    }
                ], 
                "name": "createMarket(int256,bytes,int256,int256,int256,int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fork", 
                        "type": "int256"
                    }
                ], 
                "name": "moveMarketAndAssocEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "pushMarketForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }
                ], 
                "name": "updateTradingFee(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "creationBlock(int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern createMarket: [createMarket:[int256,bytes,int256,int256,int256,int256[],int256]:int256, moveMarketAndAssocEvents:[int256,int256]:int256, pushMarketForward:[int256,int256]:int256, updateTradingFee:[int256,int256,int256]:int256]"
    }, 
    "eventResolution": {
        "address": "0xe2d6660f1810d5c137fc511eefc0768559f8810d", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, penalizeNotEnoughReports:[int256,int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x0da6ea37fcd66ab0d3865efde01ab4ec7cd235de", 
            "", 
            "macro YES: 2^65", 
            "macro NO: 2^64", 
            "macro BAD: 3 * 2^63", 
            "macro CATCH_TOLERANCE: 2^64 / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < 2^63):", 
            "        0", 
            "    elif($x > 2^63):", 
            "        2^64", 
            "    else:", 
            "        0", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "def catch(x):", 
            "    return(catch(x))", 
            "", 
            "## helper functions:", 
            "def resolveBinary(event, market, branch, votingPeriodEvent, period):", 
            "    fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    pushedBack = EVENTS.getPushedBack(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration date", 
            "    if(fxpOutcome == 3*2**63 && MARKETS.getPushedForward(market)):", 
            "        #set event expiration to be the old date prior to this bond process", 
            "        EVENTS.setExpiration(event, EVENTS.getOriginalExpiration(event))", 
            "        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))", 
            "        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        MARKETS.setPushedForward(market, 0)", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        EVENTS.setMedian(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        # need to store uncaught outcome for rejectedperiod separately as well as which period it was \"rejected\" in", 
            "        EVENTS.setRejected(event, EVENTS.getExpiration(event)/periodLength, fxpOutcome)", 
            "        return(-6)", 
            "    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome", 
            "    # why residual < periodLength/2?", 
            "    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):", 
            "        #push back event", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        EXPEVENTS.addEvent(branch, period+1, event)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        #set pushedback to true", 
            "        EVENTS.setPushedBack(event)", 
            "        #set event expiration date to be after the current reporting period ends", 
            "        EVENTS.setExpiration(event, block.number)", 
            "        MARKETS.setTradingPeriod(market, period+1)", 
            "        return(-4)", 
            "    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "    else:", 
            "        # return bond", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(INFO.getCreator(event), 42*2**64)", 
            "        if(MARKETS.getPushedForward(market)):", 
            "            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            # delete old event from future events exp", 
            "            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(event)/periodLength)", 
            "    return(1)", 
            "", 
            "def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent, period):", 
            "    #median = MEDIAN.calculateMedian(event)", 
            "    EVENTS.setMedian(event, median)", 
            "    fxpOutcome = median * (scaled_max - scaled_min) + scaled_min", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    pushedBack = EVENTS.getPushedBack(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "", 
            "    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration date", 
            "    if(fxpOutcome == 3*2**63 && MARKETS.getPushedForward(market)):", 
            "        #set event expiration to be the old date prior to this bond process", 
            "        EVENTS.setExpiration(event, EVENTS.getOriginalExpiration(event))", 
            "        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))", 
            "        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "        MARKETS.setPushedForward(market, 0)", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        EVENTS.setMedian(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        # need to store uncaught outcome for rejectedperiod separately as well as which period it was \"rejected\" in", 
            "        EVENTS.setRejected(event, EVENTS.getExpiration(event)/periodLength, fxpOutcome)", 
            "        return(-6)", 
            "", 
            "    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome", 
            "    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):", 
            "        #push back event", 
            "        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)", 
            "        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, event, 0)", 
            "        EXPEVENTS.addEvent(branch, period+1, event)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome(event, 0)", 
            "        #set pushedback to true", 
            "        EVENTS.setPushedBack(event)", 
            "        # set median to 0", 
            "        EVENTS.setMedian(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        EVENTS.setExpiration(event, block.number)", 
            "        MARKETS.setTradingPeriod(market, period+1)", 
            "        return(-4)", 
            "    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):", 
            "        # give event bond money to reporters", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(branch, 42*2**64)", 
            "        # not ethical is same as .5 outcome", 
            "        fxpOutcome = 3*2**63", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        EVENTS.setMedian(event, fxpOutcome)", 
            "    else:", 
            "        # return bond", 
            "        CASH.subtractCash(event, 42*2**64)", 
            "        CASH.addCash(INFO.getCreator(event), 42*2**64)", 
            "        if(MARKETS.getPushedForward(market)):", 
            "            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))", 
            "            # delete old event from future events exp", 
            "            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(event)/periodLength)", 
            "    return(1)", 
            "", 
            "def determineWinningOutcomes(events: arr, numberEvents, branch, market):", 
            "    n = 0", 
            "    winningOutcomes = array(8)", 
            "    while n < numberEvents:", 
            "        fxpOutcome = EVENTS.getOutcome(events[n])", 
            "        outcome = fxpOutcome/2^64", 
            "        if(n==0):", 
            "            #scalar or .5", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                winningOutcomes[0] = 1", 
            "                winningOutcomes[1] = 2", 
            "            # anything besides scalar or .5", 
            "            else:", 
            "                winningOutcomes[0] += outcome", 
            "        elif(n==1):", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                # scalar, scalar", 
            "                if(winningOutcomes[1]):", 
            "                    winningOutcomes[2] = 3", 
            "                    winningOutcomes[3] = 4", 
            "                # nonscalar, scalar", 
            "                else:", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] = winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-1])", 
            "            # scalar, nonscalar", 
            "            elif(winningOutcomes[1]):", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "                winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "            # nonscalar, nonscalar", 
            "            else:", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "        elif(n==2):", 
            "            if(scalar(events[n]) || fxpOutcome==3*2^63):", 
            "                #scalar, scalar, scalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[4] = 5", 
            "                    winningOutcomes[5] = 6", 
            "                    winningOutcomes[6] = 7", 
            "                    winningOutcomes[7] = 8", 
            "                #scalar, nonscalar, scalar", 
            "                #nonscalar, scalar, scalar", 
            "                elif(winningOutcomes[1]):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    #winningOutcomes[1] = winningOutcomes[1]", 
            "                    winningOutcomes[2] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                    winningOutcomes[3] += winningOutcomes[1] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                #nonscalar, nonscalar, scalar", 
            "                elif(winningOutcomes[1]==0):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "            else:", 
            "                #scalar, scalar, nonscalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[2] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[3] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #scalar, nonscalar, nonscalar", 
            "                #nonscalar, scalar, nonscalar", 
            "                elif(winningOutcomes[1]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #nonscalar, nonscalar, nonscalar", 
            "                else:", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "        n+=1", 
            "    return(winningOutcomes: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "catch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "numberEvents", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "determineWinningOutcomes(int256[],int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveBinary(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "scaled_min", 
                        "type": "int256"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveCategoricalOrScalar(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "events": {
        "address": "0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "", 
            "# Events' index is the eventID", 
            "# a binary outcome has 0 for min && 1 for max value, but consensus will return 2^64 and 2^65 respectively", 
            "# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1", 
            "# S&P 500 scalar would be say 0 && 4700, respectively", 
            "# categorical markets have fixed point min and max", 
            " # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)", 
            "data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, numReports, median, uncaughtOutcome, final, ethical, originalExp, rejected, rejectedPeriod, rejectedUncaught, pushedBack)", 
            "", 
            "def getEventInfo(event):", 
            "    info = array(6)", 
            "    info[0] = self.Events[event].branch", 
            "    info[1] = self.Events[event].expirationDate", 
            "    info[2] = self.Events[event].outcome", 
            "    info[3] = self.Events[event].minValue", 
            "    info[4] = self.Events[event].maxValue", 
            "    info[5] = self.Events[event].numOutcomes", 
            "    return(info: arr)", 
            "", 
            "def getEventBranch(event):", 
            "\treturn(self.Events[event].branch)", 
            "", 
            "def getPushedBack(event):", 
            "\treturn(self.Events[event].pushedBack)", 
            "", 
            "def getExpiration(event):", 
            "\treturn(self.Events[event].expirationDate)", 
            "", 
            "def getOriginalExpiration(event):", 
            "\treturn(self.Events[event].originalExp)", 
            "", 
            "def setExpiration(event, date):", 
            "\tself.Events[event].expirationDate = date", 
            "\treturn(1)", 
            "", 
            "def getOutcome(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].outcome)", 
            "", 
            "def getEthics(event):", 
            "\treturn(self.Events[event].ethical)", 
            "", 
            "def setEthics(event, ethicality):", 
            "\tself.Events[event].ethical = ethicality", 
            "\treturn(ethicality)", 
            "", 
            "def getEthical(event):", 
            "\treturn(self.Events[event].ethical)", 
            "", 
            "def getFinal(event):", 
            "\treturn(self.Events[event].final)", 
            "", 
            "def getMinValue(event):", 
            "\treturn(self.Events[event].minValue)", 
            "", 
            "def getMaxValue(event):", 
            "\treturn(self.Events[event].maxValue)", 
            "", 
            "def getNumOutcomes(event):", 
            "\treturn(self.Events[event].numOutcomes)", 
            "", 
            "def setUncaughtOutcome(event, outcome):", 
            "\tself.Events[event].uncaughtOutcome = outcome", 
            "\treturn(1)", 
            "", 
            "def getUncaughtOutcome(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].uncaughtOutcome)", 
            "", 
            "def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes):", 
            "\t# check that msg.sender is one of our function contracts", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Events[ID].expirationDate==0):", 
            "\t\tself.Events[ID].branch = branch", 
            "\t\tself.Events[ID].expirationDate = expirationDate", 
            "\t\tself.Events[ID].originalExp = originalExp", 
            "\t\tself.Events[ID].minValue = minValue", 
            "\t\tself.Events[ID].maxValue = maxValue", 
            "\t\tself.Events[ID].numOutcomes = numOutcomes", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def addMarket(event, marketID):", 
            "\tself.Events[event].markets[self.Events[event].numMarkets] = marketID", 
            "\tself.Events[event].numMarkets += 1", 
            "\treturn(1)", 
            "", 
            "def getMarkets(event):", 
            "\ti = 0", 
            "\tmarkets = array(self.Events[event].numMarkets)", 
            "\twhile i < self.Events[event].numMarkets:", 
            "\t\tmarkets[i] = self.Events[event].markets[i]", 
            "\t\ti += 1", 
            "\treturn(markets: arr)", 
            "", 
            "def getMarket(event, marketIndex):", 
            "\treturn(self.Events[event].markets[marketIndex])", 
            "", 
            "def getNumMarkets(event):", 
            "\treturn(self.Events[event].numMarkets)", 
            "", 
            "def setOutcome(ID, outcome):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Events[ID].outcome = outcome", 
            "\treturn(1)", 
            "", 
            "#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.", 
            "def setReportingThreshold(event):", 
            "\t# first check is if event expDate is in the current vote period and second is if blockNum is near expiration of voting period (within 7200 blocks or 24 hr.)", 
            "\t# final check is if < 25 reports so far", 
            "\t# (block.number+7200) / BRANCHES.getPeriodLength(branch) -1 is what we're reporting on in 24 hr", 
            "\t# vote period + 1 is the next vote period", 
            "\t# so if in 24 hr we'd be in the next vote period, we're within 24 hr of the end of this one", 
            "\tif(BRANCHES.getVotePeriod(self.Events[event].branch)==self.Events[event].expirationDate/BRANCHES.getPeriodLength(self.Events[event].branch) and (((block.number+7200) / BRANCHES.getPeriodLength(branch)) - 1)==(BRANCHES.getVotePeriod(self.Events[event].branch)+1) and self.Events[event].numReports<25):", 
            "\t\tself.Events[event].threshold = 2**192", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def getNumReports(event):", 
            "\treturn(self.Events[event].numReports)", 
            "", 
            "def addNumReports(event):", 
            "\tself.Events[event].numReports += 1", 
            "\treturn(1)", 
            "", 
            "def getReportingThreshold(event):", 
            "\treturn(self.Events[event].threshold)", 
            "", 
            "def getMedian(event):", 
            "\t# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "\treturn(self.Events[event].median)", 
            "", 
            "def setMedian(event, median):", 
            "\tself.Events[event].median = median", 
            "\treturn(1)", 
            "", 
            "def setFinal(event, final):", 
            "\tself.Events[event].final = 1", 
            "\treturn(1)", 
            "", 
            "def setRejected(event, period, uncaughtOutcome):", 
            "\tself.Events[event].rejected = 1", 
            "\tself.Events[event].rejectedPeriod = period", 
            "\tself.Events[event].rejectedUncaught = uncaughtOutcome", 
            "\treturn(1)", 
            "", 
            "def setPushedBack(event):", 
            "\tself.Events[event].pushedBack = 1", 
            "\treturn(1)", 
            "", 
            "def getRejected(event):", 
            "\treturn(self.Events[event].rejected)", 
            "", 
            "def getRejectedPeriod(event):", 
            "\treturn(self.Events[event].rejectedPeriod)", 
            "", 
            "def getRejectedUncaught(event):", 
            "\treturn(self.Events[event].rejectedUncaught)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "addNumReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthical(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthics(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMaxValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMedian(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejected(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedUncaught(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getUncaughtOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expirationDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeEvent(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthics(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "date", 
                        "type": "int256"
                    }
                ], 
                "name": "setExpiration(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "final", 
                        "type": "int256"
                    }
                ], 
                "name": "setFinal(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "median", 
                        "type": "int256"
                    }
                ], 
                "name": "setMedian(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "uncaughtOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setRejected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setUncaughtOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]"
    }, 
    "expiringEvents": {
        "address": "0x7941067c43e8a9338926e8996a48da24f1656533", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have receive a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "", 
            "# [branchID][votingPeriod]", 
            "# reporthash is [reporterID] = hash", 
            "data EventsExpDates[][](numberEvents, numberRemoved, events[], totalRepReported, numEventsToReportOn, reportHash[][], periodVolume)", 
            "", 
            "data EventIDToIndex[][]", 
            "", 
            "# With this function you can get the eventIDs and report on outcomes", 
            "# @return all events in a branch and expiration period", 
            "def getEvents(branch, expDateIndex):", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventIndex(period, eventID):", 
            "\treturn(self.EventIDToIndex[period][eventID])", 
            "", 
            "# we should probably make this bonded too", 
            "# -1: voting not started", 
            "def setNumEventsToReportOn(branch, expDateIndex):", 
            "\t# after voting has started", 
            "\tif(expDateIndex==BRANCHES.getVotePeriod(branch)):", 
            "\t\tnumEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "\t\tnumberToReportOnEstimate = (numEvents-self.EventsExpDates[branch][expDateIndex].numberRemoved)*40", 
            "\t\tself.EventsExpDates[branch][expDateIndex].numEventsToReportOn = numberToReportOnEstimate", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(-1)", 
            "", 
            "", 
            "def getNumEventsToReportOn(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)", 
            "", 
            "def getPeriodVolume(branch, expIndex):", 
            "\treturn(self.EventsExpDates[branch][expIndex].periodVolume)", 
            "", 
            "def getNumberEvents(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].numberEvents)", 
            "", 
            "def getEvent(branch, expDateIndex, eventIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].events[eventIndex])", 
            "", 
            "def getTotalRepReported(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].totalRepReported)", 
            "", 
            "def getReportHash(branch, expDateIndex, reporter, event):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addEvent(branch, futurePeriod, eventID):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID", 
            "\tself.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "\tself.EventsExpDates[branch][futurePeriod].numberEvents += 1", 
            "\treturn(1)", 
            "", 
            "def removeEvent(branch, period):", 
            "\tself.EventsExpDates[branch][period].numberRemoved += 1", 
            "\treturn(1)", 
            "", 
            "def setTotalRepReported(branch, expDateIndex, repReported):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].totalRepReported = repReported", 
            "\treturn(1)", 
            "", 
            "def addPeriodVolume(branch, expIndex, volume):", 
            "\tself.EventsExpDates[branch][expIndex].periodVolume += volume", 
            "\treturn(1)", 
            "", 
            "def setReportHash(branch, expDateIndex, reporter, reportHash, event):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash", 
            "\treturn(1)", 
            "", 
            "def moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    x = 0", 
            "    while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):", 
            "        self.EventsExpDates[branch][currentPeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]", 
            "        self.EventIDToIndex[currentPeriod][self.EventsExpDates[branch][currentVotePeriod-1].events[x]] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "        self.EventsExpDates[branch][currentPeriod].numberEvents += 1", 
            "        # sub and set old period event to 0 poss.?", 
            "        x += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "futurePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "addEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "volume", 
                        "type": "int256"
                    }
                ], 
                "name": "addPeriodVolume(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodVolume(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRepReported(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "moveEventsToCurrentPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "removeEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repReported", 
                        "type": "int256"
                    }
                ], 
                "name": "setTotalRepReported(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]"
    }, 
    "faucets": {
        "address": "0xc2018c0a19ecea3b12b6fe18b54d7fb265480170", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact jack@augur.net or joey@augur.net.", 
            "", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "", 
            "# Error -1: Hey, you're not broke!", 
            "def cashFaucet():", 
            "    if CASH.balance(tx.origin) > 5*2**64:", 
            "        return(-1)", 
            "    CASH.setCash(tx.origin, 10000*2**64)", 
            "    return(1)", 
            "", 
            "def reputationFaucet(branch):", 
            "    if REPORTING.repIDToIndex(branch, tx.origin) != 0 or REPORTING.getReporterID(branch, 0) == tx.origin:", 
            "        index = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    else:", 
            "        index = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, tx.origin)", 
            "    REPORTING.setRep(branch, index, 47*2**64)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [], 
                "name": "cashFaucet()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "reputationFaucet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern faucets: [cashFaucet:[]:int256, reputationFaucet:[int256]:int256]"
    }, 
    "fxpFunctions": {
        "address": "0xb0341996eccb15f55a4a3a2e72136f25a1e4cc19", 
        "code": [
            "macro fx_floor_log2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $lo = 0:", 
            "            with $hi = 191:", 
            "                with $mid = ($hi + $lo)/2:", 
            "                    while (($lo + 1) != $hi):", 
            "                        if $y < 2**$mid:", 
            "                            $hi = $mid", 
            "                        else:", 
            "                            $lo = $mid", 
            "                        $mid = ($hi + $lo)/2", 
            "                    $lo", 
            "", 
            "macro fx_log2_small($x):", 
            "    with $result = -0x48A49EAD9B2CD16BE:", 
            "        with $temp = $x:", 
            "            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_log2($x):", 
            "    with $y = fx_floor_log2($x):", 
            "        with $z = $x / 2**$y:", 
            "            $y * 0x10000000000000000 + fx_log2_small($z)", 
            "", 
            "macro fx_log($x):", 
            "    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177", 
            "", 
            "macro fx_exp2_small($x):", 
            "    with $result = 0x10000000000000000:", 
            "        with $temp = $x:", 
            "            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xE35846B82505F32*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA184897C5558D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x162C023B2A1D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1B5250C02BF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E87B8E21*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1C768AA3*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x164F0A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result + 0x1B08D3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_exp2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $z = $x % 0x10000000000000000:", 
            "            fx_exp2_small($z) * 2**$y", 
            "", 
            "macro fx_exp($x):", 
            "    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)", 
            "", 
            "def fx_exp(x):", 
            "\treturn(fx_exp(x))", 
            "", 
            "def fx_log(x):", 
            "\treturn(fx_log(x))", 
            "", 
            "def sqrt(n):", 
            "    val = n", 
            "    i = 0", 
            "    while i < 11:", 
            "        val = (val + n*2^64/val)/2", 
            "        i += 1", 
            "    return val"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_exp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_log(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "n", 
                        "type": "int256"
                    }
                ], 
                "name": "sqrt(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]"
    }, 
    "info": {
        "address": "0x48c9517198842d366b921e523847a5022c92af4f", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "", 
            "# Every entity in our contract has similar metadata.", 
            "# Instead of putting it in each entity, we put all the", 
            "# metadata here.", 
            "# Info's index is the hash of the item we're getting info on", 
            "data Info[](description[2048], descriptionLength, creator, creationFee)", 
            "", 
            "def init():", 
            "    description = text(\"Root branch\")", 
            "    save(self.Info[1010101].description[0], description, chars=len(description))", 
            "    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826", 
            "    self.Info[1010101].creationFee = 10", 
            "    self.Info[1010101].descriptionLength = len(description)", 
            "", 
            "def getDescription(ID):", 
            "\tlength=self.Info[ID].descriptionLength", 
            "\treturn(load(self.Info[ID].description[0], chars=length): str)", 
            "", 
            "def getDescriptionLength(ID):", 
            "\treturn(self.Info[ID].descriptionLength)", 
            "", 
            "def getCreator(ID):", 
            "\treturn(self.Info[ID].creator)", 
            "", 
            "def getCreationFee(ID):", 
            "\treturn(self.Info[ID].creationFee)", 
            "", 
            "# @return 1 if success, 0 if creator already exists", 
            "def setInfo(ID, description: str, creator, fee):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\t# check that msg.sender is one of our function contracts", 
            "\tif(self.Info[ID].creator == 0):", 
            "\t\tsave(self.Info[ID].description[0], description, chars=len(description))", 
            "\t\tself.Info[ID].descriptionLength = len(description)", 
            "\t\tself.Info[ID].creationFee = fee", 
            "\t\tself.Info[ID].creator = creator", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreator(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescription(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescriptionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setInfo(int256,bytes,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]"
    }, 
    "insertionsort": {
        "address": "0xc4378033b5c1d88b233d48854ade63ba7d00ed25", 
        "code": [
            "def insertionSort(stuff: arr):", 
            "\ti = 1", 
            "\twhile i < len(stuff):", 
            "\t\tj = i-1", 
            "\t\tkey = stuff[i]", 
            "\t\twhile (stuff[j] > key and j>=0):", 
            "\t\t\tstuff[j+1] = stuff[j]", 
            "\t\t\tj -= 1", 
            "\t\ti += 1", 
            "\t\tstuff[j+1] = key", 
            "\treturn(stuff: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "stuff", 
                        "type": "int256[]"
                    }
                ], 
                "name": "insertionSort(int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern insertionsort: [insertionSort:[int256[]]:int256[]]"
    }, 
    "makeReports": {
        "address": "0x0da6ea37fcd66ab0d3865efde01ab4ec7cd235de", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x89aacd78caab454af0546ce94f77302b29b92cc0", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xb0341996eccb15f55a4a3a2e72136f25a1e4cc19", 
            "", 
            "# branches: votePeriod, reporterID (for both num hash submitted and num actual reports submitted) --- votePeriod, EventID --- eventID", 
            "data branches[](submittedHash[][], numReportsActual[][], hasReported[][](reported[]), beforeRep[][], afterRep[][], report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], reportedPeriod[][], firstReport[])", 
            "data reportable[][]", 
            "", 
            "# need to finish this req. events stuff", 
            "data requiredEvents[]", 
            "#self.Events[event].threshold = 2**256", 
            "# branch, period as params", 
            "data numReqEvents[][]", 
            "data upToDateOnRR[]", 
            "", 
            "", 
            "def getReportable(votePeriod, eventID):", 
            "    return(self.reportable[votePeriod][eventID])", 
            "", 
            "def setReportable(votePeriod, eventID):", 
            "    self.reportable[votePeriod][eventID] = 1", 
            "    return(1)", 
            "", 
            "# Return 0 means already required", 
            "def setEventRequired(branch, period, event):", 
            "    if(self.requiredEvents[event]==0):", 
            "        self.requiredEvents[event] = 1", 
            "        self.numReqEvents[branch][period] += 1", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def getRRUpToDate():", 
            "    return(self.upToDateOnRR[msg.sender])", 
            "", 
            "def setRRUpToDate():", 
            "    self.upToDateOnRR[msg.sender] = 1", 
            "    return(1)", 
            "", 
            "def getNumReportsExpectedEvent(branch, votePeriod, eventID):", 
            "    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])", 
            "", 
            "def getNumReportsEvent(branch, votePeriod, eventID):", 
            "    return(self.branches[branch].numReportsEvent[votePeriod][eventID])", 
            "", 
            "def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):", 
            "    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num", 
            "    return(1)", 
            "", 
            "def setNumReportsEvent(branch, votePeriod, eventID, num):", 
            "    self.branches[branch].numReportsEvent[votePeriod][eventID] = num", 
            "    return(1)", 
            "", 
            "def getReport(branch, period, event):", 
            "    return(self.branches[branch].report[period][tx.origin].event[event])", 
            "", 
            "def getBeforeRep(branch,period):", 
            "    return(self.branches[branch].beforeRep[period][tx.origin])", 
            "", 
            "def getAfterRep(branch, period):", 
            "    return(self.branches[branch].afterRep[period][tx.origin])", 
            "", 
            "def setBeforeRep(branch, period, rep):", 
            "    self.branches[branch].beforeRep[period][tx.origin] = rep", 
            "    return(rep)", 
            "", 
            "def setAfterRep(branch, period, rep):", 
            "    self.branches[branch].afterRep[period][tx.origin] = rep", 
            "    return(rep)", 
            "", 
            "def getNumReportsActual(branch, votePeriod):", 
            "    return(self.branches[branch].numReportsActual[msg.sender][votePeriod])", 
            "", 
            "def getSubmittedHash(branch, period, reporter):", 
            "    return(self.branches[branch].submittedHash[period][reporter])", 
            "", 
            "def makeHash(salt, report, eventID):", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = tx.origin", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# Error 0: couldn't set report hash", 
            "# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet", 
            "# Error -2: not in hash submitting timeframe or event doesn't exist / not a valid event expiring then", 
            "# Error -4: already resolved", 
            "# Error -5: .99 market", 
            "# Error -6: no markets", 
            "def submitReportHash(branch, reportHash, votePeriod, eventID, eventIndex):", 
            "    if(BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "        return(-1)", 
            "    # make sure event is in the given branch...", 
            "    eventsID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(eventsID!=eventID || eventID == 0 || eventsID == 0):", 
            "        return(-2)", 
            "    if(EVENTS.getOutcome(eventID)!=0):", 
            "        return(-4)", 
            "    if(self.reportable[votePeriod][eventID]==-1):", 
            "        return(-5)", 
            "", 
            "    #todo: if period isn't incremented, do it", 
            "", 
            "    repIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    currentExpPeriod = (block.number / periodLength)", 
            "", 
            "    if(REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):", 
            "        return(-1)", 
            "", 
            "    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):", 
            "        EXPEVENTS.setNumEventsToReportOn(branch, votePeriod)", 
            "", 
            "    # Whoever the first person to try to submit a report for period x on market y with events events checks if it needs to be reported on or not.", 
            "    if(self.reportable[votePeriod][eventID]==0):", 
            "        needsReportingOn = self.needsReportingOn(eventID)", 
            "        # if yes, the value is 1 and everything proceeds normally", 
            "        if(BRANCHES.getOracleOnly(branch)):", 
            "            needsReportingOn = 1", 
            "        self.reportable[votePeriod][eventID] = needsReportingOn", 
            "        # If not, then no one can report on this market's event(s) and the event is \"removed\" from expEvents.", 
            "        if(needsReportingOn==-1):", 
            "            EXPEVENTS.removeEvent(branch, votePeriod)", 
            "            return(-5)", 
            "", 
            "    reportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)", 
            "    if(reportingThreshold==-6):", 
            "        return(-6)", 
            "    x = array(1)", 
            "    x[0] = tx.origin + eventID", 
            "    shaHash = sha3(x, items=1)/2**64", 
            "    if(residual < periodLength/2 && (shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(eventID))):", 
            "        # don't increment num reports expected or numreportshash per reporter for updated commitment, just the first time", 
            "        if(EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, eventID)==0):", 
            "            self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1", 
            "        # submit hash of (tx.origin, salt, Votes[])", 
            "        if(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash, eventID)):", 
            "            # if first report commitment this period", 
            "            if(self.branches[branch].submittedHash[period][msg.sender]==0):", 
            "                self.branches[branch].submittedHash[period][msg.sender] = 1", 
            "            return(1)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(-2)", 
            "", 
            "# @return 1 if success", 
            "# Error messages", 
            "    # -1: has already reported", 
            "    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet", 
            "    # -3: hash doesn't match", 
            "    # -4: no rep", 
            "    # -5: bad report", 
            "    # -6: hash not low enough", 
            "    # -8: invalid event", 
            "    # -9: already resolved", 
            "    # -10: <24 hr left in period, too late to report, able to put up readj. bonds though", 
            "def submitReport(branch, votePeriod, eventIndex, salt, report, eventID, ethics):", 
            "    if(self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod]==1):", 
            "        return(-1)", 
            "    # if currentExpPeriod is more than 2 periods past the current vote period", 
            "    # then there can be no more voting for that voting period", 
            "    # (reasoning being: >=1 period past means all the events in that period have expired)", 
            "    # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)", 
            "    # currently requires events to expire to vote", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    currentExpPeriod = (block.number / periodLength)", 
            "    repIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1) || BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "        return(-2)", 
            "    if(REPORTING.getRepBalance(branch, tx.origin)<10*2**64):", 
            "        return(-4)", 
            "    # make sure event is in the given branch and vote period...", 
            "    event = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(event==0 || eventID!=event):", 
            "        return(-8)", 
            "    if(EVENTS.getOutcome(eventID)!=0):", 
            "        return(-9)", 
            "    #if(block.number/BRANCHES.getPeriodLength(branch)!=((block.number + 4800)/BRANCHES.getPeriodLength(branch))):", 
            "    #    return(-10)", 
            "    if(!self.upToDateOnRR[msg.sender]):", 
            "        # TODO: calls to consensus functions and in send rep", 
            "        #doIt()", 
            "        self.upToDateOnRR[msg.sender] = 1", 
            "    x = array(1)", 
            "    x[0] = tx.origin + eventID", 
            "    reportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)", 
            "    # in fxp (2**192) == 2**256 / 2**64", 
            "    # TODO / need:", 
            "        # coefficient for reporting minimum based off of appeals", 
            "        #Base Reporter Amount = 3+(200*Appeal_Ratio)^3", 
            "        #This keeps the base reporter amount 3-10 until it starts getting over 1%, it makes 2% 67 and 3% 219", 
            "        #Calculated as opposed to a global variable that slowly changes over time that is.", 
            "        #I think perhaps the target number of reports per reporter could be something like   150+Base_Reporter_Amount", 
            "    shaHash = sha3(x, items=1)/2**64", 
            "    if(shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(eventID)):", 
            "        residual = block.number % periodLength", 
            "        if(residual > periodLength/2):", 
            "            realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, eventID)", 
            "            reportHash = self.makeHash(salt, report, eventID)", 
            "            if(reportHash!=realHash):", 
            "                (return(-3))", 
            "            if(self.branches[branch].firstReport[votePeriod]==0):", 
            "                BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))", 
            "                REPORTING.setInitialRep(branch, votePeriod, REPORTING.getRepBalance(branch, branch))", 
            "                self.branches[branch].firstReport[votePeriod] = 1", 
            "            report = self.validateReport(eventID, branch, votePeriod, report)", 
            "            if(report == -5):", 
            "                return(-5)", 
            "            # reporter has reported for 1 more event", 
            "            self.branches[branch].numReportsActual[tx.origin][votePeriod] += 1", 
            "            # record that reporter has reported for this event", 
            "            # todo make sure this syntax works", 
            "            self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod] = 1", 
            "            # set report value for event", 
            "            self.branches[branch].report[period][tx.origin].event[eventID] = report", 
            "            # set ethics value for event", 
            "            if(ethics!=2**64 || ethics!=0):", 
            "                ethics = 2**64", 
            "            ethics = (EVENTS.getEthics(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)", 
            "            EVENTS.setEthics(eventID, ethics)", 
            "            # add 1 report to the event", 
            "            self.branches[branch].numReportsEvent[votePeriod][eventID] += 1", 
            "            # if 1st report of the period for a reporter", 
            "            if(!self.branches[branch].reportedPeriod[votePeriod][tx.origin]):", 
            "                repReported = EXPEVENTS.getTotalRepReported(branch)", 
            "                balance = REPORTING.getRepBalance(branch, tx.origin)", 
            "                repReported += balance", 
            "                EXPEVENTS.setTotalRepReported(branch, votePeriod, repReported)", 
            "                #Record rep at start of report period", 
            "                self.branches[branch].beforeRep[votePeriod][tx.origin] = balance", 
            "                self.branches[branch].afterRep[votePeriod][tx.origin] = balance", 
            "                self.branches[branch].reportedPeriod[votePeriod][tx.origin] = 1", 
            "            return(1)", 
            "        return(-2)", 
            "    else:", 
            "        return(-6)", 
            "", 
            "# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account, and distributed like trading fees are except each person would make their own lazy claim on it.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep", 
            "def penalizeNotEnoughReports(branch, votePeriod):", 
            "    #if(alreadyPenalized):", 
            "    #    return(-1)", 
            "    numEvents = self.getNumEventsToReport(branch, votePeriod)", 
            "    # min. of 30 events no matter how little rep you have", 
            "    # whats going on here", 
            "    if(self.branches[branch].reportedPeriod[votePeriod][msg.sender]):", 
            "        # if has reported, don't count in rep reported for fee or rep redistrib. claims", 
            "        repReported = EXPEVENTS.getTotalRepReported(branch)", 
            "        repReported -= REPORTING.getRepBalance(branch, tx.origin)", 
            "        EXPEVENTS.setTotalRepReported(branch, votePeriod, repReported)", 
            "    if(numEvents < 30*2**64):", 
            "        numEvents = 30*2**64", 
            "    repConstant = REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch)", 
            "    logOutput = FXP.fx_log(repConstant)", 
            "    exp = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "    exp += 18446744073709552", 
            "    total = exp*40", 
            "    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool)", 
            "    #if(exp(ln(rep%)**1.2)*40 > 1):", 
            "    if(total > 2**64):", 
            "        numEvents = (EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)/40)*2**64", 
            "", 
            "    # what _if_ there are actually <30 events in augur?", 
            "      # perhaps we should have all reporters in that period report on all of them", 
            "    if(numEvents/(2*2**64) > self.branches[branch].numReportsActual[msg.sender][votePeriod]):", 
            "        originalRep = REPORTING.getRepBalance(branch, tx.origin)", 
            "        # penalize people", 
            "        #newRep = .2*self.branches[branch].numReportsActual[msg.sender][votePeriod] / self.getNumEventsToReport(branch, votePeriod)/(2*2**64) * originalRep", 
            "        #oldRep = REPORTING.getRepBalance(branch, tx.origin)*.8", 
            "        REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), oldRep+newRep)", 
            "        # need to decide whether to allow claiming of fees and redistrib. at lower rate or not", 
            "            #repReported = EXPEVENTS.getTotalRepReported(branch)", 
            "            #EXPEVENTS.setTotalRepReported(branch, votePeriod, repReported+oldRep+newRep)", 
            "        # adds the rep to the branch's pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), originalRep - (oldRep+newRep))", 
            "    # todo: separate heavier penalty for not reporting on a round 2 / readjudicated event", 
            "    return(1)", 
            "", 
            "### Helper functions:", 
            "def calculateReportingThreshold(branch, eventID, votePeriod):", 
            "    numMarkets = EVENTS.getNumMarkets(eventID)", 
            "    if(numMarkets==0):", 
            "        return(-6)", 
            "    if(numMarkets>100):", 
            "        numMarkets = 100", 
            "    markets = array(numMarkets)", 
            "    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)", 
            "    volume = 0", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        # may be best to store vol here", 
            "        volume += MARKETS.getVolume(markets[i])", 
            "        i += 1", 
            "    totalVol = EXPEVENTS.getPeriodVolume(branch, votePeriod)", 
            "    # if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64", 
            "    logOutput = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))", 
            "    repConstant = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "    repConstant += 18446744073709552", 
            "    volFraction = 0", 
            "    if(totalVol!=0):", 
            "        volFraction = volume*2**64/totalVol", 
            "    numEvents = self.getNumEventsToReport(branch, votePeriod)", 
            "    if(numEvents < 30*2**64):", 
            "        repConstant = 30*2**128/numEvents", 
            "    # in fxp (2**128) == 2**192 / 2**64", 
            "    reportingThreshold = 40*((-(267*volFraction**2)/(2*2**64) + (533*volFraction)/2 + 1*2**64)*repConstant/2**64) * (2**128)", 
            "    return(reportingThreshold)", 
            "", 
            "#a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))", 
            "# returns num events to report on in fxp", 
            "def getNumEventsToReport(branch, votePeriod):", 
            "    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)", 
            "    repConstant = REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch)", 
            "    logOutput = FXP.fx_log(repConstant)", 
            "    exp = FXP.fx_exp(22136092888451461120*logOutput/2**64)", 
            "    exp += 18446744073709552", 
            "    total = exp*prelim + self.numReqEvents[branch][votePeriod]*2**64", 
            "    return(total)", 
            "", 
            "def needsReportingOn(event):", 
            "    # This only works for categorical and binary markets, not scalar", 
            "    if((2^64*EVENTS.getMaxValue(events[n]) != 2*2**64 || 2^64*EVENTS.getMinValue(events[n]) != 2**64) and EVENTS.getNumOutcomes(events[n]) == 2):", 
            "        return(1)", 
            "    # To determine whether a market needs to be resolved or not, the events can only have one market associated with them or all markets associated with the event fulfill the .99 qualification.", 
            "    numMarkets = EVENTS.getNumMarkets(event)", 
            "    markets = array(numMarkets)", 
            "    markets = EVENTS.getMarkets(event, outitems=numMarkets)", 
            "    if(numMarkets>100):", 
            "        return(1)", 
            "    i = 0", 
            "    # todo optimize perf. here", 
            "    while i < numMarkets:", 
            "        numOutcomes = MARKETS.getMarketNumOutcomes(markets[i])", 
            "        n = 1", 
            "        ninetynine = 0", 
            "        while n <= numOutcomes:", 
            "            if(MARKETS.price(markets[i], n) > 18262276632972456099):", 
            "                ninetynine = 1", 
            "                n = numOutcomes+1", 
            "            n += 1", 
            "        if(ninetynine == 0):", 
            "            return(1)", 
            "        i += 1", 
            "    # doesn't need reporting on, meets the .99 qualification", 
            "    return(-1)", 
            "", 
            "def validateReport(eventID, branch, votePeriod, report):", 
            "    # check report validity", 
            "    numOutcomes = EVENTS.getNumOutcomes(eventID)", 
            "    maxValue = EVENTS.getMaxValue(eventID)", 
            "    minValue = EVENTS.getMinValue(eventID)", 
            "    # binary", 
            "    if(numOutcomes==2 and maxValue==2 && minValue==1):", 
            "        if(report>2*2^64 or report<2^64 or report==0):", 
            "            return(-5)", 
            "        # submit report", 
            "        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "        outcome = (EVENTS.getUncaughtOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)", 
            "        EVENTS.setUncaughtOutcome(eventID, outcome)", 
            "    # categorical", 
            "    elif(numOutcomes>2):", 
            "        minValue = 2^64", 
            "        range = numOutcomes*2^64 - minValue", 
            "        if(report<0):", 
            "            return(-5)", 
            "        if((report*range/2^64 + minValue)>numOutcomes*2^64):", 
            "            report = 2^64", 
            "        # submit report", 
            "        # outcome (uncaught and median) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "        # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way", 
            "        # returns -5 until we add support for median calcs", 
            "        return(-5)", 
            "    # scalar", 
            "    else:", 
            "        if(report<0):", 
            "            return(-5)", 
            "        range = maxValue*2^64 - minValue*2^64", 
            "        if((report*range/2^64 + minValue*2^64) > maxValue*2^64):", 
            "            report = 2^64", 
            "        if((report*range/2^64 + minValue*2^64) < minValue*2^64):", 
            "            report = 0", 
            "        # submit report", 
            "        # outcome should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "        # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way", 
            "        # returns -5 until we add support for median calcs", 
            "        return(-5)", 
            "    return(report)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportingThreshold(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getAfterRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getBeforeRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReport(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsActual(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsExpectedEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getRRUpToDate()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReport(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportable(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getSubmittedHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "makeHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "needsReportingOn(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeNotEnoughReports(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }
                ], 
                "name": "setAfterRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }
                ], 
                "name": "setBeforeRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventRequired(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsExpectedEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "setRRUpToDate()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportable(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReport(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }
                ], 
                "name": "validateReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern makeReports: [calculateReportingThreshold:[int256,int256,int256]:int256, getAfterRep:[int256,int256]:int256, getBeforeRep:[int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, getNumReportsActual:[int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getRRUpToDate:[]:int256, getReport:[int256,int256,int256]:int256, getReportable:[int256,int256]:int256, getSubmittedHash:[int256,int256,int256]:int256, makeHash:[int256,int256,int256]:int256, needsReportingOn:[int256]:int256, penalizeNotEnoughReports:[int256,int256]:int256, setAfterRep:[int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setRRUpToDate:[]:int256, setReportable:[int256,int256]:int256, submitReport:[int256,int256,int256,int256,int256,int256,int256]:int256, submitReportHash:[int256,int256,int256,int256,int256]:int256, validateReport:[int256,int256,int256,int256]:int256]"
    }, 
    "markets": {
        "address": "0x98c09deaa9197ca893508a70564db16a4e0a3856", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xb0341996eccb15f55a4a3a2e72136f25a1e4cc19", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, addPeriodVolume:[int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getNumEventsToReportOn:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodVolume:[int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getTotalRepReported:[int256,int256]:int256, moveEventsToCurrentPeriod:[int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setNumEventsToReportOn:[int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setTotalRepReported:[int256,int256,int256]:int256]", 
            "EXPEVENTS = 0x7941067c43e8a9338926e8996a48da24f1656533", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern events: [addMarket:[int256,int256]:int256, addNumReports:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getFinal:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMedian:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getNumReports:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setFinal:[int256,int256]:int256, setMedian:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256, setUncaughtOutcome:[int256,int256]:int256]", 
            "EVENTS = 0xb0cb71d7f57a12e403dd7b6429f35935f4c9d32c", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "", 
            "# Markets' index is the marketID", 
            "# Events is a 0 indexed array of events in the market in the format of", 
            "    # [1, event, event, 2, event, 3, event, event, event]", 
            "    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events", 
            "# Sharespurchased keeps track of the number of shares purchased for each outcome", 
            "    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)", 
            "# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event", 
            "# a binary outcome state 1 is no, 2 is true, 0 if not determined", 
            "# tradingFee is a percent in fixedPoint", 
            "# tradingPeriod is which eventexpperiod market expires in", 
            "data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, forkSelection, pushingForward, bondsMan, originalPeriod, initialLiquidity[])", 
            "", 
            "def getTotalSharesPurchased(market):", 
            "    total = 0", 
            "    n = self.Markets[market].numOutcomes", 
            "    i = 0", 
            "    while i < n:", 
            "      total += self.Markets[market].sharesPurchased[i]", 
            "      i += 1", 
            "    return(total)", 
            "", 
            "def getMarketEvent(market, index):", 
            "    return(self.Markets[market].events[index])", 
            "", 
            "macro TRADER_FIELDS: 3", 
            "macro EVENTS_FIELDS: 6", 
            "macro OUTCOMES_FIELDS: 2", 
            "macro WINNING_OUTCOMES_FIELDS: 8", 
            "macro FIELDS: 12", 
            "", 
            "def getMarketInfo(marketID):", 
            "    index = FIELDS", 
            "    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "    with info = array(FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):", 
            "        numEvents = self.Markets[marketID].lenEvents", 
            "        info[0] = marketID", 
            "        info[1] = self.Markets[marketID].currentParticipant", 
            "        info[2] = self.Markets[marketID].alpha", 
            "        info[3] = participantNumber", 
            "        info[4] = self.Markets[marketID].numOutcomes", 
            "        info[5] = self.Markets[marketID].tradingPeriod", 
            "        info[6] = self.Markets[marketID].tradingFee", 
            "        info[7] = self.Markets[marketID].branch", 
            "        info[8] = numEvents", 
            "        info[9] = self.Markets[marketID].cumulativeScale", 
            "        info[10] = INFO.getCreationFee(marketID)", 
            "        info[11] = INFO.getCreator(marketID)", 
            "", 
            "        # gather trader(s) info: [trader ID, yes shares, no shares]", 
            "        t = 0", 
            "        while t < self.Markets[marketID].currentParticipant:", 
            "            info[index + t*TRADER_FIELDS] = self.Markets[marketID].participants[t].participantID", 
            "            info[index + t*TRADER_FIELDS + 1] = self.Markets[marketID].participants[t].shares[1]", 
            "            info[index + t*TRADER_FIELDS + 2] = self.Markets[marketID].participants[t].shares[2]", 
            "            t += 1", 
            "        index += self.Markets[marketID].currentParticipant*TRADER_FIELDS", 
            "", 
            "        # gather event(s) info:", 
            "        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]", 
            "        with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):", 
            "            i = 0", 
            "            while i < numEvents:", 
            "                with eventInfo = EVENTS.getEventInfo(events[i], outitems=EVENTS_FIELDS):", 
            "                    info[index + i*EVENTS_FIELDS] = events[i]", 
            "                    j = 1", 
            "                    while j < EVENTS_FIELDS:", 
            "                        info[index + i*EVENTS_FIELDS + j] = eventInfo[j]", 
            "                        j += 1", 
            "                i += 1", 
            "        index += numEvents*EVENTS_FIELDS", 
            "", 
            "        # gather outcomes info:", 
            "        # [sharesPurchased, price, winningOutcomes...]", 
            "        k = 0", 
            "        while k < self.Markets[marketID].numOutcomes:", 
            "            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]", 
            "            info[index + k*OUTCOMES_FIELDS + 1] = self.price(marketID, k + 1)", 
            "            k += 1", 
            "        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS", 
            "        k = 0", 
            "        while k < WINNING_OUTCOMES_FIELDS:", 
            "            info[index + k] = self.Markets[marketID].winningOutcomes[k]", 
            "            k += 1", 
            "        index += WINNING_OUTCOMES_FIELDS", 
            "", 
            "        # append description character codes", 
            "        info[index] = descriptionLength", 
            "        index += 1", 
            "        with description = INFO.getDescription(marketID, outchars=descriptionLength):", 
            "            c = 0", 
            "            while c < descriptionLength:", 
            "                info[index + c] = getch(description, c)", 
            "                c += 1", 
            "        return(info: arr)", 
            "", 
            "# Gets all information about all markets on the specified branch and", 
            "# returns it as a giant array.  getMarketsInfo requires a great deal of gas.", 
            "# Invoke using eth_call with gas=9999999999999 (or other very large number).", 
            "# @param {int} branch Branch ID that we're retrieving markets on.", 
            "# @param {int} offset Starting market index (0=full load).", 
            "# @param {int} numMarketsToLoad How many markets to load (0=all markets).", 
            "# @return array Array containing all data for all markets:", 
            "#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]", 
            "#           where length_j is the number of elements stored for market j,", 
            "#           info_j is the information array for market j, and N is the total", 
            "#           number of markets in this branch.", 
            "def getMarketsInfo(branch, offset, numMarketsToLoad):", 
            "    numMarkets = BRANCHES.getNumMarkets(branch)", 
            "    with marketIDs = BRANCHES.getMarketsInBranch(branch, outitems=numMarkets):", 
            "        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:", 
            "            numMarkets = numMarketsToLoad", 
            "        with marketsMatrix = array(numMarkets):", 
            "            with marketArrayLength = array(numMarkets):", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    marketID = marketIDs[m + offset]", 
            "                    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "                    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1", 
            "                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])", 
            "                    m += 1", 
            "", 
            "                # flatten the markets info matrix so it can be returned", 
            "                # (data offset by 1+numMarkets so length data can be prepended)", 
            "                totalFlatLength = 1 + numMarkets", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    totalFlatLength += marketArrayLength[m]", 
            "                    m += 1", 
            "                with flattened = array(totalFlatLength):", 
            "                    flattened[0] = numMarkets", 
            "                    m = 0", 
            "                    while m < numMarkets:", 
            "                        flattened[m + 1] = marketArrayLength[m]", 
            "                        m += 1", 
            "                    currentFlatLength = 1 + numMarkets", 
            "                    row = 0", 
            "                    while row < numMarkets:", 
            "                        col = 0", 
            "                        while col < marketArrayLength[row]:", 
            "                            flattened[currentFlatLength + col] = marketsMatrix[row][col]", 
            "                            col += 1", 
            "                        currentFlatLength += col", 
            "                        row += 1", 
            "                    return(flattened: arr)", 
            "", 
            "def getForkSelection(market):", 
            "    return(self.Markets[market].forkSelection)", 
            "", 
            "def getMarketEvents(market):", 
            "    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)", 
            "", 
            "def getSharesPurchased(market, outcome):", 
            "    return(self.Markets[market].sharesPurchased[outcome])", 
            "", 
            "def getVolume(market):", 
            "    return(self.Markets[market].volume)", 
            "", 
            "def getParticipantNumber(market, address):", 
            "    participantNumber = self.Markets[market].addr2participant[address]", 
            "    if(self.Markets[market].participants[participantNumber].participantID != tx.origin):", 
            "        return(-1)", 
            "    else:", 
            "        return(participantNumber)", 
            "", 
            "def getParticipantID(market, participantNumber):", 
            "    return(self.Markets[market].participants[participantNumber].participantID)", 
            "", 
            "def getParticipantSharesPurchased(market, participantNumber, outcome):", 
            "    return(self.Markets[market].participants[participantNumber].shares[outcome])", 
            "", 
            "def getNumEvents(market):", 
            "    return(self.Markets[market].lenEvents)", 
            "", 
            "def getCurrentParticipantNumber(market):", 
            "    return(self.Markets[market].currentParticipant)", 
            "", 
            "def getAlpha(market):", 
            "    return(self.Markets[market].alpha)", 
            "", 
            "def getCumScale(market):", 
            "    return(self.Markets[market].cumulativeScale)", 
            "", 
            "def getMarketNumOutcomes(market):", 
            "    return(self.Markets[market].numOutcomes)", 
            "", 
            "def getTradingPeriod(market):", 
            "    return(self.Markets[market].tradingPeriod)", 
            "", 
            "def getOriginalTradingPeriod(market):", 
            "    return(self.Markets[market].originalPeriod)", 
            "", 
            "def setTradingPeriod(market, period):", 
            "    self.Markets[market].tradingPeriod = period", 
            "    return(1)", 
            "", 
            "def getTradingFee(market):", 
            "    return(self.Markets[market].tradingFee)", 
            "", 
            "def getBranchID(market):", 
            "    return(self.Markets[market].branch)", 
            "", 
            "# alpha is equal to v/(n*log(n)) where v is the max percent commission", 
            "# && n is the number of outcomes people can trade. Alpha is set when", 
            "# a market is created.", 
            "# todo: sum trick", 
            "macro lsLmsr($marketID):", 
            "    with $bq = Bq($marketID):", 
            "        with $i = 1:", 
            "            with $sumExp = 0:", 
            "                while $i <= numOutcomes($marketID):", 
            "                    $sumExp += FXP.fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)", 
            "                    $i += 1", 
            "                $bq*cumScale($marketID)*FXP.fx_log($sumExp)/2**64", 
            "", 
            "# Maximum value of array", 
            "macro maximum($a):", 
            "    with $max = $a[0]:", 
            "        with $i = 1:", 
            "            with $len = len($a):", 
            "                while $i < $len:", 
            "                    if $a[$i] > $max:", 
            "                        $max = $a[$i]", 
            "                    $i += 1", 
            "                $max", 
            "", 
            "macro sumList($q, $a, $b):", 
            "    $i = $a + 1", 
            "    $result = $q[$a]", 
            "    while $i <= $b:", 
            "        $result += $q[$i]", 
            "        $i += 1", 
            "    $result", 
            "", 
            "macro market($marketID):", 
            "    self.Markets[$marketID]", 
            "", 
            "macro alpha($marketID):", 
            "    market($marketID).alpha", 
            "", 
            "macro cumScale($marketID):", 
            "    market($marketID).cumulativeScale", 
            "", 
            "macro numOutcomes($marketID):", 
            "    market($marketID).numOutcomes", 
            "", 
            "macro sharesPurchased($marketID):", 
            "    market($marketID).sharesPurchased", 
            "", 
            "macro particpant($marketID, $addr):", 
            "    market($marketID).participants[$addr]", 
            "", 
            "macro Bq($marketID):", 
            "   alpha($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64", 
            "", 
            "def lsLmsr(marketID):", 
            "    return(lsLmsr(marketID))", 
            "", 
            "def price(market, outcome):", 
            "    a = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] += 2**50", 
            "    b = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] -= 2**50", 
            "    return(((b - a) * 2**64)/2**50)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, forkSelection):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add event list to the market", 
            "    save(self.Markets[marketID].events[0], events, items=len(events))", 
            "    self.Markets[marketID].lenEvents = len(events)", 
            "    self.Markets[marketID].tradingPeriod = tradingPeriod", 
            "    self.Markets[marketID].originalPeriod = tradingPeriod", 
            "    self.Markets[marketID].tradingFee = tradingFee", 
            "    self.Markets[marketID].branch = branch", 
            "    self.Markets[marketID].forkSelection = forkSelection", 
            "    return(1)", 
            "", 
            "def addParticipant(market, address):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    participantNumber = self.Markets[market].currentParticipant", 
            "    self.Markets[market].participants[participantNumber].participantID = address", 
            "    self.Markets[market].addr2participant[address] = participantNumber", 
            "    self.Markets[market].currentParticipant += 1", 
            "    return(participantNumber)", 
            "", 
            "def modifyShares(marketID, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    sharesPurchased(marketID)[outcome] += amount", 
            "    return(1)", 
            "", 
            "def modifyParticipantShares(branch, marketID, participantNumber, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount", 
            "    if(block.number/100>=self.getTradingPeriod(marketID)):", 
            "        return(1)", 
            "    else:", 
            "        if(amount<0):", 
            "            amount = amount*-1", 
            "        self.Markets[marketID].volume += amount", 
            "        EXPEVENTS.addPeriodVolume(branch, self.getTradingPeriod(marketID), amount)", 
            "        return(1)", 
            "", 
            "def initialLiquidityAmount(market, outcome):", 
            "    return(self.Markets[market].initialLiquidity[outcome])", 
            "", 
            "def setInitialLiquidityAmount(market, outcome, amount):", 
            "    self.Markets[market].initialLiquidity[outcome] = amount", 
            "    return(1)", 
            "", 
            "def setWinningOutcomes(market, outcomes: arr):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))", 
            "    return(1)", 
            "", 
            "def getWinningOutcomes(market):", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)", 
            "", 
            "def initialLiquiditySetup(marketID, alpha, cumScale, numOutcomes):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].alpha = alpha", 
            "    self.Markets[marketID].cumulativeScale = cumScale", 
            "    self.Markets[marketID].numOutcomes = numOutcomes", 
            "    return(1)", 
            "", 
            "def setTradingFee(market, fee):", 
            "    self.Markets[market].tradingFee = fee", 
            "    return(fee)", 
            "", 
            "def setPushedForward(market, bool):", 
            "    self.Markets[market].pushingForward = bool", 
            "    self.Markets[market].bondsMan = msg.sender", 
            "    return(1)", 
            "", 
            "def getPushedForward(market):", 
            "    return(self.Markets[market].pushingForward)", 
            "", 
            "def getBondsMan(market):", 
            "    return(self.Markets[market].bondsMan)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "addParticipant(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getAlpha(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondsMan(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCumScale(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentParticipantNumber(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkSelection(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numMarketsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInfo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantNumber(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantSharesPurchased(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedForward(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesPurchased(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalSharesPurchased(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getVolume(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "initialLiquidityAmount(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cumScale", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initialLiquiditySetup(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradingPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkSelection", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeMarket(int256,int256[],int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "lsLmsr(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyParticipantShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyShares(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "price(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialLiquidityAmount(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bool", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingFee(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingPeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomes", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWinningOutcomes(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]"
    }, 
    "quicksort": {
        "address": "0xd385403eecaac565a9d184da3731c437c41e3bb1", 
        "code": [
            "def quicksort(stuff: arr):", 
            "\tif(len(stuff)<=1):", 
            "\t\treturn(stuff: arr)", 
            "\telse:", 
            "\t\tless = array(len(stuff))", 
            "\t\tlsz = 0", 
            "\t\tmore = array(len(stuff))", 
            "\t\tmsz = 0", 
            "\t\tequal = array(len(stuff))", 
            "\t\tesz = 0", 
            "\t\ti = 0", 
            "\t\twhile i < len(stuff):", 
            "\t\t\tif stuff[i] < stuff[0]:", 
            "\t\t\t\tless[lsz] = stuff[i]", 
            "\t\t\t\tlsz += 1", 
            "\t\t\telif stuff[i] > stuff[0]:", 
            "\t\t\t\tmore[msz] = stuff[i]", 
            "\t\t\t\tmsz += 1", 
            "\t\t\telse:", 
            "\t\t\t\tequal[esz] = stuff[i]", 
            "\t\t\t\tesz += 1", 
            "\t\t\ti += 1", 
            "\t\tless = self.quicksort(slice(less, items=0, items=lsz), outitems=lsz)", 
            "\t\tmore = self.quicksort(slice(more, items=0, items=msz), outitems=msz)", 
            "\t\tnewArr = array(lsz+esz+msz)", 
            "\t\tn = 0", 
            "\t\twhile n < lsz:", 
            "\t\t\tnewArr[n] = less[n]", 
            "\t\t\tn += 1", 
            "\t\tz = 0", 
            "\t\twhile n < lsz+esz:", 
            "\t\t\tnewArr[n] = equal[z]", 
            "\t\t\tz += 1", 
            "\t\t\tn += 1", 
            "\t\tz = 0", 
            "\t\twhile n < msz+lsz+esz:", 
            "\t\t\tnewArr[n] = more[z]", 
            "\t\t\tz += 1", 
            "\t\t\tn += 1", 
            "\t\treturn(newArr: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "stuff", 
                        "type": "int256[]"
                    }
                ], 
                "name": "quicksort(int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern quicksort: [quicksort:[int256[]]:int256[]]"
    }, 
    "reporting": {
        "address": "0x89aacd78caab454af0546ce94f77302b29b92cc0", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# import makeReports as REPORTS", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x88efaf82cdc09fc6e122e679444776f8cee53fc5", 
            "", 
            "# Reporting index is the branchID", 
            "# Reporters index is the rep. address", 
            "# We 0 index reputation so can walk thru for consensus", 
            "# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future", 
            "# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key", 
            "# Events is 0 indexed as well", 
            "data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, balance[], dormantRep[](repValue, reporterID))", 
            "", 
            "data whitelists[](addresses[], taken)", 
            "", 
            "def init():", 
            "    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0", 
            "    self.Reporting[1010101].reputation[0].repValue = 47*2^64", 
            "    self.Reporting[1010101].reputation[0].reporterID = tx.origin", 
            "    self.Reporting[1010101].numberReporters = 2", 
            "    self.Reporting[1010101].repIDtoIndex[1010101] = 1", 
            "    self.Reporting[1010101].reputation[1].repValue = 0", 
            "    self.Reporting[1010101].reputation[1].reporterID = 1010101", 
            "    self.Reporting[1010101].totalRep += 47*2^64", 
            "", 
            "def checkWhitelist(address):", 
            "    return(self.whitelists[msg.sender].addresses[address])", 
            "", 
            "def checkContractWhitelist(contract, address):", 
            "    return(self.whitelists[contract].addresses[address])", 
            "", 
            "def setWhitelist(contract, addresses:arr):", 
            "    if self.whitelists[contract].taken:", 
            "        return(text(\"ERROR: you have to vote to change a whitelist\"):str)", 
            "    else:", 
            "        self.whitelists[contract].taken = 1", 
            "        i = 0", 
            "        l = len(addresses)", 
            "        while i <l:", 
            "            address = addresses[i]", 
            "            self.whitelists[contract].addresses[addresses] = 1", 
            "            i += 1", 
            "        return(text(\"SUCCESS\"):str)", 
            "", 
            "# @return reputation value", 
            "def getRepByIndex(branch, repIndex):", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getRepBalance(branch, address):", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "def getDormantRepByIndex(branch, repIndex):", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getDormantRepBalance(branch, address):", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "def getReporterID(branch, index):", 
            "    return(self.Reporting[branch].reputation[index].reporterID)", 
            "", 
            "def getTotalRep(branch):", 
            "    return(self.Reporting[branch].totalRep)", 
            "", 
            "def setInitialRep(branch, period, balance):", 
            "    self.Reporting[branch].balance[period] = balance", 
            "", 
            "def getInitialRep(branch, period):", 
            "    return(self.Reporting[branch].balance[period])", 
            "", 
            "# will return 0s for array values after it's looped through all the ones you", 
            "# have an actual balance in", 
            "def getReputation(address):", 
            "    branchListCount = BRANCHES.getNumBranches()", 
            "    if(address):", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    else:", 
            "        address = tx.origin", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumberReporters(branch):", 
            "    return(self.Reporting[branch].numberReporters)", 
            "", 
            "def repIDToIndex(branch, repID):", 
            "    return(self.Reporting[branch].repIDtoIndex[repID])", 
            "", 
            "def hashReport(report: arr, salt):", 
            "    hashInfo = array(len(report) + 2)", 
            "    hashInfo[0] = tx.origin", 
            "    hashInfo[1] = salt", 
            "    i = 2", 
            "    while i < (len(report) + 2):", 
            "        hashInfo[i] = report[i-2]", 
            "        i += 1", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setInitialReporters(parent, branchID):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add branch as a \"reporter\"", 
            "    self.Reporting[branchID].numberReporters = 1", 
            "    self.Reporting[branchID].repIDtoIndex[branchID] = 0", 
            "    self.Reporting[branchID].reputation[0].repValue = 0", 
            "    self.Reporting[branchID].reputation[0].reporterID = branchID", 
            "    return(1)", 
            "", 
            "#def claimInitialRep(parent, branchID):", 
            "    # have 1 month to claim", 
            "#    if(self.repIDToIndex(branchID, msg.sender)==0 && block.number < (BRANCHES.getCreationDate(branchID) + 216000)):", 
            "#        i = self.Reporting[branchID].numberReporters", 
            " #       rep = REPORTS.getBeforeRep(parent, BRANCHES.getParentPeriod(branchID))", 
            "  #      reporterID = msg.sender", 
            "   #     self.Reporting[branchID].reputation[i].reporterID = reporterID", 
            "    #    self.Reporting[branchID].reputation[i].repValue = rep", 
            "     #   self.Reporting[branchID].repIDtoIndex[reporterID] = i", 
            "      #  self.Reporting[branchID].dormantRep[i].reporterID = reporterID", 
            "       # self.Reporting[branchID].dormantRep[i].repValue = REPORTS.getDormantRep(parent, BRANCHES.getParentPeriod(branchID))", 
            "        #self.Reporting[branchID].numberReporters += 1", 
            "        #self.Reporting[branchID].totalRep += rep", 
            "        #return(1)", 
            "    #else:", 
            "        # already claimed or too late", 
            "     #   return(0)", 
            "", 
            "def addReporter(branch, sender):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    reporterIndex = self.Reporting[branch].numberReporters", 
            "    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex", 
            "    self.Reporting[branch].reputation[reporterIndex].repValue = 0", 
            "    self.Reporting[branch].reputation[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].numberReporters += 1", 
            "    return(1)", 
            "", 
            "def addRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue -= value", 
            "    return(1)", 
            "", 
            "def setRep(branch, index, newRep):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    oldRep = self.Reporting[branch].reputation[index].repValue", 
            "    self.Reporting[branch].reputation[index].repValue = newRep", 
            "    self.Reporting[branch].totalRep += newRep - oldRep", 
            "    return(1)", 
            "", 
            "def addDormantRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractDormantRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue -= value", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setSaleDistribution(addresses: arr, balances: arr, branchID):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    i = 0", 
            "    while i < len(addresses):", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]", 
            "        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters", 
            "        self.Reporting[branchID].numberReporters += 1", 
            "        i+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "addReporter(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkContractWhitelist(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkWhitelist(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getReputation(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }
                ], 
                "name": "hashReport(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repID", 
                        "type": "int256"
                    }
                ], 
                "name": "repIDToIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialRep(int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newRep", 
                        "type": "int256"
                    }
                ], 
                "name": "setRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "balances", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setSaleDistribution(int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWhitelist(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getDormantRepBalance:[int256,int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getInitialRep:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialRep:[int256,int256,int256]:_, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256]"
    }, 
    "transferShares": {
        "address": "0xe9c32b6ca918e72a5a0d265188d658ac9e36494e", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getForkSelection:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquidityAmount:[int256,int256]:int256, initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setInitialLiquidityAmount:[int256,int256,int256]:int256, setPushedForward:[int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x98c09deaa9197ca893508a70564db16a4e0a3856", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x48c9517198842d366b921e523847a5022c92af4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0x614ee1763c4593cb20ac089e70fcaa00454339d6", 
            "", 
            "# @return amount of shares transferred", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or you haven't traded in this market (or market doesn't exist)", 
            "    # -2: user actually doesn't have the shares", 
            "    # -3: not enough money to transfer the shares", 
            "def transferShares(branch, market, outcome, amount, to):", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    receiverNumber = MARKETS.getParticipantNumber(market, to)", 
            "    # make sure outcome exists", 
            "    if (outcome==0 || MARKETS.getParticipantID(market, participantNumber) != tx.origin):", 
            "        return(-1)", 
            "    if(to != MARKETS.getParticipantID(market, receiverNumber)):", 
            "        receiverNumber = MARKETS.addParticipant(market, to)", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, return -2", 
            "    if(MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):", 
            "        return(-2)", 
            "    MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)", 
            "    MARKETS.modifyParticipantShares(branch, market, receiverNumber, outcome, amount)", 
            "", 
            "    # half of fees to market creator", 
            "    # other half go to branch", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, 2^32)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    price = 2^32*(newCost - oldCost)", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    MARKETS.modifyShares(market, outcome, -2^32)", 
            "    if((CASH.balance(tx.origin) >= fee) && CASH.send(INFO.getCreator(market), fee/2) && CASH.send(branch, fee/2)):", 
            "        return(amount)", 
            "    else:", 
            "        return(-3)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "to", 
                        "type": "int256"
                    }
                ], 
                "name": "transferShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern transferShares: [transferShares:[int256,int256,int256,int256,int256]:int256]"
    }
}