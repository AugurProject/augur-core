# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

#### must be first data members to match delegator.se
data controller
data controllerLookupName
####

inset('../macros/externs.sem')
inset('../macros/safeMath.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/assertNoValue.sem')
inset('../macros/require.sem')

macro BOND_AMOUNT: 10**18

data initialized
data reportingWindow
data tokens[2**160]
data spenders[2**160][2**160]
data supply
data peakSupply

def any():
    assertNoValue()

def initialize(reportingWindow: address):
    require(not self.initialized)
    self.initialized = 1
    self.reportingWindow = reportingWindow
    return 1

def register():
    # do not allow for registration for reporting in the current window or past windows
    require(block.timestamp < self.reportingWindow.getStartTime())
    require(self.tokens[msg.sender] == 0)
    self.getReputationToken().transferFrom(msg.sender, self, BOND_AMOUNT)
    self.tokens[msg.sender] += 1
    self.supply += 1
    if (self.supply > self.peakSupply):
        self.peakSupply = supply
    return 1

def redeem():
    require(block.timestamp > self.reportingWindow.getEndTime())
    require(tokens[msg.sender] > 0)
    require(self.reportingWindow.isDoneReporting(msg.sender))
    self.tokens[msg.sender] -= 1
    self.supply -= 1
    self.getReputationToken().transfer(msg.sender, BOND_AMOUNT)
    return 1

####
#### Getters
####

def getReportingWindow():
    return(self.reportingWindow)

def getBranch():
    return(self.reportingWindow.getBranch())

def getReputationToken():
    return(self.reportingWindow.getReputationToken())

def getPeakSupply():
    return(self.peakSupply)


####
#### ERC20 Implementation
####

event Transfer(from:address:indexed, to:address:indexed, attotokens:int256)
event Approval(owner:address:indexed, spender:address:indexed, attotokens:int256)

def totalSupply():
    return(self.supply)

def balanceOf(address: address):
    return(self.tokens[address])

def transfer(destinationAddress: address, attotokens: uint256):
    require(1 <= attotokens and attotokens <= 2**254)
    self.tokens[msg.sender] = safeSub(self.tokens[msg.sender], attotokens)
    self.tokens[destinationAddress] = safeAdd(self.tokens[destinationAddress], attotokens)
    log(type = Transfer, msg.sender, destinationAddress, attotokens)
    return(1)

def transferFrom(sourceAddress: address, destinationAddress: address, attotokens: uint256):
    require(1 <= attotokens and attotokens <= 2**254)
    require(self.spenders[sourceAddress][msg.sender] >= attotokens)
    self.spenders[sourceAddress][msg.sender] = safeSub(self.spenders[sourceAddress][msg.sender], attotokens)
    self.tokens[sourceAddress] = safeSub(self.tokens[sourceAddress], attotokens)
    self.tokens[destinationAddress] = safeAdd(self.tokens[destinationAddress], attotokens)
    log(type = Transfer, sourceAddress, destinationAddress, attotokens)
    return(1)

def approve(spenderAddress: address, attotokens: uint256):
    require(1 <= attotokens and attotokens <= 2**254)
    self.spenders[msg.sender][spenderAddress] = attotokens
    log(type = Approval, msg.sender, spenderAddress, attotokens)
    return(1)

def allowance(ownerAddress: address, spenderAddress: address):
    return(self.spenders[ownerAddress][spenderAddress])
