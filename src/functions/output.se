def init():
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0
    self.Reporting[1010101].reputation[0].repValue = 0
    self.Reporting[1010101].reputation[0].reporterID = msg.sender
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.branch[1010101].baseReportersLastPeriod = 2*3
    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1
    self.Branches[1010101].periodLength = 15
    # .5%
    self.Branches[1010101].minTradingFee = 92233720368547760 
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # since only have to report on half this targets 3
    self.Branches[1010101].baseReporters = 2*3
    # test initial funds
    self.cashcoinBalances[msg.sender] = 100000*ONE

inset('refund.se')

macro POINTSEVEN: 12912720851596685312
macro POINTZEROONE: 184467440737095520

# Error -1: Hey, you're not broke!
def cashFaucet():
    refund()
    if self.balance(msg.sender) > 5*ONE:
        return(-1)
    self.setCash(msg.sender, 10000*ONE)
    return(1)

def reputationFaucet(branch):
    refund()
    if self.repIDToIndex(branch, tx.origin) != 0 or self.getReporterID(branch, 0) == tx.origin:
        index = self.repIDToIndex(branch, tx.origin)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, tx.origin, 0, 0, 0)
    self.setRep(branch, index, 47*ONE)
    self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
    return(1)

def fundNewAccount(branch):
    self.send(self, 0)
    self.reputationFaucet(branch)
    self.setCash(msg.sender, 10000*2^64)
    return(1)

# used to claim rep on a fork or on a new branch
def claimInitialRep(parent, branch):
    refund()
    if(self.getParent(branch)!=parent):
        return(0)
    # have 1 month to claim
    if(self.repIDToIndex(branch, msg.sender)==0 && block.timestamp < (self.getCreationDate(branch) + TWENTYFOURHR*30)):
        parentPeriod = self.getParentPeriod(branch)
        forkPeriod = self.getForkPeriod(parent)
        fork = self.getFork(parent)
        forkEvent = self.getEventForkedOver(parent)
        report = self.getReport(parent, forkPeriod, forkEvent, msg.sender)
        outcome = self.getUncaughtOutcome(forkEvent)
        if(binary(forkEvent)):
            outcome = catch(outcome)
        ethical = ethic_catch(self.getEthical(forkEvent))
        ethicReport = self.getEthicReport(parent, forkPeriod, forkEvent, msg.sender)
        rep = self.getBeforeRep(parent, parentPeriod, msg.sender)
        repDecrease = 0
        if(fork && (report<(outcome-POINTZEROONE) || (report > (outcome+POINTZEROONE)) || report==0 || (self.getForkedOverEthicality(forkEvent) && ethical==ethicReport))):
            # take away 30% of rep from liars and those who didn't report
            repDecrease = rep*POINTSEVEN/ONE
            rep = rep - repDecrease
            amountLeftToPayBonder = self.getBondAmount(forkEvent) - self.getForkBondPaid(forkEvent)
            if(repDecrease < amountLeftToPayBonder):
                # send all the rep to the fork bond poster
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), repDecrease)
            else:
                # send amountLeftToPayBonder [if positive] to the fork bond poster
                if(amountLeftToPayBonder > 0):
                    self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), amountLeftToPayBonder)    
                    # send the rest to the new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), (repDecrease - amountLeftToPayBonder))
                else:
                    # send to new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), repDecrease)
        if(fork):
            self.setPenalizedUpTo(branch, msg.sender, forkPeriod)
        else:
            self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        dormantRep = self.getPeriodDormantRep(parent, self.getParentPeriod(branch), msg.sender)
        self.addReporter(branch, msg.sender, rep, dormantRep, repDecrease)
        return(1)
    else:
        # already claimed or too late
        return(0)

        
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

inset('refund.se')

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)
event log_cancel(market:indexed, sender, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber, $fee, $sender):
    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]
    trade_id = sha3(trade, items=7)
    cumScale = self.getCumScale($market)

    # Save trade
    if !self.getID(trade_id):
        self.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)
        # Update market
        last_id = self.getLastTrade($market)
        self.addTrade($market, trade_id, last_id)
        # Update available and trading amounts for asks
        if $type == ASK:
            self.modifyParticipantShares($market, $participantNumber, $outcome, -$amount, 0)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
        # Send / escrow cash for bids
        if $type == BID:
            self.sendFrom($market, $amount * $price / ONE, $sender)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id)
    return(trade_id)

#
# Cancellation
#
# 200k gas
def cancel(trade_id):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    type = trade[1]
    market = trade[2]
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    branch = self.getBranchID(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)
        # Issue refunds
        if type == BID:
            # cash refund
            amt = amount * price * (fee + ONE) / ONE^2
            self.subtractCash(market, amt)
            self.addCash(msg.sender, amt)
        elif type == ASK:
            # shares refund
            participantNumber = self.getParticipantNumber(market, msg.sender)
            self.modifyParticipantShares(market, participantNumber, outcome, amount, 1)
            self.subtractCash(market, (amount * price * fee / ONE^2))
            self.addCash(msg.sender, (amount * price * fee / ONE^2))
        # Log cancellation
        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Buy / Sell actions: puts orders on the book
# Errors:
    # -1: amount/price bad or no market
    # -2: oracle only branch
    # -3: bad outcome to trade [not needed anymore, can't buy shares that don't exist]
    # -4: not enough money or shares
#
# costs 532k
# smallest trade value is 0.00000001
def buy(amount, price, market, outcome):
    refund()
    if(!self.getCreationTime(market)):
        return(0)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):
        return(0)
    if(self.balance(msg.sender) < (amount * price * (fee + ONE) / ONE^2)):
        return(-4)
    save_trade(BID, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# cost 532k
# smallest trade value is 0.00000001
def sell(amount, price, market, outcome):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-3)
    if(self.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-4)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    if(price>cumScale or amount*price < 3402823669209384705829531287552L or amount*price >= 2**190):
        return(0)
    if(self.balance(msg.sender) < (amount * price * fee / ONE^2)):
        return(-4)
    save_trade(ASK, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# Example:
    #buyer gives up say 20
    #complete set cost is say 100
    #fee is say 2
    #market should lose 20 from buyer's escrowed money
    #market should gain 100 from complete set
    #person short selling should give the market 80 [complete set cost less shares sold]
    #plus fees
        #1 should go to branch
        #1 should go to creator
def short_sell(buyer_trade_id, max_amount):
    refund()
    # check trade hash
    tradeInfo = array(3)
    tradeInfo[0] = buyer_trade_id
    tradeInfo[1] = max_amount
    tradeInfo[2] = 0
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return(-2)
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(3)
    # Get market
    type = trade[1]
    if(type!=BID):
        return(4)
    market = trade[2]
    if(self.getOneWinningOutcome(market, 0)):
        return(-4)
    orig_amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    if(owner == msg.sender or owner == tx.origin):
        return(5)
    # Make sure the trade has been mined, obvious HFT prevention
    if block.number <= trade[6]:
        return(TRADE_SAME_BLOCK_PROHIBITED)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    creator = self.getCreator(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    amount = min(orig_amount, max_amount)
    if(amount < 0):
        return(INSUFFICIENT_BALANCE)
    fee = amount * price * fee_percent(trading_fee, price, cumScale) / ONE^2
    makerFeeRate = self.getMakerFees(market)
    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
    takerFeesTotal = branchFees + creatorFees
    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)
    if(self.balance(msg.sender) < cost):
        return(INSUFFICIENT_BALANCE)

    if(amount*price/ONE < 184467440738):
        return(-4)

    numOutcomes = self.getMarketNumOutcomes(market)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)

    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)

    # send money from user acc. to market address/account
    # cost for shares
    self.sendFrom(market, cost-takerFeesTotal, msg.sender)

    # Fill buy order
    # Determine fill amount
    fill = amount
    # Update trade amount or remove
    if fill < orig_amount:
        self.fill_trade(trade_id, fill)
    else:
        remove_trade(trade_id, market)
    # Update balances
    ownerNum = self.getParticipantNumber(market, owner)
    self.modifyParticipantShares(market, participantNumber, outcome, -fill, 0)
    self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    # 75% to branch + .5% more to branch per maker fee 1% decrease 
    self.sendFrom(branch, branchFees, msg.sender)
    # 25% to creator + .5% more to creator per 1% decrease in maker fees
    self.sendFrom(creator, creatorFees, msg.sender)

    # other party [maker] pay their part of the fee here too
    fee = fee * makerFeeRate / ONE
    self.subtractCash(market, fee)
    self.addCash(creator, fee/2)
    self.addCash(branch, fee/2)
    
    # only count branch fees here
    self.addFees(market, fee/2+branchFees)

    # Log transaction
    log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
    # Log price, fill amount, type and timestamp
    log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
    self.setPrice(market, outcome, price)
    return([SUCCESS, max_amount, fill, price]: arr)
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROZEROONE: 18446744073709552

macro POINTONE: 1844674407370955264

macro POINTNINE: 16602069666338596864

# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account and distributed like trading fees.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
# Errors:
    # -1: already done
    # -2: not in right part of period
# prove both that a reporter voted on less than he/she actually could have and it was <.5 of what they were predicted to have reported on
# reporters pay an eth bond for this on first report --- if never called by collect fees they get it back else it goes back to pay someone who correctly calls this function --- return bond if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees
def proveReporterDidntReportEnough(branch, reporter, eventExample):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(self.getNotEnoughPenalized(branch, reporter, lastPeriod)):
        return(-1)
    if(self.getForkPeriod(branch)+1 == lastPeriod):
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        return(1)
    if(residual > periodLength/2):
        return(-2)
    # events a user should be reporting on
    # eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
    prelim = self.getNumEventsToReportOn(branch, lastPeriod)
    # need to do active rep on a period by period basis.. todo
    exp = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getBeforeRep(branch, lastPeriod, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
    baseReporters = self.getBaseReportersLastPeriod(branch)
    # if total [which is mult by num events to report on via the prelim amount] is too high [>1] then numevents will estimate a higher number than reality, so need to correct for this below
    total = exp*baseReporters
    numEvents = exp*prelim + self.getNumRequired(branch, lastPeriod)*ONE
    eventsInPeriod = self.getNumberEvents(branch, lastPeriod)-self.getNumRemoved(branch, lastPeriod)
    if(repConstant >= POINTZEROONE):
        minimum = min(30+self.getNumRequired(branch, lastPeriod), eventsInPeriod)
        if(numEvents/ONE < minimum):
            numEvents = minimum*ONE
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)
    if(total > ONE):
        numEvents = (self.getNumEventsToReportOn(branch, lastPeriod)/baseReporters)*ONE + self.getNumRequired(branch, lastPeriod)*ONE
    numReportsActual = self.getNumReportsActual(branch, lastPeriod, reporter)
    # reporter couldve reported on event example but didnt
    couldveReported = self.getEventCanReportOn(branch, lastPeriod, reporter, eventExample)
    if(numEvents/2 > numReportsActual*ONE && couldveReported):
        # typically meant for people who did report but not enough [those who didnt at all use pen. catchup] so using before rep is fine, but if not use rep balance
        originalRep = self.getBeforeRep(branch, lastPeriod, reporter)
        if(originalRep==0):
            originalRep = self.getRepBalance(branch, reporter)
        # penalize people
        newRep = POINTONE*numReportsActual*originalRep / numEvents
        oldRep = originalRep*POINTNINE / ONE
        repChange = (oldRep+newRep) - originalRep
        if(repChange > 0):
            return(1)
        # removes rep from reporter who lost it
        self.addRep(branch, self.repIDToIndex(branch, reporter), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        self.setBeforeRep(branch, lastPeriod, oldRep+newRep, reporter)
        afterRep = self.getAfterRep(branch, lastPeriod, reporter)
        newAfterRep = afterRep + repChange
        if(afterRep==0):
            newAfterRep = oldRep+newRep
        self.setAfterRep(branch, lastPeriod, newAfterRep, reporter)
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        self.doRefund(msg.sender, reporter)
        return(1)
    else:
        return(0)
inset('refund.se')

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10

event thru(user:indexed, time)

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -5: Event forked and not final yet
    # -6: bonded pushed forward market not ready to be resolved
    # -7: event not reportable >.99
    # -8: market isn't in branch
# if market's events have moved due to a fork branch is the new fork
def closeMarket(branch, market, sender):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    if(self.balance(market)<=0):
        return(-1)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 0
    resolved = 1
    while i < numberEvents:
        if(self.getOutcome(events[i])==0 && self.getmode(events[i])==0):
            resolved = 0
            i = numberEvents
        i += 1
    i = 0
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(numReports == numExpected && numReports!=0 && numExpected!=0):
            reportingDone = 1
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && !resolved):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        outcomeSix = 0
        while n < numberEvents:
            votingPeriodEvent = self.getExpiration(events[n])/self.getPeriodLength(branch)
            fxpOutcome = self.getOutcome(events[n])
            resolution = 1
            if(self.getUncaughtOutcome(events[n])==0):
                return(-2)
            if(self.getRoundTwo(event) && !self.getFinal(event)):
                return(-3)
            forkPeriod = self.getForkPeriod(self.getEventBranch(events[n]))
            currentPeriod = block.timestamp / self.getPeriodLength(branch)
            if((self.getForked(event) && !self.getForkedDone(event)) or (currentPeriod <= (forkPeriod+1))):
                return(-5)
            if(binary(events[n]) && fxpOutcome==0):
                    resolution = self.resolveBinary(events[n], market, branch, votingPeriodEvent)
            elif(scalar(events[n]) && self.getmode(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(self.getMinValue(events[n]), self.getMaxValue(events[n]), events[n], market, branch, votingPeriodEvent)
            elif(categorical(events[n]) && self.getmode(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(ONE, ONE*self.getNumOutcomes(events[n]), events[n], market, branch, votingPeriodEvent)
            if(resolution==-6):
                outcomeSix = 1
            n += 1
        if(outcomeSix):
            return(-6)
        winningOutcomes = array(8)
        winningOutcomes = self.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)
        self.setWinningOutcomes(market, winningOutcomes)
        self.refundClosing(self.getgasSubsidy(market), sender)
        return(1)
    else:
        return(0)

# claim winnings after a market is resolved
# @return 1 if success
# Errors:
    # 0: reporting not done
    # -1: trader doesn't exist
def claimProceeds(branch, market):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 1
    resolved = 1
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(self.getOutcome(events[i])==0 && self.getmode(events[i])==0):
            resolved = 0
        if(numReports != numExpected && numReports!=0 and numExpected!=0):
            reportingDone = 0
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = self.getWinningOutcomes(market, outitems=8)
        outcome = 0
        # market not resolved
        if(winningOutcomes[0]==0):
            return(0)
        if(winningOutcomes[1]==0):
            minval = self.getMinValue(events[0])
            ethical = ethic_catch(self.getEthical(events[0]))
            if(len(events)==1 && categorical(events[0]) && (self.getmode(events[0])==ONEHALF or !ethical)):
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 1, self.getNumOutcomes(events[0]))
            else:
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 0, 0)
        elif(winningOutcomes[7]):
            outcome = self.eightOutcomes(market, winningOutcomes, events, msg.sender)
        elif(winningOutcomes[3]):
            outcome = self.fourOutcomes(market, winningOutcomes, events, msg.sender)
        elif(winningOutcomes[1]):
            outcome = self.twoOutcomes(market, winningOutcomes, events, msg.sender)
        return(outcome)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and ONE*self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)
inset('refund.se')

# period length is given in blocks
# @return branchID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: no money for creation fee or branch already exists
def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):
    refund()
    if(periodLength<=0 || !self.getPeriodLength(parent) || description==0):
        return(-1)

    if(tradingFee < 0 or tradingFee > 2**62):
        return(-1)
    parentPeriod = self.getVotePeriod(parent)

    branchInfo = string(8*32+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*ONE                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.timestamp                             #current blocktime
    branchInfo[5] = parent                                      #branchID of parent branch
    branchInfo[6] = tradingFee
    branchInfo[7] = oracleOnly
    mcopy(branchInfo+ 8*32, description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha3(branchInfo, chars=len(branchInfo))
    currentVotePeriod = (block.timestamp / periodLength) - 1
    if(self.getCreator(branchID)==0):
        self.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod, parent)
    else:
        return(-2)
    if(self.getCreator(parent) && self.sendFrom(parent, 47*ONE, msg.sender) && self.setInfo(branchID, description, tx.origin, 47*ONE) && self.setInitialReporters(parent, branchID)):
        return(branchID)
    else:
        return(-2)

inset('refund.se')

#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528
macro POINTFOUR: 7378697629483821056
macro MINBOND: 200*ONE

# So we want to do the rbcr for both period 1 and period 2 at this time
# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]
# in a fork this is called on the original branch
# Errors:
    #  0: event is a fork event
    # -1: need to penalize in round 2 penalize function
    # -2: already past first half of new period and needed to penalize before then
    # -4: in fork period only thing that rbcr is done on is the round 2 event in the original branch via round 2 penalize
    # -5: already done for all events in this period
    # -6: forked events should be penalized using the fork penalization function
# force event to be resolved first if it can be
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
def penalizeRoundTwoWrong(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    roundTwo = self.getRoundTwo(event)
    overruled = 0
    uncaught = self.getUncaughtOutcome(event)
    if(repBalance < ONE):
        return(0)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    # if no events in a period
    if(self.getNumberEvents(branch, lastPeriod)<=0):
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, repBalance)
        return(1)
    elif(self.getForkPeriod(branch) == lastPeriod && event!=forkEvent):
        return(-4)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    if(!uncaught):
        if(self.roundTwoResolve(branch, event, self.getEventIndex(votePeriod, event), msg.sender)==0):
            return(-7)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    forkEvent = self.getEventForkedOver(branch)
    p = self.proportionCorrect(event)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    lastPenalizationPeriod = lastPeriod - 1
    oldReport = self.getReport(branch,lastPenalizationPeriod,event,msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    oldEthics = self.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)
    avgAdjCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / 2**64
    bond = min(bond, MINBOND)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    # if overruled / different outcome after reporting on again
    if(scalar(event) or categorical(event)):
        if((self.getOriginalOutcome(event) != self.getUncaughtOutcome(event) or self.getOriginalEthicality(event)!=ethic_catch(self.getEthical(event)))):
            overruled = 1
    elif((self.getOriginalOutcome(event) != catch(self.getUncaughtOutcome(event)) or self.getOriginalEthicality(event)!=ethic_catch(self.getEthical(event)))):
        overruled = 1
        
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)

    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it
    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period
    if(self.getRoundTwo(event) && (self.getFinal(event) or event==forkEvent) && !self.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):
        newAfterRep = 0
        smoothedRep = 0
        # Do the first rbcr based on first report and final outcome if reported first time
        if(oldReport && outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(oldReport > outcome+POINTZEROONE or oldReport < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = oldReport - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = oldReport - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 0.4 / (number of events you reported on last period) for penalization and pen. rate for backstop 1
            # use .04 as a max penalty per event for round 2 liars who lied on first report
            if(numReportedOn<10):
                repChange = oldRep * (ONE - POINTFOUR/10)/ONE + newRep*(POINTFOUR/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - POINTFOUR/numReportedOn)/ONE + newRep*(POINTFOUR/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
            if(oldEthics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            # if overruled: reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usual later in the process
            if(overruled && self.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), -repChange)
                self.increaseBondPaid(event, (-1*repChange))
        # Do the second (for each user) based on second report and final outcome
        if(reportValue && outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome    
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for backstop 1
            # use .02 as a max penalty per event for round 2 on second report
            if(numReportedOn<10):
                repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
            if(ethics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            if(overruled && self.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), -repChange)
                self.increaseBondPaid(event, (-1*repChange))
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    else:
        return(0)
    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]
    if(event==forkEvent):
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, (self.getNumReportsActual(branch, lastPeriod, msg.sender) - 1))
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)


### Helper functions:
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# put in consensus data
#def proportionCorrect(event):
#    refund()
#    p = 0
#    outcome = catch(self.getUncaughtOutcome(event))
#    if(outcome!=0):
#        # binary
#        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
#            # subtract 1 to get it from 0 to 1
#            avgOutcome = self.getUncaughtOutcome(event) - ONE
#            # say we have outcome of 0, avg is .4, what is p?
#            # p is .6 or 60%
#            if(outcome == ONE):
#                p = ONE - avgOutcome
#            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
#            # p is .8 or 80%
#            if(outcome == 2 * ONE):
#                p = avgOutcome
#            if(outcome == 3 * ONEHALF):
#                return(0)
#        return(p)
#    else:
#        return(0)

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.timestamp / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
        
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# # of winningOutcomes is 2
def twoOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    # look for the scalar
    scalar = 0
    if(((self.getMaxValue(events[0])!=TWO || self.getMinValue(events[0])!=ONE) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*ONEHALF):
        scalar = 0
    elif(((self.getMaxValue(events[1])!=TWO || self.getMinValue(events[1])!=ONE) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*ONEHALF):
        scalar = 1
    elif(((self.getMaxValue(events[2])!=TWO || self.getMinValue(events[2])!=ONE) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*ONEHALF):
        scalar = 2
    outcome = self.getOutcome(events[scalar])
    minValue = self.getMinValue(events[scalar])
    maxValue = self.getMaxValue(events[scalar])
    if(outcome>maxValue):
        outcome = maxValue
    elif(outcome<minValue):
        outcome = minValue
    # price is in fixed point
    # share two goes with the high side
    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)
    #share one goes with the low side of the calc
    pricePerShare1 = ONE - pricePerShare1
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    # for each winning outcome do...
    n = 0
    cumScale = self.getCumScale(market)
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        # low side
        if(n==0):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
        # high side (of the scalar part)
        elif(n==1):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
        n+=1
    return(1)
inset('refund.se')

def makeHash(salt, report, eventID, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Error: 0: not caught up on rep redistributions
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
def submitReportHash(event, reportHash):
    branch = self.getBranch(event)
    votePeriod = self.getVotePeriod(branch)

    # makes sure a user is up to date on penalizations
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)

    # first report of period, num events not set
    if(self.getNumEventsToReportOn(branch, votePeriod)==0):
        self.setNumEventsToReportOn(branch)
        self.setInitialBalance(branch, votePeriod, self.balance(branch))
    eventIndex = self.getEventIndex(votePeriod, event)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    reportingThreshold = 0
    if(self.getRequired(event) || self.getReportingThreshold(event)):
        reportingThreshold = 2**192
    else:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    x = array(1)
    x[0] = msg.sender + event
    # div by ONE b/c is out of 2**192 rather than 2**256 [to avoid looping around]
    # add 2**255 to ensure pos. and between 0 and 1
    shaHash = (sha3(x, items=1)+2**255)/ONE
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2 && shaHash <= reportingThreshold):
        if(self.getReportHash(branch, votePeriod, msg.sender, event)==0):
            self.addReportExpected(branch, votePeriod, event)
        self.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        return(1)
    return(-2)

# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid event
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
    # -8: fees couldn't be collected
    # -9: need to pay not reporting bond
def submitReport(event, salt, report, ethics):
    branch = self.getBranch(event)
    balance = self.getRepBalance(branch, msg.sender)
    votePeriod = self.getVotePeriod(branch)
    if(balance<ONE):
        return(0)
    # if 1st report of the period for a reporter
    if(!self.getNumReportsActual(branch, votePeriod, msg.sender)):
        if(msg.value <= 500000*tx.gasprice):
            return(-9)
        dormantRep = self.balanceOf(branch, msg.sender)
        # Record rep at start of report period
        self.setBeforeRep(branch, votePeriod, balance, msg.sender)
        self.setAfterRep(branch, votePeriod, balance, msg.sender)
        self.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)
        self.setRefund(msg.sender, msg.value)
        send(CONSENSUS, msg.value)
    if(self.getReport(branch, votePeriod, event, msg.sender)):
        return(-1)
    eventIndex = self.getEventIndex(votePeriod, event)
    # makes sure event is in the given branch and vote period
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-5)
    elif(self.getOutcome(event)!=0):
        return(-6)
    periodLength = self.getPeriodLength(branch)
    # ensures user has collected fees for last reporting period
    if(!self.getFeesCollected(branch, msg.sender, votePeriod-1)):
        if(self.collectFees(branch, msg.sender)<1):
            return(-8)
    # commented out for testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    return(-7)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        realHash = self.getReportHash(branch, votePeriod, msg.sender, event)
        if(self.makeHash(salt, report, eventID, msg.sender)!=realHash || realHash==0):
            return(-3)
        forkedOverEthicality = self.getForkedOverEthicality(event)
        forkedOverThisEvent = 0
        if(self.getEventForkedOver(branch) == event):
            forkedOverThisEvent = 1
        roundTwo = self.getRoundTwo(event)
        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)
        if(report == -4):
            return(-4)
        self.setReport(branch, votePeriod, eventID, report, msg.sender)
        # set ethics value for event
        ethics = ethics
        if(ethics!=ONE and ethics!=0):
            ethics = ONE
        # set ethicality for forked event
        if(forkedOverThisEvent):
            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
            if(forkedOverEthicality):
                oldEthical = ethic_catch(self.getEthical(event))
                if(oldEthical == ONE):
                    ethics = 0
                else:
                    ethics = ONE
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            ethics = (self.getForkEthicality(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            self.setForkEthicality(event, ethics)
        # set ethicality for a regular event
        else:
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            if(roundTwo):
                ethics = (self.getEthics(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            else:
                ethics = (self.getEthics(event)*self.getNumReportsEvent(branch, votePeriod, event) + ethics) / (self.getNumReportsEvent(branch, votePeriod, event) + 1)
            self.setEthics(eventID, ethics)
        self.addReportToEvent(branch, votePeriod, eventID, msg.sender)
        # round 2 and fork events are weighted by rep    
        if(roundTwo or forkedOverThisEvent):
            self.addRepEvent(branch, votePeriod, event, self.getBeforeRep(branch, votePeriod, msg.sender))
        reportsNum = self.getLesserReportNum(branch, votePeriod, event)
        paidBack = self.getReportersPaidSoFar(branch, event)
        diff = reportsNum - paidBack
        if(diff >= 1):
            self.addReportersPaidSoFar(branch, event)
            self.subtractCash(branch, 3500000*tx.gasprice*ONE / WEITOETH)
            self.addCash(msg.sender, 3500000*tx.gasprice*ONE / WEITOETH)
        return(1)
    return(-2)

# validates and submits report
# weights reports by rep if round 2 and fork
def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):
    outcome = 0
    # binary
    if(self.getNumOutcomes(eventID)==2 and self.getMaxValue(eventID)==TWO && self.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == catch(self.getUncaughtOutcome(eventID))):
                return(-4)
            outcome = (self.getForkOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                outcome = (self.getUncaughtOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            else:
                outcome = (self.getUncaughtOutcome(eventID)*self.getNumReportsEvent(branch, votePeriod, eventID) + report) / (self.getNumReportsEvent(branch, votePeriod, eventID) + 1)
            self.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report<=0):
            # 1 is the new 0
            report = 1
        if(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == self.getUncaughtOutcome(eventID)):
                return(-4)
            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
            self.addToWeightOfReport(votePeriod, eventID, report, balance)
            if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                self.setCurrentMode(votePeriod, eventID, report)
                self.setCurrentModeItems(votePeriod, eventID, report)
            outcome = self.getCurrentMode(votePeriod, eventID)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, balance)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, eventID, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            else:
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, 1)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, eventID, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            self.setUncaughtOutcome(eventID, outcome)
    return(report)

### Helper functions:
# calculates how many reports should be on a given event
def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):
    numMarkets = self.getNumMarkets(eventID)
    if(numMarkets>25):
        numMarkets = 25
    markets = array(numMarkets)
    markets = self.getMarkets(eventID, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        shareValue += self.getSharesValue(markets[i])
        totalFees += self.getFees(markets[i])
        i += 1
    totalVal = self.getShareValue(branch, votePeriod)
    shareFraction = shareValue*ONE/totalVal
    numReportersOnMarket = self.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * WEITOETH / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = min(canPayForThisManyReporters*ONE, numReportersOnMarket)
    if(self.getLesserReportNum(branch, period, event)==0):
        self.refundCost(sender, self.getSubsidy(branch, votePeriod, eventID))
        self.setLesserReportNum(branch, votePeriod, eventID, lesser)
    return(lesser)

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

macro POINTZEROSIX: 1106804644422573056
macro COSTPERREPORTER: 3500000

def createSingleEventMarket(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):
    event = self.createEvent(branch, description, expDate, minValue, maxValue, numOutcomes, resolution)
    market = self.createMarket(branch, description, tradingFee, [event], tag1, tag2, tag3, makerFees, extraInfo)
    return(market)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# @return eventID if success
# error messages otherwise
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # 0: not enough money to pay fees or event already exists
    # -2: max value < min value
    # -9: would expire during non-reporting fork period
# .025 eth to create
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    periodLength = self.getPeriodLength(branch)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):
        return(-9)
    if(maxValue < minValue or (maxValue-minValue) < ONE):
        return(-2)
    eventID = 0
    if(periodLength && description != 0 && expDate > block.timestamp):
        eventinfo = string(8*32 + len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = msg.sender                                   #creator address
        eventinfo[4] = periodLength
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo + 8*32, description, len(description))
        eventID = sha3(eventinfo, chars=len(eventinfo))
    else:
        return(-1)
    if(numOutcomes < 2 || numOutcomes > 8):
        return(0)
    currentVotePeriod = self.getVotePeriod(branch)
    self.initiateOwner(eventID)
    if(!self.getCreator(eventID)):
        # see which future period it expires in && put the event in that bin
        # event voting periods - expDate / periodLength gives you the voting period #
        futurePeriod = expDate / periodLength
        if(self.setInfo(eventID, description, msg.sender, 0) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):
            return(eventID)
        else:
            return(0)
    else:
        return(0)

# tradingFee is a percent in fixedPoint
# @return marketID if success or 1 if on an oracle only branch creation we have success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired
    # -8: market already exists
    # -9: would expire during non-reporting fork period
# .05 eth to create
# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, tradingFee, events:arr, tag1, tag2, tag3, makerFees, extraInfo:str):
    if(makerFees<0 or makerFees > ONEHALF):
        return(0)
    periodLength = self.getPeriodLength(branch)
    # send this to branch
    creationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / (2*tradingFee)
    # gives ether/cash amount in fixed point
    minFee = COSTPERREPORTER*self.getBaseReporters(branch)*tx.gasprice*len(events)*ONE/WEITOETH
    if(creationFee < minFee):
        creationFee = minFee
    if(self.balance(msg.sender) < creationFee):
        return(-4)
    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 || tradingFee < self.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
        
    event = events[0]
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports upto 3 dimensional markets
    if(eventNum > 3):
        return(-2)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(i!=0):
            if(event==events[i-1]):
                return(-6)
        expirationDate = self.getExpiration(event)
        futurePeriod = expirationDate / periodLength
        if(expirationDate < block.timestamp):
            return(-7)
        forkPeriod = self.getForkPeriod(branch)
        if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1))):
            return(-9)
        if(self.getEventBranch(event) != branch || !self.getCreator(event)):
            return(-1)
        # market's trading period is the same as the last expiring event in the market
        if(expirationDate > tradingPeriod):
            tradingPeriod = expirationDate
        eventsConcat += event
        if(!self.getBond(event)):
            # pay validity / indeterminate protection bond
            period = block.timestamp / TWENTYFOURHR
            validity_bond =  (creationFee * (1 + self.getPast24(period)) / (1 + self.getNumberEvents(branch, self.getVotePeriod(branch))))/2
            if(!self.sendFrom(event, validity_bond, msg.sender)):
                return(-4)
            self.setBond(event, validity_bond)
            self.addPast24(period)
        #scalars
        maxValue = self.getMaxValue(event)
        minValue = self.getMinValue(event)
        if((maxValue!=TWO || minValue !=ONE) && self.getNumOutcomes(event)==2):
            # is a valid scalar
            # cumulativeScale is the range of a scalar
            cumulativeScale += maxValue - minValue
        eventNumOutcomes = self.getNumOutcomes(event)
        if(i==0):
            numOutcomes += eventNumOutcomes
        else:
            numOutcomes *= eventNumOutcomes
        i += 1
    if(numOutcomes > 8):
        return(-3)
    if(cumulativeScale==0):
        cumulativeScale = ONE
    lastExpDate = tradingPeriod
    tradingPeriod = (tradingPeriod / periodLength)

    # formation of marketID (hash)
    marketinfo = string(8*32 + len(description))
    marketinfo[0] = tradingPeriod
    marketinfo[1] = tradingFee
    marketinfo[2] = block.timestamp
    marketinfo[3] = tag1
    marketinfo[4] = tag2
    marketinfo[5] = tag3
    marketinfo[6] = lastExpDate
    marketinfo[7] = len(description)
    mcopy(marketinfo + 8*32, description, chars=len(description))
    marketID = sha3(marketinfo, chars=len(marketinfo))
    self.addToMarketsHash(branch, marketID)
    self.initiateOwner(marketID)
    # pay numOutcomes fee
    # if it's already been created return 0
    if(self.getCreator(marketID) || self.getMarketNumOutcomes(marketID)):
        return(-8)
    if(!self.getOracleOnly(branch) && self.balance(msg.sender) < creationFee):
        return(-4)
    # need at least 1.2M gas @ gas price to cover resolution + 1M for each additional event + 500k per event to calc. num reports for it
    if(msg.value < (1200000*tx.gasprice + 1000000*tx.gasprice*(eventNum-1) + 500000*eventNum*tx.gasprice)):
        return(0)
    if(self.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*eventNum*tx.gasprice)) && self.setInfo(marketID, description, msg.sender, creationFee) && self.addMarketToBranch(branch, marketID) && self.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*tx.gasprice, creationFee, lastExpDate)):
        i = 0
        while i < len(events):
            self.addMarket(events[i], marketID)
            expirationDate = self.getExpiration(event)
            futurePeriod = expirationDate / periodLength
            if(self.getEvent(branch, futurePeriod, self.getEventIndex(futurePeriod, events[i]))!=events[i]):
                self.addEvent(branch, futurePeriod, events[i], 500000*tx.gasprice)
                # cost for calculating num. of reports for an event
                self.send(EXPEVENTS, 500000*tx.gasprice)
            i += 1
        return(marketID)
    else:
        return(0)

def updateTradingFee(branch, market, tradingFee):
    refund()
    if(msg.sender != self.getCreator(market) || tx.origin != self.getCreator(market)):
        return(-4)
    oldFee = self.getTradingFee(market)
    oldCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / oldFee
    newCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / tradingFee
    if(tradingFee < self.getMinTradingFee(branch) or tradingFee > oldFee):
        return(-1)
    self.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender)
    return(self.setTradingFee(market, tradingFee))

# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    refund()
    # can't do while forking
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    currentPeriod = block.timestamp / periodLength
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1)):
        return(-1)
    numEvents = self.getNumEvents(market)
    # if market closed or already pushed forward, return 0
    if(self.getOneWinningOutcome(market, 0) or self.getPushedForward(market)):
        return(-2)
    if(self.sendFrom(market, numEvents*self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):
        return(-3)
    i = 0
    events = array(3)
    # for each event in market
    while i < numEvents:
        events[i] = self.getMarketEvent(market, i)
        expiration = self.getExpiration(events[i])
        if(self.getRejectedPeriod(events[i]) || expiration!=self.getOriginalExpiration(events[i]) || self.getOutcome(events[i]) || self.getRoundTwo(events[i]) || expiration/periodLength==block.timestamp/periodLength):
            return(-4)
        i += 1
    i = 0
    while i < numEvents:
        # push into next vote period
        period = self.getVotePeriod(branch)
        # figure out what's going on with subsidy system here
        self.addEvent(branch, period+1, events[i], 0)
        # set event expiration date to be after the current reporting period ends
        self.setExpiration(events[i], block.timestamp)
        self.setTradingPeriod(market, period+1)
        self.setPushedForward(market, 1, msg.sender)
        self.setEventPushedUp(events[i], 1)
        i += 1
    return(1)
inset('refund.se')

# buys amount of every outcome
# cost 850k gas
def buyCompleteSets(market, amount):
    refund()
    if(!self.getCreationTime(market)):
        return(0)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    cost = amount*cumScale/ONE
    if(self.balance(msg.sender) < cost):
        return(-3)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    self.sendFrom(market, cost, msg.sender)
    return(1)

    
# sells amount of every outcome [if user owns it]
def sellCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    branch = self.getBranchID(market)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-2)
    # these prices are in fixed point
    cost = amount*cumScale/ONE
    i = 1
    while i <= numOutcomes:
        if(self.getParticipantSharesPurchased(market, participantNumber, i) < amount):
            return(-3)
        i += 1
    i = 1
    while i <= numOutcomes:
        self.modifyShares(market, i, -amount)
        self.modifyParticipantShares(market, participantNumber, i, -amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, -amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), -amount*cumScale/ONE)
    # send funds from the market to the user acc.
    self.subtractCash(market, cost)
    self.addCash(msg.sender, cost)
    return(1)
inset('refund.se')

# sender/owner, then spender
data amountCanSpend[][]

event Transfer(_from:indexed, _to:indexed, _value)
event Approval(_owner:indexed, _spender:indexed, value)

# fix sender, tx.origin stuff here

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    refund()
    # Rep cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.getVotePeriod(branch)
    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting
    # use a diff. fun. than getReport here
    #if(value<=0 || self.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || self.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || self.getReport(branch, currentVotePeriod, recver, 0) != 0):
    # self.getNumReportsActual(branch, currentVotePeriod, msg.sender)
    #    return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    # need to check all this for the person it's being sent to as well
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    #if(self.getRRUpToDate()!=1):
    #    doIt()
    #    self.RRDone = true
    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):
    #    self.collectFees(lastPeriod)
    # before rep, after rep, balance
    # person you're sending to needs rr up to date / done as well
    # auto increment vote period if needed
    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one, only if in first half of period
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractRep(branch, senderIndex, value) && self.addRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
# sendDormantRep
def transfer(branch, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = msg.sender
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=msg.sender):
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            log(type=Transfer, msg.sender, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# fails unless from has authorized sender
def transferFrom(branch, from, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = from
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=from):
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            self.amountCanSpend[from][msg.sender] -= value
            log(type=Transfer, from, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
    
# allows spender to withdraw from your account
def approve(branch, spender, value):
    self.amountCanSpend[msg.sender][spender] = value
    log(type=Approval, msg.sender, spender, value)
    return(1)

# returns amount spender can withdraw from owner
def allowance(owner, spender):
    return(self.amountCanSpend[owner][spender])

# error messages
    # -1: not in first half of reporting period
# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization
def convertToDormantRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
		# benny comment:
            #```Maybe still have this sort-of variable "power" to it, but REP initially doesn't have "full-power", or REP that hasn't been used to report over the past week has now let it's "power-meter" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch "on" or switch "off" the self. If a user knows, "I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power", well that's pretty good incentive to keep the user active, without actually taking it from them.```

    if(value<=0):
        return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    #if(self.getRRUpToDate()!=1):
    #    doIt()

    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractRep(branch, senderIndex, value) && self.addDormantRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, -value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# error messages
    # -1: not in first half of reporting period
def convertToActiveRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
      
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    if(value<=0):
        return(0)

    #if(self.getRRUpToDate()):
        #doIt()
    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
        
    
macro hasReported($branch, $period):
    self.getNumReportsActual($branch, $period, msg.sender)
    

inset('refund.se')

macro POINTNINE: 16602069666338596864

# call when a user who hasn't reported for a while wants to start again and needs to catch up on penalizations
# ex:
    #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period
    #add some events to period 0
    #increment
    #period 1 voteperiod 0 - shouldn't be penalizing anything yet
    #increment
    #period 2 voteperiod 1 - penalize voteperiod 0
# ex 2:
    #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period
    #add some events to period 100
    #increment to period 101
    #period 101, voteperiod 100 - shouldn't be penalizing anything yet
    #increment
    #period 102, voteperiod 101 - penalize voteperiod 100
def penalizationCatchup(branch, sender):
    refund()
    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    # find delta between this last period and last penalized up to
    lastPeriodPenalized = self.getPenalizedUpTo(branch, sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    oldRep = self.getRepBalance(branch, sender)
    if(lastPeriodPenalized!=lastPeriod && !self.getNumReportsActual(branch, lastPeriod, sender)):
        if(delta <= 0):
            return(0)
        # dock 10% for each period they didn't penalize on
        smoothedRep = oldRep*POINTNINE/ONE
        i = 1
        # delta 22 thing, if >22, max is 23 [1 above, 1 below, and 21 in while loop]
        if(delta>22):
            smoothedRep = smoothedRep*POINTNINE/ONE
            delta = 22
        while i < delta:
            smoothedRep = smoothedRep*POINTNINE/ONE
            i += 1
        # and send it to branch for penalty rep collection
        repChange = oldRep - smoothedRep
        # removes rep from reporter who lost it
        self.subtractRep(branch, self.repIDToIndex(branch, sender), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), repChange)
        self.setPenalizedUpTo(branch, sender, lastPeriod)
        return([delta, oldRep, smoothedRep, repChange]: arr)
    else:
        return(0)
inset('refund.se')

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

def catch(x):
    refund()
    return(catch(x))

## helper functions:
macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalarorcat, $mode, $ethicOutcome):
    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and $market remains with old expiration date
    # UI needs to call penalizeWrong for ones that are pushed back in both pushed back period and regular period with actual reporting
    $indeterminate = ONEHALF*3
    if(($fxpOutcome == $indeterminate or $mode==ONEHALF) && self.getEventPushedUp($event)):
        if(self.getPushedForward($market)):
            self.addCash($branch, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        self.setTradingPeriod($market, self.getOriginalTradingPeriod($market))
        self.setPushedForward($market, 0, msg.sender)
        self.setNumReportsExpectedEvent($branch, $votingPeriodEvent, $event, 0)
        self.setNumReportsEvent($branch, $votingPeriodEvent, $event, 0)
        #set outcome to 0
        self.setOutcome($event, 0)
        self.setmode($event, 0)
        self.setEthics($event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome($event, 0)
        self.setEventPushedUp($event, 0)
        # need to store which period it was "rejected" in
        self.setRejected($event, self.getExpiration($event)/$periodLength)
        #set $event expiration to be the old date
        self.setExpiration($event, self.getOriginalExpiration($event))
        -6
    elif(($fxpOutcome==$indeterminate or $mode==ONEHALF) || !$ethical):
        # give $event bond money to reporters
        self.subtractCash($event, self.getBond($event))
        self.addCash($branch, self.getBond($event))
        # not $ethical is same as .5 outcome
        if($scalarorcat):
            # mode is used to compare for reporting acc. so still the same as reported outcome, but resolving the market as .5
            self.setOutcome($event, $ethicOutcome)
        else:
            self.setOutcome($event, $indeterminate)
        1
    else:
        # return bond
        self.subtractCash($event, self.getBond($event))
        self.addCash(self.getCreator($event), self.getBond($event))
        if(self.getPushedForward($market)):
            self.addCash(self.getBondsMan($market), self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        if(self.getEventPushedUp($event)):
            # delete old $event from future events exp
            $period = self.getOriginalExpiration($event)/$periodLength
            self.removeEvent($branch, $period)
            self.deleteEvent($branch, $period, $event)
        1

def resolveBinary(event, market, branch, votingPeriodEvent):
    refund()
    fxpOutcome = catch(self.getUncaughtOutcome(event))
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    self.setOutcome(event, fxpOutcome)
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 0, 0, 0)
    return(val)

def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent):
    refund()
    mode = self.getUncaughtOutcome(event)
    self.setmode(event, mode)
    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
    self.setOutcome(event, fxpOutcome)
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, mode, ethicOutcome)
    return(val)

def determineWinningOutcomes(events: arr, numberEvents, branch, market):
    refund()
    n = 0
    winningOutcomes = array(8)
    while n < numberEvents:
        fxpOutcome = self.getOutcome(events[n])
        outcome = fxpOutcome/ONE
        if(n==0):
            #scalar or .5
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                winningOutcomes[0] = 1
                winningOutcomes[1] = 2
            # anything besides scalar or .5
            else:
                winningOutcomes[0] += outcome
        elif(n==1):
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                # scalar, scalar
                if(winningOutcomes[1]):
                    winningOutcomes[2] = 3
                    winningOutcomes[3] = 4
                # nonscalar, scalar
                else:
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] = winningOutcomes[0] + self.getNumOutcomes(events[n-1])
            # scalar, nonscalar
            elif(winningOutcomes[1]):
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
                winningOutcomes[1] += self.getNumOutcomes(events[n-1])*(outcome-1)
            # nonscalar, nonscalar
            else:
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
        elif(n==2):
            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):
                #scalar, scalar, scalar
                if(winningOutcomes[3]):
                    winningOutcomes[4] = 5
                    winningOutcomes[5] = 6
                    winningOutcomes[6] = 7
                    winningOutcomes[7] = 8
                #scalar, nonscalar, scalar
                #nonscalar, scalar, scalar
                elif(winningOutcomes[1]):
                    #winningOutcomes[0] = winningOutcomes[0]
                    #winningOutcomes[1] = winningOutcomes[1]
                    winningOutcomes[2] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                    winningOutcomes[3] += winningOutcomes[1] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                #nonscalar, nonscalar, scalar
                elif(winningOutcomes[1]==0):
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
            else:
                #scalar, scalar, nonscalar
                if(winningOutcomes[3]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[2] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[3] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #scalar, nonscalar, nonscalar
                #nonscalar, scalar, nonscalar
                elif(winningOutcomes[1]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #nonscalar, nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
        n+=1
    return(winningOutcomes: arr)
inset('refund.se')

# rbcr is done as a normal event where everyone reports on it
# only called on the fork not the parent, normal penalization except the values are forkOutcome and forkEthicality as opposed to anything else
# some rep from this goes to bond poster, original / last period report is actually what a user reported on the parent for the round 2 bond vote, they lose rep as well as people this time who report wrong
# branch is fork
# fork event needs to be resolved first before this can be called
# Errors:
    # -2: already past first half of new period and needed to penalize before then
    # -4: fork event isn't resolved yet
    # -5: already done for all events in this period
def penalizeOnForkedEvent(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    if(repBalance < ONE):
        return(0)
    forkOutcome = self.getForkOutcome(event)
    outcome = catch(forkOutcome)
    if(scalar(event) or categorical(event)):
        outcome = forkOut
    p = self.proportionCorrectForkEvent(event)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    bond = self.getBondAmount(event)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    # means event / fork isn't resolved
    if(self.getForkedDone(event)==0):
        return(-4)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)
    # penalization on a forked event
    # if didn't report [reportValue of 0] then it's a bad report here
    # Do (for each user) based on forking report and final outcome
    if(!self.getPenalized(branch, lastPeriod, msg.sender, event)):
        if(outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome    
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 1 / (number of events you reported on last period) for forking
            # use .10 as a max penalty per fork event
            if(numReportedOn<10):
                repChange = oldRep * (ONE - ONE/10)/ONE + newRep*(ONE/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - ONE/numReportedOn)/ONE + newRep*(ONE/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
            if(ethics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            if(self.getForkBondPaid(event) < self.getBondAmount(event)*2 && repChange < 0):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(event)), -repChange)
                self.adjForkBondPaid(event, -1*repChange)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

def proportionCorrectForkEvent(event):
    refund()
    p = 0
    outcome = catch(self.getForkOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getForkOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
inset('refund.se')

macro POINTZEROONE: 184467440737095520

macro MINBOND: 200*2**64

# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost
    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.
        # needs an abs min of ~200 rep.
# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.
def roundTwoPostBond(branch, event, eventIndex, votePeriod):
    refund()
    if(self.getVotePeriod(branch)!=votePeriod):
        return(0)
    # if pushed forward don't allow
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-1)
    market = self.getMarket(event, 0)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod == votePeriod or (forkPeriod+1) == votePeriod):
        return(0)
    # todo find actual cost
    if(msg.value < 500000*tx.gasprice):
        return(0)
    send(BACKSTOPS, msg.value)
    self.setRoundTwoRefund(event, msg.value)
    avgAdjCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    # if so, we're in the final 24 hours and event is in this branch + votePeriod
    if(!resolving && block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && eventID!=0 && event==eventID && self.getRoundTwo(event)==0 && self.getForked(event)==0):
        if(self.sendReputation(branch, event, bond)==0):
            return(0)
        period = self.getVotePeriod(branch)
        # remove from events in # to report on calc for last period
        self.removeEvent(branch, period)
        # makes event required reporting in round 2 (the next period) as well
        self.setEventRequired(branch, period+1, event)
        # push event into next period
        self.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
        self.setExpiration(event, block.timestamp)
        # set round two to true so can't be done again
        self.setRoundTwo(event, 1)
        self.setOriginalVotePeriod(event, votePeriod)
        if(scalar(event) or categorical(event)):
            self.setOriginalOutcome(event, self.getUncaughtOutcome(event))
        else:
            self.setOriginalOutcome(event, catch(self.getUncaughtOutcome(event)))
        self.setOriginalEthicality(event, ethic_catch(self.getEthical(event)))
        self.addRoundTwo(branch, period)
        self.setBondPoster(event, msg.sender)
        self.setUncaughtOutcome(event, 0)
        self.setmode(event, 0)
        self.setEthics(event, 0)
        return(1)

# resolves a round 2 event
def roundTwoResolve(branch, event, eventIndex, sender):
    refund()
    overruled = 1
    votePeriod = self.getVotePeriod(branch)
    market = self.getMarket(event, 0)
    avgAdjCost = self.getInitialBalance(branch, votePeriod-1)/self.getNumberEvents(branch, votePeriod-1)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    votedOnAgain = 0
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(scalar(event) or categorical(event)):
        if(self.getOriginalOutcome(event) == self.getUncaughtOutcome(event) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
            overruled = 0
    elif(self.getOriginalOutcome(event) == catch(self.getUncaughtOutcome(event)) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
        overruled = 0
    if(votePeriod > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    forkPeriod = self.getForkPeriod(branch)
    # if forking and this isn't the fork event
    if(forkPeriod==votePeriod or votePeriod==(forkPeriod+1) && (self.getEventForkedOver(branch)!=event && self.getBondReturned(event)==0 && self.getRoundTwo(event))):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
        self.setRoundTwo(event, 0)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # overruled and bond poster wasn't malicious
    elif(overruled && votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event)
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rbcr for the round 2 reporting [don't count ethicality here]
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(2*bond)
    # same as original consensus and bond poster was wrong
    elif(votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # lose bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, branch), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event)
        # rbcr from original period/orig. outcome stands, rbcr from round 2 happens as usual as well
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # not voted on again yet
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==2**6Z)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# take from bond to pay for resolution of a round 2 event
def resolve(branch, event):
    refund()
    bond = self.getBond(event)
    ethical = ethic_catch(self.getEthical(event))
    self.setEthics(event, ethical)
    # binary
    if(binary(event)):
        fxpOutcome = catch(self.getUncaughtOutcome(event))
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as 1.5 outcome w/ binary
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = self.getUncaughtOutcome(event)
        self.setmode(event, mode)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome w/ scalar
            # mode is used to compare for reporting acc. so still the same as reported outcome, but resolving the market as .5
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)
inset('refund.se')

event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528

#1. Record rep at start of report period [before rep in make reports]
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
#5. If you don't do it for all events or don't penalize for not reporting enough, autolose 10% rep each period one does this (b/c they're trying to cheat)
# Errors:
    #  0: event is a fork event
    # -1: need to penalize in round 2 penalize function
    # -2: already past first half of new period and needed to penalize before then
    # -4: in fork period only thing that rbcr is done on is the round 2 event in the original branch via round 2 penalize
    # -5: already done for all events in this period
    # -6: forked events should be penalized using the fork penalization function
    # -7: no outcome
# force event to be resolved first if it can be
def penalizeWrong(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    rejected = self.getRejected(event)
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    roundTwo = self.getRoundTwo(event)
    uncaught = self.getUncaughtOutcome(event)
    if(repBalance < ONE):
        return(0)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    if(forkPeriod == lastPeriod):
        return(-4)
    elif(self.getForked(event)):
        return(-6)
    # if no events in a period
    elif(self.getNumberEvents(branch, lastPeriod)<=0):
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, repBalance)
        return(1)
    elif(roundTwo && outcome!=0):
        return(-1)
    
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    elif(!uncaught && !(rejected && self.getRejectedPeriod(event)==lastPeriod)):
        if(self.closeMarket(branch, self.getMarket(event, 0), msg.sender)!=1):
            return(-7)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    p = self.proportionCorrect(event)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    # commented for testing
    #elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
    #    return(-2)
    # lastperiod is where people who originally voted on a round 2 event voted the first time - want num events penalized to go up but not to actually be penalized for it yet
        # shouldn't be penalized until the next period resolution is over [since it's a round 2 event]
    if(roundTwo && !self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
        # if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event
            # unless this just happened to them last period and they reported correctly then
    # if this event was a pushed forward event that got rejected, don't penalize on it, only penalize on the final reporting, i.e. if appealed don't allow rbcr until after the appeal process is over in the first period
    elif(!self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && rejected && self.getRejectedPeriod(event)==lastPeriod):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    elif(!self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && outcome!=0):
        # wrong
        if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome
                # perhaps for right we should do diff todo so adds to more than 1 --- can actually do proportion correct for this i think now
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for forking and backstop 1
        # use .02 as a max penalty per event
        if(numReportedOn<10):
            repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep
        else:
            repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        log(type=penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

# ui has to call this to stay cheap / not check it elsewhere
def incrementPeriodAfterReporting(branch):
    refund()
    # do this after reporting is finished
    if(periodOver(branch)):
        period = block.timestamp / self.getPeriodLength($branch) - 1
        lastPeriod = period - 1
        percentAppealed = (self.getNumRoundTwo(branch, period)*ONE/self.getNumberEvents(branch, period) + self.getNumRoundTwo(branch, lastPeriod)*ONE/self.getNumberEvents(branch, lastPeriod)) / 2
        self.incrementPeriod(branch)
        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on
        base_reporter_quantity = 2*(3*ONE + ((333*ONE * Percent_Appealed/ONE)**3 / 2**128))/ONE
        self.setBaseReportersLastPeriod(branch, self.getBaseReporters(branch))
        self.setBaseReporters(branch, base_reporter_quantity)
        return(1)
    else:
        return(0)

### Helper functions:
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# put in consensus data
def proportionCorrect(event):
    refund()
    p = 0
    outcome = catch(self.getUncaughtOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getUncaughtOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.timestamp / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
        
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

data slashed[][]

# anti cheat provide ballot and randomNum mechanism steal deposit
# Returns:
    # 0: not a valid claim
    # -2: reporter doesn't exist
def slashRep(branch, salt, report, reporter, eventID, testing):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    votePeriod = self.getVotePeriod(branch)
    # if actually past vote period dont allow it
    if(!testing):
        votePeriodShouldBe = block.timestamp / periodLength - 1
        if(votePeriodShouldBe!=votePeriod):
            return(0)
    realHash = self.getReportHash(branch, votePeriod, reporter, eventID)
    hashInfo = array(4)
    hashInfo[0] = reporter
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    if(reportHash!=realHash):
        return(0)
    else:
        if(!self.slashed[votePeriod][reporter]):
            reporterIndex = self.repIDToIndex(branch, reporter)
            trutherIndex = self.repIDToIndex(branch, msg.sender)
            # if the truther's rep. account doesn't exist, make one
            if(self.getReporterID(branch, trutherIndex)!=msg.sender):
                trutherIndex = self.getNumberReporters(branch)
                self.addReporter(branch, msg.sender)
            if(self.getReporterID(branch, reporterIndex)!=reporter):
                return(-2)
            reporterBalance = self.getRepBalance(branch, reporter)
            self.setRep(branch, reporterIndex, 0)
            trutherBalance = self.getRepBalance(branch, msg.sender)
            self.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*ONEHALF / ONE))
            self.slashed[votePeriod][reporter] = 1
        else:
            return(0)
    return(reporterBalance)
inset('refund.se')

macro POINTZEROONE: 184467440737095520

# UI has to handle function calls for these

#Notes:
    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.  
    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.  
    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.  
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rbcr on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong
    # no reporting or rbcr in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
def move_event(event):
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    branch = self.getEventBranch(event)
    eventForkedOver = self.getEventForkedOver(branch)
    expPeriod = self.getExpiration(event)/self.getPeriodLength(branch)
    eventIndex = self.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    if(forkPeriod && currentPeriod == (forkPeriod+2) && !self.getOutcome(event) && !self.getMoved(event)):
        winner = self.getResolved(branch, forkPeriod)
        if(winner==0):
            winner = self.resolve_fork(branch)
        self.setMoved(event)
        if(event == eventForkedOver):
            return(1)
        elif(winner == self.getEventBranch(event)):
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)
            
            # leave event here
            # if should've resolved in past periods
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod, eventID)
                self.setExpiration(event, block.timestamp)
            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
        else:
            self.setBranch(event, winner)
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)

            # move event to fork
            # and place it into the next reporting period w/ outcomes to 0
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod, eventID)
                self.setExpiration(event, block.timestamp)
            else:
                # push into period it wouldve expired in
                self.addEvent(branch, expPeriod, eventID)
                # expiration time doesnt need to change
    else:
        return(0)

# parent branch is branch here
def resolve_fork(branch):
    # do whitelist
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    origCap = self.exchangeRate(branch)
    fork = self.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origcap >= forkCap):
        winner = branch
        self.setResolved(branch, forkPeriod, winner)
        return(winner)
    else:
        winner = fork
        self.setResolved(branch, forkPeriod, winner)
        return(winner)

# Resolve fork method that gets exchange rate
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    #return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back
# bond is 1% of rep
def fork(event, branch, forkedOverEthicality):
    forkPeriod = self.getForkPeriod(branch)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    # no fork for 1 period after a fork
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1) or currentPeriod == (forkPeriod+2)):
        return(-3)
    if(!self.getRoundTwo(event) || self.getFinal(event) || self.getForked(event)):
        return(-1)
    if(self.getBranch(event)!=branch):
        return(0)
    # todo find actual gas cost for resolution here and charge that
    if(msg.value < 200000*tx.gasprice):
        return(0)
    send(CONSENSUS, msg.value)
    self.setRefund(event, msg.value)
    # if pushed forward event don't allow
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-4)
    # if in last 48 hr of period
    if(block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && self.getUncaughtOutcome(event)!=0 && !self.getForked(event)):
        bond = POINTZEROONE*self.getTotalRep(branch)/ONE
        self.setBondAmount(event, bond)
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(self.sendReputation(branch, event, bond)==0):
            return(-2)
        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = self.createSubbranch(text("fork"), self.getPeriodLength(branch), branch, self.getMinTradingFee(branch), 0)
        self.setFork(newBranch)
        period = self.getVotePeriod(newBranch)
        self.setEventRequired(newBranch, period+1, event)
        self.addEvent(newBranch, period+1, event)
        self.setExpiration(event, block.timestamp)
        self.setOriginalBranch(event, branch)
        self.setForkBondPoster(event, msg.sender)
        self.setForked(event)
        self.setFinal(event)
        self.setForkPeriod(branch)
        self.setForkPeriod(newBranch)
        self.setEventForkedOver(newBranch, event)
        self.setEventForkedOver(branch, event)
        if(forkedOverEthicality):
            self.setForkedOverEthicality(event)
        # return round 2 bond on orig. branch
        market = self.getMarket(event, 0)
        avgAdjCost = self.getInitialBalance(branch, period-1)/self.getNumberEvents(branch, period-1)
        bond = avgAdjCost + self.getSharesValue(market)*(184467440737095520 + self.getTradingFee(market)/2) / 2**64
        bond = min(bond, 200*ONE)
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
    else:
        return(0)


# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
def resolveForkedEvent(branch, event):
    refund()
    bond = 100*ONE
    votedOnAgain = 0
    # checks for orig. branch
    if(self.getBranch(event)!=branch or self.getEventForkedOver(branch)!=event):
        return(0)
    if(self.getVotePeriod(branch) > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!self.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        self.setForkDone(event)
        self.doRefund(msg.sender, event)
        return(1)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
def resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = self.getBond(event)
    winner = self.getResolved(branch, self.getForkPeriod(branch))
    if(!winner):
        return(-5)
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            fxpOutcome = catch(self.getUncaughtOutcome(event))
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            fxpOutcome = catch(self.getForkOutcome(event))
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setOutcome(event, fxpOutcome)
        self.setEthics(event, ethical)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            mode = self.getUncaughtOutcome(event)
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            mode = self.getForkOutcome(event)
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setmode(event, mode)
        self.setEthics(event, ethical)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
inset('refund.se')

#event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
#event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Trade
#
# Errors:
    # -1: oracle only branch
    # -2: bad trade hash
    # -3: trader doesn't exist / own shares in this market
    # -4: must buy at least .00000001 in value
    # 10: insufficient balance
#Exchange(Market, outcome, sender, amount, receiver, payment) - transfers amount shares from sender to receiver for payment amount
#max value is max amount to spend to buy [including fees]
#max amount is max shares to sell
# 500k gas
# picks orders off the book
def trade(max_value, max_amount, trade_ids:arr):
    refund()
    if(self.getOracleOnly(branch)):
        return([-1]: arr)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return([-2]: arr)
    max_value = max_value
    max_amount = max_amount
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
        if !trade:
            return([0]: arr)
        # Get market
        type = trade[1]
        market = trade[2]
        creator = self.getCreator(market)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        if(owner == msg.sender or owner == tx.origin):
            return([0]: arr)
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= trade[6]:
            return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
        branch = self.getBranchID(market)
        trading_fee = self.getTradingFee(market)
        cumScale = self.getCumScale(market)
        fee = fee_percent(trading_fee, price, cumScale)

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            participantNumber = self.getParticipantNumber(market, msg.sender)
            balance = self.getParticipantSharesPurchased(market, participantNumber, outcome)
            if(balance > 0 and max_amount > 0):
                if(self.getParticipantID(market, participantNumber) != msg.sender):
                    return([-3]: arr)
                makerFeeRate = self.getMakerFees(market)
                sender = self.getParticipantNumber(market, msg.sender)
                ownerNum = self.getParticipantNumber(market, owner)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/ONE
                # must trade at least 0.00000001 in value
                if(value < 184467440738):
                    return([-4]: arr)
                # Update trade amount or remove
                if fill < amount:
                    self.fill_trade(trade_id, fill)
                else:
                    remove_trade(trade_id, market)
                # Update balances
                self.modifyParticipantShares(market, sender, outcome, -fill, 0)
                self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                # THREEFOURTHS is 3/4
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                self.addCash(msg.sender, value-takerFeesTotal)
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                self.subtractCash(market, value)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # needed to keep track of how many fees a market has raised
                # only count branch fees here
                self.addFees(market, fee/2+branchFees)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)
        elif type == ASK:
            balance = self.balance(msg.sender)
            makerFeeRate = self.getMakerFees(market)
            feeRate = 3*2**64/2**65 - makerFeeRate
            maxAmountGivenBalance = balance*2**64/(feeRate+2**64)
            max_value = min(maxAmountGivenBalance, max_value)
            if max_value > 0:
                # Calculate value of trade
                trade_value = amount * price / ONE
                # Determine fill value
                value = min(max_value, trade_value)
                if(value < 184467440738):
                    return([-4]: arr)
                fee = value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                if(balance < (value + takerFeesTotal)):
                    return([INSUFFICIENT_BALANCE]: arr)
                fill = 0
                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = value*ONE / price
                    self.fill_trade(trade_id, fill)
                else:
                    fill = amount
                    remove_trade(trade_id, market)
                participantNumber = self.getParticipantNumber(market, msg.sender)
                # if participant doesn't exist in market, add them
                if(msg.sender != self.getParticipantID(market, participantNumber)):
                    participantNumber = self.addParticipant(market, msg.sender)
                
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                self.modifyParticipantShares(market, participantNumber, outcome, fill, 0)
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                cost = value + takerFeesTotal
                self.addCash(owner, value)
                self.subtractCash(msg.sender, cost)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # only count branch fees here
                self.addFees(market, fee/2+branchFees)
                # Update max_value
                max_value -= value
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, BID, price, fill, trade_id, outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)

        # Log price, fill amount, type and timestamp
        self.setPrice(market, outcome, price)
        log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1
    return([SUCCESS, max_value, max_amount]: arr)
macro refund():
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# four winning outcomes
def fourOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
    scalarOne = -1
    scalarTwo = -1
    if(((self.getMaxValue(events[0])!=TWO || self.getMinValue(events[0])!=ONE) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*ONEHALF):
        scalarOne = 0
    if(((self.getMaxValue(events[1])!=TWO || self.getMinValue(events[1])!=ONE) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*ONEHALF):
        if(scalarOne == -1):
            scalarOne = 1
        else:
            scalarTwo = 1
    elif(((self.getMaxValue(events[2])!=TWO || self.getMinValue(events[2])!=ONE) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*ONEHALF):
        scalarTwo = 2
    outcomeOne = self.getOutcome(events[scalarOne])
    minValueOne = self.getMinValue(events[scalarOne])
    maxValueOne = self.getMaxValue(events[scalarOne])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[scalarTwo])
    minValueTwo = self.getMinValue(events[scalarTwo])
    maxValueTwo = self.getMaxValue(events[scalarTwo])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo

    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)
    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)
    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent

    # price is in fixed point
    # share four goes with the high-high side
    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / ONE
    # share three goes with the low-high side
    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / ONE
    # share two goes with the high-low side
    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / ONE
    # share one goes with the low-low
    # both fixed point so div by ONE to keep in fixed point
    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / ONE
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    n = 0
    cumScale = self.getCumScale(market)
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        # low-low
        if(n==0):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
        # high-low
        elif(n==1):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
        # low-high
        elif(n==2):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare3/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare3/ONE)
        # high-high
        elif(n==3):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare4/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare4/ONE)
        n+=1
    return(1)
inset('refund.se')

# eight winning outcomes
def eightOutcomes(market, winningOutcome: arr, events: arr, sender):
    refund()
    outcomeOne = self.getOutcome(events[0])
    minValueOne = self.getMinValue(events[0])
    maxValueOne = self.getMaxValue(events[0])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[1])
    minValueTwo = self.getMinValue(events[1])
    maxValueTwo = self.getMaxValue(events[1])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo
    outcomeThree = self.getOutcome(events[2])
    minValueThree = self.getMinValue(events[2])
    maxValueThree = self.getMaxValue(events[2])
    if(outcomeThree>maxValueThree):
        outcomeThree = maxValueThree
    elif(outcomeThree<minValueThree):
        outcomeThree = minValueThree

    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)
    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)
    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent
    outcomeThreeHighSidePercent = ONE*(outcomeThree - minValueThree) / (maxValueThree - minValueThree)
    outcomeThreeLowSidePercent = ONE - outcomeThreeHighSidePercent
            
    # price is in fixed point
    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
    pricePerShare = array(7)
    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (ONE * ONE)
    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)
    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)
    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)

    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    
    # for each winning outcome do...
    n = 0
    cumScale = self.getCumScale(market)
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare[n]/ONE)
        self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare[n]/ONE)
        n+=1
    return(1)
inset('refund.se')

# mutex result non scalar not .5
# one winning outcome
def oneOutcome(market, winningOutcome, sender, categoricalPointFive, numOutcomes):
    participantNumber = self.getParticipantNumber(market, sender)
    cumScale = self.getCumScale(market)
    if(categoricalPointFive):
        i = 0
        while(i < numOutcomes):
            sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, i+1)
            self.modifyParticipantShares(market, participantNumber, i+1, -sharesOwned)
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            self.addCash(participant, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            i+=1
    else:
        # distribute cashcoin to the people who won money by holding winning shares
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome)
        participant = self.getParticipantID(market, participantNumber)
        self.modifyParticipantShares(market, participantNumber, winningOutcome, -sharesOwned)
        self.subtractCash(market, sharesOwned*cumScale/ONE)
        self.addCash(participant, sharesOwned*cumScale/ONE)
    return(1)
inset('refund.se')


# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
    # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
# 2 means no errors but didnt report
def collectFees(branch, sender):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2):
        return(-2)
    if(!self.getRRDone(branch, sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    lastPeriod = self.getVotePeriod(branch) - 1
    # todo make so need 1 rep to claim fees
    if(!self.getFeesCollected(branch, sender, lastPeriod) && self.getNumReportsActual(branch, lastPeriod, sender)):
        newRep = self.getAfterRep(branch, lastPeriod, sender)
        denominator = self.getDenominator(branch, lastPeriod)
        if(!self.getFeeFirst(branch, lastPeriod)):
            self.setFeeFirst(branch, lastPeriod, 1)
            self.setPeriodBalance(branch, lastPeriod, self.getRepBalance(branch, branch))
        gainedRep = newRep * self.getPeriodBalance(branch, lastPeriod) / denominator
        #if(lostRep) newRep should be == self.getAfterRep(branch, period, sender) + gainedRep
        #if(gainedRep) newRep should be == self.getBeforeRep(branch, period, sender) + gainedRep
        self.addRep(branch, self.repIDToIndex(branch, sender), gainedRep)
        self.subtractRep(branch, self.repIDToIndex(branch, branch), gainedRep)
        cash = self.getInitialBalance(branch, lastPeriod) * newRep / denominator
        self.addCash(sender, cash)
        self.subtractCash(branch, cash)
        self.setFeesCollected(branch, sender, lastPeriod)
        # return not reported enough bond if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees
        if(self.getNotEnoughPenalized(branch, msg.sender, lastPeriod)==0 or self.getForkPeriod(branch)+1 == lastPeriod):
            self.doRefund(msg.sender, msg.sender)
        return(1)
    elif(!self.getFeesCollected(branch, sender, lastPeriod)):
        self.setFeesCollected(branch, sender, lastPeriod)
        return(2)
inset('refund.se')

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
	refund()
	length=self.Info[ID].descriptionLength
	return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
	refund()
	return(self.Info[ID].descriptionLength)

def getCreator(ID):
	refund()
	return(self.Info[ID].creator)

def getCreationFee(ID):
	refund()
	return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	# check that msg.sender is one of our function contracts
	if(self.Info[ID].creator == 0):
		save(self.Info[ID].description[0], description, chars=len(description))
		self.Info[ID].descriptionLength = len(description)
		self.Info[ID].creationFee = fee
		self.Info[ID].creator = creator
		return(1)
	else:
		return(0)

inset('refund.se')

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
# total rep is all the rep in augur
# active rep is the amount which is actually active
# fork is the child branch of a parent which forked
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    refund()
    return(self.whitelists[msg.sender].addresses[address])

def getActiveRep(branch):
    return(self.Reporting[branch].activeRep)
    
def adjustActiveRep(branch, amount):
    self.Reporting[branch].activeRep += amount
    return(1)

def setFork(branch):
    self.Reporting[branch].fork = branch
    return(1)
    
def getFork(branch):
    return(self.Reporting[branch].fork)

def checkContractWhitelist(contract, address):
    refund()
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    refund()
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
# getDormantRepBalance
def balanceOf(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)
    
# return total supply of dormant rep
def totalSupply(branch):
    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))

def getReporterID(branch, index):
    refund()
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    refund()
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    refund()
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = msg.sender
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    refund()
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    refund()
    return(self.Reporting[branch].repIDtoIndex[repID])

def hashReport(report: arr, salt):
    refund()
    hashInfo = array(len(report) + 2)
    hashInfo[0] = msg.sender
    hashInfo[1] = salt
    i = 2
    while i < (len(report) + 2):
        hashInfo[i] = report[i-2]
        i += 1
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    refund()
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = amount
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branchID].dormantRep[i].repValue = dormant
    self.Reporting[branch].activeRep += amount + repToBonderOrBranch
    self.Reporting[branchID].totalRep += amount + dormant + repToBonderOrBranch
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].activeRep += newRep - oldRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
# make this cheaper
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

inset('refund.se')

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

def fx_exp(x):
    refund()
    return(fx_exp(x))

def fx_log(x):
    refund()
    return(fx_log(x))

def sqrt(n):
    refund()
    val = n
    i = 0
    while i < 11:
        val = (val + n*ONE/val)/2
        i += 1
    return val
inset('refund.se')

data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned, bondPaid, refund)

data forking[](bondPoster, bondAmount, forkedOverEthicality, bondPaid, originalBranch, moved)

data resolved[][]

def setRoundTwoRefund(event, amt):
    self.roundTwo[event].refund = amt
    return(1)
    
def doRoundTwoRefund(sender, event):
    send(sender, self.roundTwo[event].refund)
    return(1)

def setForkBondPoster(event, poster):
    self.forking[event].bondPoster = poster
    return(1)

def getForkBondPoster(event):
    return(self.forking[event].bondPoster)

def setForkedOverEthicality(event):
    self.forking[event].forkedOverEthicality = 1
    return(1)

def getForkedOverEthicality(event):
    return(self.forking[event].forkedOverEthicality)
    
def adjForkBondPaid(event, amount):
    self.forking[event].bondPaid += amount
    return(1)

def getForkBondPaid(event):
    return(self.forking[event].bondPaid)

# sets bond amount for a fork bond
def setBondAmount(event, amount):
    self.forking[event].bondAmount = amount
    return(1)

# gets bond amount for a fork bond
def getBondAmount(event):
    return(self.forking[event].bondAmount)

def setOriginalBranch(event, branch):
    self.forking[event].originalBranch = branch
    return(1)

def getOriginalBranch(event):
    return(self.forking[event].originalBranch)
    
def setMoved(event):
    self.forking[event].moved = 1
    return(1)

def getMoved(event):
    return(self.forking[event].moved)
    
def setResolved(branch, forkPeriod, winner):
    self.resolved[branch][forkPeriod] = winner
    return(1)

def getResolved(branch, forkPeriod):
    return(self.resolved[branch][forkPeriod])

# gets how much of round 2 bond has been paid back
def getBondPaid(event):
    return(self.roundTwo[event].bondPaid)

# increases how much of round 2 bond has been paid back
def increaseBondPaid(event, amount):
    self.roundTwo[event].bondPaid += amount
    return(1)

# whether a round 2 bond's principle has been returned
def getBondReturned(event):
    return(self.roundTwo[event].bondReturned)
    
def setBondReturned(event):
    self.roundTwo[event].bondReturned = 1
    return(1)

def getRoundTwo(event):
    refund()
    return(self.roundTwo[event].roundTwo)
    
def setRoundTwo(event, roundTwo):
    self.roundTwo[event].roundTwo = roundTwo
    return(1)
    
def getBondPoster(event):
    refund()
    return(self.roundTwo[event].bondPoster)

def setBondPoster(event, bondPoster):
    self.roundTwo[event].bondPoster = bondPoster
    return(1)

# whether a round 2 event is final
def getFinal(event):
    refund()
    return(self.roundTwo[event].final)

def setFinal(event):
    self.roundTwo[event].final = 1
    return(1)
    
def getOriginalOutcome(event):
    refund()
    return(self.roundTwo[event].originalOutcome)

def setOriginalOutcome(event, originalOutcome):
    self.roundTwo[event].originalOutcome = originalOutcome
    return(1)

def getOriginalEthicality(event):
    refund()
    return(self.roundTwo[event].originalEthicality)
    
def setOriginalEthicality(event, ethicality):
    self.roundTwo[event].originalEthicality = ethicality
    return(1)

def getOriginalVotePeriod(event):
    refund()
    return(self.roundTwo[event].originalVotePeriod)

def setOriginalVotePeriod(event, period):
    self.roundTwo[event].originalVotePeriod = period
    return(1)

inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROONE: 184467440737095520

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
# subsidy is money for paying back a user for calculating the targeted num of reports for an event
data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents, subsidy[])

data EventIDToIndex[][]

# numReportsEvent is number of reports on an event, expected is how many have been committed for an event
# numReportsActual is the amount of reports a user has submitted in a period
# lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]
# periodRepConstant is 
data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], repEvent[][], lesserReportNum[][], periodRepConstant[][], reportersPaidSoFarForEvent[])

data requiredEvents[]

# branch, period as params
data numReqEvents[][]

data mode_items[][](report_value[], current_mode, current_mode_items)

def getReportersPaidSoFar(branch, event):
    return(self.branches[branch].reportersPaidSoFarForEvent[event])

def addReportersPaidSoFar(branch, event):
    self.branches[branch].reportersPaidSoFarForEvent[event] += 1
    return(1)
    
def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.EventsExpDates[branch][period].subsidy[event])

def getPeriodRepConstant(branch, votePeriod, sender):
    return(self.branches[branch].periodRepConstant[votePeriod][sender])

def setPeriodRepConstant(branch, votePeriod, sender, value):
    self.branches[branch].periodRepConstant[votePeriod][sender] = value
    return(1)

def getLesserReportNum(branch, period, event):
    return(self.branches[branch].lesserReportNum[period][event])

def getCurrentModeItems(period, event):
    return(self.mode_items[period][event].current_mode_items)

def getCurrentMode(period, event):
    return(self.mode_items[period][event].current_mode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.mode_items[period][event].report_value[report])

def getRepEvent(branch, votePeriod, event):
    return(self.branches[branch].repEvent[votePeriod][event])

def getEthicReport(branch, period, event, sender):
    return(self.branches[branch].ethics[period][sender].event[event])

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.branches[branch].report[period][sender].event[event])

def getBeforeRep(branch, period, sender):
    return(self.branches[branch].beforeRep[period][sender])

def getAfterRep(branch, period, sender):
    return(self.branches[branch].afterRep[period][sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.branches[branch].periodDormantRep[period][sender])

def getNumReportsActual(branch, votePeriod, sender):
    return(self.branches[branch].numReportsActual[sender][votePeriod])

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event):
    return(self.requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.numReqEvents[branch][period])
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
# 0, event means calculateReportTargetForEvent(branch, eventID, votePeriod, sender) in make reports should be called for that event
def getEventsToReportOn(branch, expDateIndex, sender):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            return([0, event]: arr)
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        reportingThreshold = self.calculateReportingThreshold(branch, events[i], expDateIndex, sender)
        x = array(1)
        x[0] = sender + events[i]
        # add 2**255 to ensure pos. and between 0 and 1
        shaHash = (sha3(x, items=1)+2**255)/ONE
        if((shaHash < reportingThreshold || shaHash<self.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !self.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
    return(events: arr)
    
def getEventCanReportOn(branch, expDateIndex, reporter, event):
    refund()
    reportingThreshold = self.calculateReportingThreshold(branch, event, expDateIndex, reporter)
    x = array(1)
    x[0] = reporter + event
    # add 2**255 to ensure pos. and between 0 and 1
    shaHash = (sha3(x, items=1)+2**255)/ONE
    if(shaHash < reportingThreshold || shaHash<self.getReportingThreshold(event) || self.getRequired(events)):
        return(1)
    else:
        return(0)

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
def calculateReportingThreshold(branch, eventID, votePeriod, sender):
    repConstant = self.getPeriodRepConstant(branch, votePeriod, sender)
    if(repConstant==0):
        repConstant = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getRepBalance(branch, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
        expectedEventsForReporter = repConstant * self.getNumEventsToReportOn(branch, votePeriod)
        total = expectedEventsForReporter
        eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)
        numRequiredEvents = self.getNumRequired(branch, votePeriod)
        if(repFraction >= POINTZEROONE):
            minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)
            if(total/ONE < minimum):
                total = minimum*ONE
                repConstant = total / self.getNumEventsToReportOn(branch, votePeriod)
        self.setPeriodRepConstant(branch, votePeriod, sender, repConstant)
    # 1 is 2**192 here, lesserreportnum, repconstant, and one are all base 2**64
    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE
    return(reportingThreshold)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    expDateIndex = self.getVotePeriod(branch)
    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*self.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def deleteEvent(branch, period, event):
    i = self.EventIDToIndex[period][event]
    self.EventsExpDates[branch][period].events[i] = 0
    self.EventIDToIndex[period][event] = 0
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(self.getVotePeriod(branch) > self.getExpiration(event)/self.getPeriodLength(branch) && !self.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/self.getPeriodLength(branch), event)
        self.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)
        
def addToWeightOfReport(period, event, report, amount):
    self.mode_items[period][event].report_value[report] += amount
    return(1)
    
def setCurrentMode(period, event, mode):
    self.mode_items[period][event].current_mode = mode
    return(1)
    
# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.mode_items[period][event].current_mode_items = self.mode_items[period][event].report_value[modeReport]
    return(1)

def addRepEvent(branch, votePeriod, event, amount):
    self.branches[branch].repEvent[votePeriod][event] += amount
    return(1)

def setEthicReport(branch, period, event, ethics, sender):
    self.branches[branch].ethics[period][sender].event[event] = ethics
    return(1)

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)
    
def addReportToEvent(branch, votePeriod, eventID, sender):
    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
    self.branches[branch].numReportsActual[sender][votePeriod] += 1
    return(1)

def addReportExpected(branch, votePeriod, eventID):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
    return(1)

def setReport(branch, period, event, report, sender):
    self.branches[branch].report[period][sender].event[event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.branches[branch].beforeRep[period][sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.branches[branch].afterRep[period][sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.branches[branch].periodDormantRep[period][sender] = rep
    return(rep)
    
def setLesserReportNum(branch, period, event, num):
    self.branches[branch].lesserReportNum[period][event] = num
    return(1)
    
#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
    refund()
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if < 3 reports so far
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one
    branch = self.getBranch(event)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    votePeriod = self.getVotePeriod(branch)
    if(votePeriod==self.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and self.branches[branch].numReportsExpectedEvent[votePeriod][event]<3):
        self.setThreshold(event, 2**192)
        return(1)
    else:
        return(0)
inset('refund.se')

# branch takes a branchID
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
data branch[](period[](denominator, penalized[](event[], num, notEnoughReportsPenalized), feesCollected[], feeFirst, periodBalance), penalizedUpTo[], baseReportersLastPeriod)

data refunds[]


def setRefund(refunder, amt):
    self.refunds[refunder] = amt
    return(1)
    
def doRefund(sender, refunder):
    send(sender, self.refunds[refunder])
    return(1)

def getBaseReportersLastPeriod(branch):
    return(self.branch[branch].baseReportersLastPeriod)

def setBaseReportersLastPeriod(branch, amount):
    self.branch[branch].baseReportersLastPeriod = amount
    return(1)

# get whether the first fee has been claimed by a reporter yet
def getFeeFirst(branch, period):
    return(self.branch[branch].period[period].feeFirst)

def setFeeFirst(branch, period, val):
    self.branch[branch].period[period].feeFirst = val
    return(1)

def getPeriodBalance(branch, period):
    return(self.branch[branch].period[period].periodBalance)

def setPeriodBalance(branch, period, balance):
    self.branch[branch].period[period].periodBalance = balance

def getPenalizedUpTo(branch, sender):
    return(self.branch[branch].penalizedUpTo[sender])

def setPenalizedUpTo(branch, sender, period):
    self.branch[branch].penalizedUpTo[sender] = period
    return(1)

def getDenominator(branch, period):
    return(self.branch[branch].period[period].denominator)

def increaseDenominator(branch, period, amount):
    self.branch[branch].period[period].denominator += amount
    return(1)

def getFeesCollected(branch, address, period):
    return(self.branch[branch].period[period].feesCollected[address])

def setFeesCollected(branch, address, period):
    self.branch[branch].period[period].feesCollected[address] = 1
    return(1)
    
def getPenalized(branch, period, sender, event):
    return(self.branch[branch].period[period].penalized[sender].event[event])

def setPenalized(branch, period, sender, event):
    self.branch[branch].period[period].penalized[sender].event[event] = 1
    return(1)

def getPenalizedNum(branch, period, sender):
    return(self.branch[branch].period[period].penalized[sender].num)    

def increasePenalizedNum(branch, period, sender, amount):
    self.branch[branch].period[period].penalized[sender].num += amount
    return(1)

def setNotEnoughPenalized(branch, address, period):
    self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized = 1
    return(1)
    
def getNotEnoughPenalized(branch, address, period):
    return(self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized)
    
def getRRDone(branch, reporter):
    refund()
    return(repRedistributionDone(branch, reporter))

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0
inset('refund.se')

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)
# period parameter for reporting
# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:
    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap
    #Say ev/ebit or valuation is 15, so:
    #45 * fee * volume per period = rep market cap

    #Want:
        #Rep market cap >> outstanding shares value at all times
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)

# first param is the branch, second param is the subcurrency contract
data cash[][]

data branchList[]

data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    refund()
    return(self.initiateOwner(1010101))

# event a branch was most recently forked over
def getEventForkedOver(branch):
    return(self.Branches[branch].eventForkedOver)

def setEventForkedOver(branch, event):
    self.Branches[branch].eventForkedOver = event
    return(1)

def getBaseReporters(branch):
    refund()
    return(self.Branches[branch].baseReporters)
    
def setBaseReporters(branch, num):
    refund()
    self.Branches[branch].baseReporters = num
    return(1)

def getOracleOnly(branch):
    refund()
    return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
    refund()
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    refund()
    return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
    refund()
    self.Branches[branch].balance[period] = balance
    return(balance)

def getInitialBalance(branch, period):
    refund()
    return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    refund()
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)
   
   
def getParent(branch):
    return(self.Branches[branch].parent)

# @return all markets in a branch
def getSomeMarketsInBranch(branch, initial, last):
    refund()
    numMarkets = last - initial
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[initial+i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
    refund()
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    refund()
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    refund()
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    refund()
    return(self.branchListCount)

def getBranchByNum(branchNumber):
    refund()
    return(self.branchList[branchNumber])

def getCreationDate(ID):
    refund()
    return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        self.Branches[ID].creationDate = block.timestamp
        self.Branches[ID].parentPeriod = parentPeriod
        self.Branches[ID].oracleOnly = oracleOnly
        self.Branches[ID].parent = parent
        self.initiateOwner(ID)
        return(1)
    else:
        return(0)

def getParentPeriod(branch):
    refund()
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)
    
def setForkPeriod(branch):
    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod
    return(1)
    
# gets the period in which a branch was most recently forked
def getForkPeriod(branch):
    return(self.Branches[branch].forkPeriod)
macro refund():
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
	# [1, event, event, 2, event, 3, event, event, event]
	# 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
	# sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, creationTime, lastExpDate, prices[])

# takes branch as param, composite hash of all markets in the system
data marketsHash[]

def getMarketsHash(branch):
	return(self.marketsHash[branch])

def addToMarketsHash(branch, newHash):
	x = array(2)
	x[0] = self.marketsHash[branch]
	x[1] = newHash
	self.marketsHash[branch] = sha3(x, items=2)
	return(1)

def addFees(market, amount):
	self.Markets[market].fees += amount
	return(1)
	
def setPrice(market, outcome, price):
	self.Markets[market].prices[outcome] = price
	return(1)

def refundClosing(amount, to):
	send(amount, to)
	return(1)

def getFees(market):
	return(self.Markets[market].fees)

def getMakerFees(market):
	return(self.Markets[market].makerFees)

def getgasSubsidy(market):
	return(self.Markets[market].gasSubsidy)

def getSharesValue(market):
	return(self.Markets[market].sharesValue)

def returnTags(market):
	tags = array(3)
	tags[0] = self.Markets[market].tag1
	tags[1] = self.Markets[market].tag2
	tags[2] = self.Markets[market].tag3
	return(tags: arr)

def getTotalSharesPurchased(market):
	refund()
	total = 0
	n = self.Markets[market].numOutcomes
	i = 1
	while i <= n:
	  total += self.Markets[market].sharesPurchased[i]
	  i += 1
	return(total)

def getMarketEvent(market, index):
	refund()
	return(self.Markets[market].events[index])

def getCreationTime(market):
	return(self.Markets[market].creationTime)

def getMarketEvents(market):
	refund()
	return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
	refund()
	return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
	refund()
	length=self.Markets[market].extraInfoLen
	return(load(self.Markets[market].extraInfo[0], chars=length): str)

def getVolume(market):
	refund()
	return(self.Markets[market].volume)

def getParticipantNumber(market, address):
	refund()
	participantNumber = self.Markets[market].addr2participant[address]
	return(participantNumber)

def getParticipantID(market, participantNumber):
	refund()
	return(self.Markets[market].participants[participantNumber].participantID)

def getParticipantSharesPurchased(market, participantNumber, outcome):
	refund()
	return(self.Markets[market].participants[participantNumber].shares[outcome])

def getNumEvents(market):
	refund()
	return(self.Markets[market].lenEvents)

def getCurrentParticipantNumber(market):
	refund()
	return(self.Markets[market].currentParticipant)

def getCumScale(market):
	refund()
	return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
	refund()
	return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
	refund()
	return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
	refund()
	return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
	refund()
	self.Markets[market].tradingPeriod = period
	return(1)

def getTradingFee(market):
	refund()
	return(self.Markets[market].tradingFee)

def getBranchID(market):
	refund()
	return(self.Markets[market].branch)

macro market($marketID):
	self.Markets[$marketID]

macro cumScale($marketID):
	market($marketID).cumulativeScale

macro numOutcomes($marketID):
	market($marketID).numOutcomes

macro sharesPurchased($marketID):
	market($marketID).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, lastExpDate):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# add event list to the market
	save(self.Markets[marketID].events[0], events, items=len(events))
	self.Markets[marketID].lenEvents = len(events)
	save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))
	self.Markets[marketID].extraInfoLen = len(extraInfo)
	self.Markets[marketID].tradingPeriod = tradingPeriod
	self.Markets[marketID].originalPeriod = tradingPeriod
	self.Markets[marketID].tradingFee = tradingFee
	self.Markets[marketID].branch = branch
	self.Markets[marketID].cumulativeScale = cumScale
	self.Markets[marketID].numOutcomes = numOutcomes
	self.Markets[marketID].tag1 = tag1
	self.Markets[marketID].tag2 = tag2
	self.Markets[marketID].gasSubsidy = gasSubsidy
	self.Markets[marketID].tag3 = tag3
	self.Markets[marketID].makerFees = makerFees
	self.Markets[marketID].fees = creationFee
	self.Markets[marketID].creationTime = block.timestamp
	self.Markets[marketID].lastExpDate = lastExpDate
	return(1)

def addParticipant(market, address):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	participantNumber = self.Markets[market].currentParticipant
	self.Markets[market].participants[participantNumber].participantID = address
	self.Markets[market].addr2participant[address] = participantNumber
	self.Markets[market].currentParticipant += 1
	return(participantNumber)

def modifyShares(marketID, outcome, amount):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	sharesPurchased(marketID)[outcome] += amount
	return(1)
	
def modifySharesValue(marketID, amount):
	self.Markets[marketID].sharesValue += amount
	return(1)

def modifyParticipantShares(marketID, participantNumber, outcome, amount, cancel):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	self.Markets[marketID].participants[participantNumber].shares[outcome] += amount
	if(amount<0):
		amount = amount*-1
	if(cancel):
		amount = -1*amount
	self.Markets[marketID].volume += amount
	return(1)

def setWinningOutcomes(market, outcomes: arr):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# largest # of winning outcomes is 8
	save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
	return(1)

def getWinningOutcomes(market):
	refund()
	# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# largest # of winning outcomes is 8
	return(load(self.Markets[market].winningOutcomes[0], items=8): arr)
	
def getOneWinningOutcome(market, num):
	refund()
	# whitelist
	return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
	refund()
	self.Markets[market].tradingFee = fee
	return(fee)

def setPushedForward(market, bool, sender):
	refund()
	self.Markets[market].pushingForward = bool
	self.Markets[market].bondsMan = sender
	return(1)

def getPushedForward(market):
	refund()
	return(self.Markets[market].pushingForward)

def getBondsMan(market):
	refund()
	return(self.Markets[market].bondsMan)

def getLastTrade(market):
	refund()
	return(self.Markets[market].last_trade)
	
def addTrade(market, trade_id, last_id):
	refund()
	self.Markets[market].trade_ids[last_id].next_id = trade_id
	self.Markets[market].trade_ids[trade_id].prev_id = last_id
	self.Markets[market].trade_ids[trade_id].id = trade_id
	self.Markets[market].last_trade = trade_id
	self.Markets[market].total_trades += 1
	return(1)
	
def remove_trade_from_market(market_id, trade_id):
	refund()
	prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id
	next_id = self.Markets[market_id].trade_ids[trade_id].next_id
	if prev_id and next_id:
		self.Markets[market_id].trade_ids[prev_id].next_id = next_id
		self.Markets[market_id].trade_ids[next_id].prev_id = prev_id
	elif prev_id:
		self.Markets[market_id].last_trade = prev_id
		self.Markets[market_id].trade_ids[prev_id].next_id = 0

	if next_id:
		self.Markets[market_id].trade_ids[trade_id].next_id = 0
	if prev_id:
		self.Markets[market_id].trade_ids[trade_id].prev_id = 0
	self.Markets[market_id].trade_ids[trade_id].id = 0
	self.Markets[market_id].total_trades -= 1
	return(1)

def get_trade_ids(market_id):
	refund()
	trades_count = self.Markets[market_id].total_trades
	trade_id = self.Markets[market_id].last_trade
	trade_ids = array(trades_count)

	i = 0
	while i < trades_count:
		trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id
		trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id
		i = i + 1

	if trade_ids:
		return(trade_ids:arr)
	return([FAILURE]:arr)
	
def get_total_trades(market_id):
	refund()
	return(self.Markets[market_id].total_trades)

def getOrderBook(marketID):
	refund()
	numTrades = self.Markets[marketID].total_trades
	trades = self.get_trade_ids(marketID, outitems=numTrades)
	orderBook = array(8*numTrades)
	i = 0
	while i < numTrades:
		tradeInfo = self.get_trade(trades[i], outitems=8)
		j = 0
		while j < 8:
			orderBook[8*i + j] = tradeInfo[j]
			j += 1
		i += 1
	return(orderBook:arr)

macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro FIELDS: 18

# todo move these getters to a new contract
def getMarketInfo(marketID):
	refund()
	index = FIELDS
	participantNumber = self.Markets[marketID].addr2participant[msg.sender]
	descriptionLength = self.getDescriptionLength(marketID)
	with info = array(FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):
		numEvents = self.Markets[marketID].lenEvents
		info[0] = marketID
		info[1] = self.Markets[marketID].currentParticipant
		info[2] = self.Markets[marketID].makerFees
		info[3] = participantNumber
		info[4] = self.Markets[marketID].numOutcomes
		info[5] = self.Markets[marketID].tradingPeriod
		info[6] = self.Markets[marketID].tradingFee
		info[7] = self.Markets[marketID].branch
		info[8] = self.Markets[marketID].lenEvents
		info[9] = self.Markets[marketID].cumulativeScale
		info[10] = self.Markets[marketID].creationTime
		info[11] = self.Markets[marketID].volume
		info[12] = self.getCreationFee(marketID)
		info[13] = self.getCreator(marketID)
		info[14] = self.Markets[marketID].tag1
		info[15] = self.Markets[marketID].tag2
		info[16] = self.Markets[marketID].tag3
		info[17] = self.Markets[marketID].creationTime
		# gather event(s) info:
		# [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
		with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):
			i = 0
			while i < numEvents:
				with eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS):
					info[index + i*EVENTS_FIELDS] = events[i]
					j = 1
					while j < EVENTS_FIELDS:
						info[index + i*EVENTS_FIELDS + j] = eventInfo[j]
						j += 1
				i += 1
		index += numEvents*EVENTS_FIELDS

		# gather outcomes info: [sharesPurchased, price], winningOutcomes
		# (price of outcome = last trade)
		numTrades = self.Markets[marketID].total_trades
		numOutcomes = self.Markets[marketID].numOutcomes
		trades = self.get_trade_ids(marketID, outitems=numTrades)
		k = 0
		while k < numOutcomes:
			info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]
			i = 0
			lastTrade = self.Markets[marketID].prices[k+1]
			info[index + k*OUTCOMES_FIELDS + 1] = lastTrade
			k += 1
		index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS
		k = 0
		while k < WINNING_OUTCOMES_FIELDS:
			info[index + k] = self.Markets[marketID].winningOutcomes[k]
			k += 1
		index += WINNING_OUTCOMES_FIELDS

		# append description character codes
		info[index] = descriptionLength
		index += 1
		with description = self.getDescription(marketID, outchars=descriptionLength):
			c = 0
			while c < descriptionLength:
				info[index + c] = getch(description, c)
				c += 1
		return(info: arr)

def getMarketsInfo(branch, offset, numMarketsToLoad):
	numMarkets = self.getNumMarketsBranch(branch)
	marketIDs = self.getSomeMarketsInBranch(branch, offset, offset+numMarketsToLoad, outitems=numMarketsToLoad)
	totalLen = numMarketsToLoad*10
	m = 0
	while m < numMarketsToLoad:
		totalLen += self.getDescriptionLength(marketIDs[m])
		m += 1
	data = array(totalLen)
	m = 0
	c = 0
	totalMarkets = min(numMarketsToLoad, numMarkets)
	while m < totalMarkets:
		descriptionLength = self.getDescriptionLength(marketIDs[m])
		data[c] = marketIDs[m]
		data[c + 1] = self.Markets[marketIDs[m]].tradingPeriod
		data[c + 2] = self.Markets[marketIDs[m]].tradingFee
		data[c + 3] = self.Markets[marketIDs[m]].creationTime
		data[c + 4] = self.Markets[marketIDs[m]].volume
		data[c + 5] = self.Markets[marketIDs[m]].tag1
		data[c + 6] = self.Markets[marketIDs[m]].tag2
		data[c + 7] = self.Markets[marketIDs[m]].tag3
		data[c + 8] = self.Markets[marketIDs[m]].lastExpDate
		data[c + 9] = descriptionLength
		c += 10
		description = self.getDescription(marketIDs[m], outchars=descriptionLength)
		d = 0
		while d < descriptionLength:
			data[c] = getch(description, d)
			d += 1
			c += 1
		m += 1
	return(data: arr)

def getSender():
	return(msg.sender)
inset('refund.se')

# Events' index is the eventID
# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1
# categorical markets have fixed point min and max
 # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)
# threshold is the min sha threshold for reporting on an event
# mode is the mode for a given event
# originalExp is original expiry date in the case an event was pushed back and the expiration date gets changed - both are in epoch time
# if a pushed back event is rejected then rejectedPeriod is the period it was pushed forward to and rejected in
# bond is the indeterminate bond
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength, pushedUp)

data past24Hours[]

def getEventPushedUp(event):
    return(self.Events[event].pushedUp)
    
def setEventPushedUp(event, val):
    self.Events[event].pushedUp = val
    return(1)

def getForkOutcome(event):
    return(self.Events[event].forkOutcome)

def setForkOutcome(event, value):
    self.Events[event].forkOutcome = value
    return(1)
    
def getForkEthicality(event):
    return(self.Events[event].forkEthicality)

def setForkEthicality(event, value):
    self.Events[event].forkEthicality = value
    return(1)

def getForked(event):
    return(self.Events[event].forked)

def setForked(event):
    self.Events[event].forked = 1
    return(1)
    
def setForkDone(event):
    self.Events[event].forkOver = 1
    return(1)
    
def getForkedDone(event):
    return(self.Events[event].forkOver)

def getEventResolution(event):
    resLen = self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=resLen): str)

def getEventInfo(event):
    refund()
    eventinfo = array(7)
    eventinfo[0] = self.Events[event].branch
    eventinfo[1] = self.Events[event].expirationDate 
    eventinfo[2] = self.Events[event].outcome
    eventinfo[3] = self.Events[event].minValue
    eventinfo[4] = self.Events[event].maxValue
    eventinfo[5] = self.Events[event].numOutcomes
    eventinfo[6] = self.Events[event].bond
    return(eventinfo: arr)
    
def getResolution(event):
    refund()
    length=self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=length): str)

def getPast24(period):
    refund()
    return(self.past24Hours[period])

def addPast24(period):
    refund()
    self.past24Hours[period] += 1
    return(1)

def getEventBranch(event):
    refund()
    return(self.Events[event].branch)

def getExpiration(event):
    refund()
    return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
    refund()
    return(self.Events[event].originalExp)

def setExpiration(event, date):
    refund()
    self.Events[event].expirationDate = date
    return(1)

def setBranch(event, branch):
    self.Events[event].branch = branch
    return(1)

def getOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].outcome)

def getEthics(event):
    refund()
    return(self.Events[event].ethical)

def setEthics(event, ethicality):
    refund()
    self.Events[event].ethical = ethicality
    return(ethicality)

def getEthical(event):
    refund()
    return(self.Events[event].ethical)

def getMinValue(event):
    refund()
    return(self.Events[event].minValue)

def getMaxValue(event):
    refund()
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    refund()
    return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
    refund()
    self.Events[event].uncaughtOutcome = outcome
    return(1)

def getUncaughtOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].originalExp = expirationDate
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))
        return(1)
    else:
        return(0)

def setBond(event, bond):
    refund()
    self.Events[event].bond = bond
    return(1)

def addMarket(event, marketID):
    refund()
    self.Events[event].markets[self.Events[event].numMarkets] = marketID
    self.Events[event].numMarkets += 1
    return(1)

def getBranch(event):
    return(self.Events[event].branch)

def getBond(event):
    refund()
    return(self.Events[event].bond)

def getMarkets(event):
    refund()
    i = 0
    markets = array(self.Events[event].numMarkets)
    while i < self.Events[event].numMarkets:
        markets[i] = self.Events[event].markets[i]
        i += 1
    return(markets: arr)
    
def getMarket(event, marketIndex):
    refund()
    return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
    refund()
    return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.Events[ID].outcome = outcome
    return(1)

def getReportingThreshold(event):
    refund()
    return(self.Events[event].threshold)
    
def setThreshold(event, threshold):
    # do whitelist
    self.Events[event].threshold = threshold
    return(1)

def getmode(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].mode)

def setmode(event, mode):
    refund()
    self.Events[event].mode = mode
    return(1)

def setRejected(event, period):
    refund()
    self.Events[event].rejected = 1
    self.Events[event].rejectedPeriod = period
    return(1)

def getRejected(event):
    refund()
    return(self.Events[event].rejected)

def getRejectedPeriod(event):
    refund()
    return(self.Events[event].rejectedPeriod)
inset('refund.se')

# reporter
data tradeCommits[](hash, block)
# tradeID
data trades[](id, type, market, amount, price, owner, block, outcome, initialTrade)

def makeTradeHash(max_value, max_amount, trade_ids: arr):
    refund()
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    return(tradeHash)

def commitTrade(hash):
    refund()
    self.tradeCommits[msg.sender].hash = hash
    self.tradeCommits[msg.sender].block = block.number
    return(1)
    
def setInitialTrade(id):
    refund()
    self.trades[id].initialTrade = 1
    return(1)
    
def getInitialTrade(id):
    refund()
    return(self.trades[id].initialTrade)
    
def zeroHash():
    refund()
    self.tradeCommits[msg.sender].hash = 0
    return(1)

def checkHash(tradeHash, sender):
    refund()
    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):
        return(-1)
    else:
        return(1)
        
def getID(tradeID):
    refund()
    return(self.trades[tradeID].id)
    
def saveTrade(trade_id, type, market, amount, price, sender, outcome):
    refund()
    self.trades[trade_id].id = trade_id
    self.trades[trade_id].type = type
    self.trades[trade_id].market = market
    self.trades[trade_id].amount = amount
    self.trades[trade_id].price = price
    self.trades[trade_id].owner = sender
    self.trades[trade_id].block = block.number
    self.trades[trade_id].outcome = outcome
    return(1)

def get_trade(id):
    refund()
    trade = array(8)
    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].outcome
    if trade:
        return(trade:arr)
    return([0]:arr)    

def get_amount(id):
    refund()
    return(self.trades[id].amount)
    
def get_price(id):
    refund()
    return(self.trades[id].price)

def update_trade(id, price):
    refund()
    self.trades[id].price = price
    self.trades[id].block = block.number

def remove_trade(id):
    refund()
    self.trades[id].id = 0
    self.trades[id].type = 0
    self.trades[id].market = 0
    self.trades[id].amount = 0
    self.trades[id].price = 0
    self.trades[id].owner = 0
    self.trades[id].block = 0
    self.trades[id].outcome = 0
    return(1)
    
def fill_trade(id, fill):
    refund()
    self.trades[trade_id].amount -= fill
    return(1)
inset('refund.se')

data cashcoinBalances[]

data owners[]


# @return: cash balance of address
def balance(address):
    refund()
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    refund()
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)
# @return: value sent, 0 if fails
# If you've never used cash in augur, to initiate your account call this with value as 0
def send(recver, value):
    refund()
    if(self.owners[msg.sender]==0):
        self.owners[msg.sender] = msg.sender
    #if(self.owners[recver]==0):
    #    return(0)
    sender = msg.sender
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    refund()
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):
        return(0)
    #if(self.owners[recver]==0):
    #    return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
    #    return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:
        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH
        send(to, value)
        return 1
    else:
        return 0
