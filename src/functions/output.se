def init():
    self.Branches[1010101].currentVotePeriod = (block.number / 100) - 1
    self.Branches[1010101].periodLength = 100
    self.Branches[1010101].minTradingFee = 2^57
    self.branchListCount = 1
    self.branchList[0] = 1010101
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 47*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.Reporting[1010101].totalRep += 47*2^64
    # test initial funds
    self.cashcoinBalances[tx.origin] = 100000*2^64
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)

event creationBlock(market:indexed)


# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
    # n is num outcomes
# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
# @return marketID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money or market already exists
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired

# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr, forkSelection):
    periodLength = self.getPeriodLength(branch)
    # liquidity is just buying complete sets then selling at diff. prices
    # minimum fee 2% with initial liquidity >= $50 and < $100
    if(initialLiquidity<100*2**64):
        if(tradingFee<368934881474191032):
            return(-5)
    # minimum fee 1% with initial liquidity >= $100 and < $1000
    if(initialLiquidity<1000*2**64):
        if(tradingFee<184467440737095516):
            return(-5)
    # minimum fee 0.5% with initial liquidity < $2000
    if(initialLiquidity<2000*2**64):
        if(tradingFee<92233720368547758):
            return(-5)
    # minimum fee 0.4% with initial liquidity < $3000
    if(initialLiquidity<3000*2**64):
        if(tradingFee<73786976294838206):
            return(-5)
    # minimum fee 0.3% with initial liquidity < $4000
    if(initialLiquidity<4000*2**64):
        if(tradingFee<55340232221128654):
            return(-5)
    # minimum fee 0.2% with initial liquidity < $5000
    if(initialLiquidity<5000*2**64):
        if(tradingFee<36893488147419103):
            return(-5)
    # minimum fee 0.1% with initial liquidity >= $5000
    if(initialLiquidity>=5000*2**64):
        if(tradingFee<18446744073709551):
            return(-5)

    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 or (initialLiquidity<50*2**64 and !self.getOracleOnly(branch)) || alpha <= 2^57 || tradingFee < self.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
    # minimum initial liquidity for "oracle only" branches is less (half is a fee, half returned)
    if(initialLiquidity<2*2**64):
        return(-1)
    event = events[0]

    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)

    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(-2)

    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(i!=0):
            if(event==events[i-1]):
                return(-6)
        expirationDate = self.getExpiration(event)
        futurePeriod = expirationDate / periodLength
        if(expirationDate < block.number):
            return(-7)    
        self.addEvent(branch, futurePeriod, event)
        if(expirationDate > tradingPeriod):
            tradingPeriod = expirationDate
        eventsConcat += event
        if (self.getEventBranch(event) != branch || !self.getCreator(event)):
            return(-1)
        #scalars
        maxValue = self.getMaxValue(event)
        minValue = self.getMinValue(event)
        if((maxValue!=2 || minValue !=1) && self.getNumOutcomes(event)==2):
            # is a valid scalar
            cumulativeScale += maxValue - self.getMinValue(event)
        eventNumOutcomes = self.getNumOutcomes(event)
        if(i==0):
            numOutcomes += eventNumOutcomes
        else:
            numOutcomes *= eventNumOutcomes
        i += 1
    if(numOutcomes > 80):
        return(-3)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / periodLength)

    # formation of marketID (hash)
    marketinfo = string(11*32 + len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo + 11*32, description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))
    log(type=creationBlock, marketID)
    self.initiateOwner(marketID)
    # pay numOutcomes fee
    # if it's already been created return 0
    if(!self.send(branch, numOutcomes*2^63) || self.getCreator(marketID) || self.getMarketNumOutcomes(marketID)):
        return(-4)

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    z = initialLiquidity * 2**64 / (cumulativeScale*2**64 + alpha*numOutcomes*cumulativeScale*self.fx_log(numOutcomes*2**64)/2**64)
    self.initialLiquiditySetup(marketID, alpha, cumulativeScale, numOutcomes)
    while y <= numOutcomes:
        self.modifyShares(marketID, y, z)
        self.setInitialLiquidityAmount(marketID, y, z)
        y += 1
    if(self.setInfo(marketID, description, tx.origin, initialLiquidity) && self.addMarketToBranch(branch, marketID) && self.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, forkSelection) && self.send(marketID, initialLiquidity)):
        i = 0
        while i < len(events):
            self.addMarket(events[i], marketID)
            i += 1
        return(marketID)

    # revert shares bought and other variables
    else:
        v = 1
        while v <= numOutcomes:
            self.modifyShares(marketID, v, -z)
            v += 1
        self.initialLiquiditySetup(marketID, 0, 0, 0)
        return(-4)

# todo: needs to comply w/ new trading fee rules
# perhaps don't allow raising of trading fee
def updateTradingFee(branch, market, tradingFee):
    if(tradingFee < self.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
    return(self.setTradingFee(market, tradingFee))

#Add def moveMarket(market, newBranch, marketAuthor) in case of a fork or some other issue
#In event of fork:
#1) Market Maker chooses the fork
#2) Market is closed at current prices
#3) The market is unable to go to adjudication upon close date and closes at final prices.
#4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
#5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
#6) market is moved to the fork with a higher market cap as defined by centralized exchange y
def moveMarketAndAssocEvents(market, fork):
    #if(self.stuffForked()):
    if(1):
        forkChoice = self.getForkSelection(market)

        # set market branch
        # move event
        # move market as well to whichever fork

        #1) Market Maker chooses the fork
        if(forkChoice==1):
            if(self.getCreator(market)==msg.sender):
                return(0)
        #2) Market is closed at current prices
        elif(forkChoice==2):
            return(0)
        #3) The market is unable to go to adjudication upon close date and closes at final prices.
        elif(forkChoice==3):
            return(0)
        #4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
        # should this be weighted by capital in the market? hmm
        elif(forkChoice==4):
            return(0)
        #5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
        elif(forkChoice==5):
            return(0)
        #6) market is moved to the fork with a higher market cap as defined by centralized exchange y
        elif(forkChoice==6):
            return(0)
        #7) autonocoin style bet which fork it should go on and that's the one (like futarchy, except you don't get a refund)
        elif(forkChoice==7):
            return(0)
    else:
        return(0)


# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    # todo: if has been pushed forward in the past (see close market) don't allow it again
    numEvents = self.getNumEvents(market)
    if(marketClosed):
        return(0)
    if(self.send(market, numEvents*self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))==0):
        return(0)
    i = 0
    # for each event in market
    while i < numEvents:
        if(eventNotResolved && eventNotInRound2Adj):
            event = self.getMarketEvent(market, i)
            # push into next vote period
            period = self.getVotePeriod(branch)
            self.addEvent(branch, period+1, event)
            # set event expiration date to be after the current reporting period ends
            self.setExpiration(event, block.number)
            self.setTradingPeriod(market, period+1)
            self.setPushedForward(market, 1)
            #self.setReportable(period+1, event)
        i += 1
    return(1)


# - If at anytime after expiry an event's market's odds are <.99, someone can prove it and push it into next reporting period
# (and don't allow rbrr for original exp period of this market, actually, don't allow this regardless)
# - Should probably still have an option to pay to resolve in case something somehow goes wrong here or people really want a market resolved.
#def resolve99Market(branch, market, resolveRegardless):
#    if(eventIsScalar || marketClosed):
#      return(-1)
#    if(marketNotExpired):
#      return(-2)
#    numOutcomes = self.getMarketNumOutcomes(market)
#    n = 0
#    ninetynine = 0
#    while n < numOutcomes:
#      if(self.price(markets, n) > 18262276632972456099):
#        ninetynine = 1
#        n = numOutcomes
#        n += 1

#    if(ninetynine==0 || resolveRegardless):
#      if(resolveRegardless):
#        if(self.send(branch, 100*2**64)==0):
#            return(0)

#    numEvents = self.getNumEvents(market)
#    i = 0
#    # for each event in market
#    while i < numEvents:
#      if(eventNotResolved && eventNotInRound2Adj):
#        event = self.getMarketEvent(market, i)
        # push into next vote period
#        period = self.getVotePeriod(branch)
#        self.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
#        self.setExpiration(event, block.number)
#        self.setTradingPeriod(market, period+1)
#        self.setReportable(period+1, event)
#      i += 1
#    return(1)

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63
macro CATCH_TOLERANCE: 2^64 / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < 2^63):
        0
    elif($x > 2^63):
        2^64
    else:
        0

macro scalar($event):
    ((self.getMaxValue($event)!=2 || self.getMinValue($event)!=1) && self.getNumOutcomes($event)==2)

def catch(x):
    return(catch(x))

## helper functions:
def resolveBinary(event, market, branch, votingPeriodEvent, period):
    fxpOutcome = catch(self.getUncaughtOutcome(event))
    pushedBack = self.getPushedBack(event)
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    ethical = ethic_catch(self.getEthical(event))
    self.setOutcome(event, fxpOutcome)
    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration date
    if(fxpOutcome == 3*2**63 && self.getPushedForward(market)):
        #set event expiration to be the old date prior to this bond process
        self.setExpiration(event, self.getOriginalExpiration(event))
        self.setTradingPeriod(market, self.getOriginalTradingPeriod(market))
        self.addCash(branch, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
        self.subtractCash(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
        self.setPushedForward(market, 0)
        self.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)
        self.setNumReportsEvent(branch, votingPeriodEvent, event, 0)
        #set outcome to 0
        self.setOutcome(event, 0)
        self.setMedian(event, 0)
        self.setEthics(event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome(event, 0)
        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
        self.setRejected(event, self.getExpiration(event)/periodLength, fxpOutcome)
        return(-6)
    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome
    # why residual < periodLength/2?
    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):
        #push back event
        self.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)
        self.setNumReportsEvent(branch, votingPeriodEvent, event, 0)
        self.setEthics(event, 0)
        self.addEvent(branch, period+1, event)
        #set outcome to 0
        self.setOutcome(event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome(event, 0)
        #set pushedback to true
        self.setPushedBack(event)
        #set event expiration date to be after the current reporting period ends
        self.setExpiration(event, block.number)
        self.setTradingPeriod(market, period+1)
        return(-4)
    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):
        # give event bond money to reporters
        self.subtractCash(event, 42*2**64)
        self.addCash(branch, 42*2**64)
        # not ethical is same as .5 outcome
        fxpOutcome = 3*2**63
        self.setOutcome(event, fxpOutcome)
    else:
        # return bond
        self.subtractCash(event, 42*2**64)
        self.addCash(self.getCreator(event), 42*2**64)
        if(self.getPushedForward(market)):
            self.addCash(self.getBondsMan(market), self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
            self.subtractCash(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
            # delete old event from future events exp
            self.removeEvent(branch, self.getOriginalExpiration(event)/periodLength)
    return(1)

def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent, period):
    #median = self.calculateMedian(event)
    self.setMedian(event, median)
    fxpOutcome = median * (scaled_max - scaled_min) + scaled_min
    self.setOutcome(event, fxpOutcome)
    pushedBack = self.getPushedBack(event)
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    ethical = ethic_catch(self.getEthical(event))

    # In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration date
    if(fxpOutcome == 3*2**63 && self.getPushedForward(market)):
        #set event expiration to be the old date prior to this bond process
        self.setExpiration(event, self.getOriginalExpiration(event))
        self.setTradingPeriod(market, self.getOriginalTradingPeriod(market))
        self.addCash(branch, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
        self.subtractCash(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
        self.setPushedForward(market, 0)
        self.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)
        self.setNumReportsEvent(branch, votingPeriodEvent, event, 0)
        #set outcome to 0
        self.setOutcome(event, 0)
        self.setMedian(event, 0)
        self.setEthics(event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome(event, 0)
        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
        self.setRejected(event, self.getExpiration(event)/periodLength, fxpOutcome)
        return(-6)

    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome
    if(fxpOutcome==3*2**63 && !pushedBack && residual < periodLength/2):
        #push back event
        self.setNumReportsExpectedEvent(branch, votingPeriodEvent, event, 0)
        self.setNumReportsEvent(branch, votingPeriodEvent, event, 0)
        self.addEvent(branch, period+1, event)
        #set outcome to 0
        self.setOutcome(event, 0)
        #set pushedback to true
        self.setPushedBack(event)
        # set median to 0
        self.setMedian(event, 0)
        self.setEthics(event, 0)
        self.setExpiration(event, block.number)
        self.setTradingPeriod(market, period+1)
        return(-4)
    if((fxpOutcome==3*2**63 && pushedBack) || !ethical):
        # give event bond money to reporters
        self.subtractCash(event, 42*2**64)
        self.addCash(branch, 42*2**64)
        # not ethical is same as .5 outcome
        fxpOutcome = 3*2**63
        self.setOutcome(event, fxpOutcome)
        self.setMedian(event, fxpOutcome)
    else:
        # return bond
        self.subtractCash(event, 42*2**64)
        self.addCash(self.getCreator(event), 42*2**64)
        if(self.getPushedForward(market)):
            self.addCash(self.getBondsMan(market), self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
            self.subtractCash(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*2^64))
            # delete old event from future events exp
            self.removeEvent(branch, self.getOriginalExpiration(event)/periodLength)
    return(1)

def determineWinningOutcomes(events: arr, numberEvents, branch, market):
    n = 0
    winningOutcomes = array(8)
    while n < numberEvents:
        fxpOutcome = self.getOutcome(events[n])
        outcome = fxpOutcome/2^64
        if(n==0):
            #scalar or .5
            if(scalar(events[n]) || fxpOutcome==3*2^63):
                winningOutcomes[0] = 1
                winningOutcomes[1] = 2
            # anything besides scalar or .5
            else:
                winningOutcomes[0] += outcome
        elif(n==1):
            if(scalar(events[n]) || fxpOutcome==3*2^63):
                # scalar, scalar
                if(winningOutcomes[1]):
                    winningOutcomes[2] = 3
                    winningOutcomes[3] = 4
                # nonscalar, scalar
                else:
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] = winningOutcomes[0] + self.getNumOutcomes(events[n-1])
            # scalar, nonscalar
            elif(winningOutcomes[1]):
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
                winningOutcomes[1] += self.getNumOutcomes(events[n-1])*(outcome-1)
            # nonscalar, nonscalar
            else:
                winningOutcomes[0] += self.getNumOutcomes(events[n-1])*(outcome-1)
        elif(n==2):
            if(scalar(events[n]) || fxpOutcome==3*2^63):
                #scalar, scalar, scalar
                if(winningOutcomes[3]):
                    winningOutcomes[4] = 5
                    winningOutcomes[5] = 6
                    winningOutcomes[6] = 7
                    winningOutcomes[7] = 8
                #scalar, nonscalar, scalar
                #nonscalar, scalar, scalar
                elif(winningOutcomes[1]):
                    #winningOutcomes[0] = winningOutcomes[0]
                    #winningOutcomes[1] = winningOutcomes[1]
                    winningOutcomes[2] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                    winningOutcomes[3] += winningOutcomes[1] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
                #nonscalar, nonscalar, scalar
                elif(winningOutcomes[1]==0):
                    #winningOutcomes[0] = winningOutcomes[0]
                    winningOutcomes[1] += winningOutcomes[0] + self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1])
            else:
                #scalar, scalar, nonscalar
                if(winningOutcomes[3]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[2] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[3] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #scalar, nonscalar, nonscalar
                #nonscalar, scalar, nonscalar
                elif(winningOutcomes[1]):
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                    winningOutcomes[1] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
                #nonscalar, nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.getNumOutcomes(events[n-2]) * self.getNumOutcomes(events[n-1]) * (outcome-1)
        n+=1
    return(winningOutcomes: arr)

# @return amount of shares transferred
# Error messages otherwise
    # -1: invalid outcome or you haven't traded in this market (or market doesn't exist)
    # -2: user actually doesn't have the shares
    # -3: not enough money to transfer the shares
def transferShares(branch, market, outcome, amount, to):
    participantNumber = self.getParticipantNumber(market, tx.origin)
    receiverNumber = self.getParticipantNumber(market, to)
    # make sure outcome exists
    if (outcome==0 || self.getParticipantID(market, participantNumber) != tx.origin):
        return(-1)
    if(to != self.getParticipantID(market, receiverNumber)):
        receiverNumber = self.addParticipant(market, to)
    # remove shares from the user's account
    # if user actually doesn't have the shares, return -2
    if(self.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-2)
    self.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)
    self.modifyParticipantShares(branch, market, receiverNumber, outcome, amount)

    # half of fees to market creator
    # other half go to branch
    oldCost = self.lsLmsr(market)
    self.modifyShares(market, outcome, 2^32)
    newCost = self.lsLmsr(market)
    price = 2^32*(newCost - oldCost)
    fee = self.getTradingFee(market)*price/2^64
    self.modifyShares(market, outcome, -2^32)
    if((self.balance(tx.origin) >= fee) && self.send(self.getCreator(market), fee/2) && self.send(branch, fee/2)):
        return(amount)
    else:
        return(-3)
# period length is given in blocks
# @return branchID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: no money for creation fee or branch already exists
def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):
    if(periodLength<=0 || !self.getPeriodLength(parent) || description==0):
        return(-1)

    parentPeriod = self.getVotePeriod(parent)

    branchInfo = string(8*32+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*2^64                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.number                                #current block number
    branchInfo[5] = parent                                      #branchID of parent branch
    branchInfo[6] = tradingFee
    branchInfo[7] = oracleOnly
    mcopy(branchInfo+ 8*32, description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha256(branchInfo, chars=len(branchInfo))
    currentVotePeriod = (block.number / periodLength) - 1
    if(self.getCreator(branchID)==0):
        self.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod)
    else:
        return(-2)
    if(self.getCreator(parent) && self.send(parent, 47*2^64) && self.setInfo(branchID, description, tx.origin, 47*2^64) && self.setInitialReporters(parent, branchID)):
        return(branchID)
    else:
        return(-2)

# eight winning outcomes
def eightOutcomes(market, winningOutcome: arr, events: arr):
    outcomeOne = self.getOutcome(events[0])
    minValueOne = self.getMinValue(events[0])
    maxValueOne = self.getMaxValue(events[0])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[1])
    minValueTwo = self.getMinValue(events[1])
    maxValueTwo = self.getMaxValue(events[1])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo
    outcomeThree = self.getOutcome(events[2])
    minValueThree = self.getMinValue(events[2])
    maxValueThree = self.getMaxValue(events[0])
    if(outcomeThree>maxValueThree):
        outcomeThree = maxValueThree
    elif(outcomeThree<minValueThree):
        outcomeThree = minValueThree

    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent
    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)
    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent
            
    # price is in fixed point
    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
    pricePerShare = array(7)
    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)
    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)

    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, tx.origin)
    if(participantNumber == -1):
        return(-1)
    participant = self.getParticipantID(market, participantNumber)
    
    # for each winning outcome do...
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(self.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)
        self.subtractCash(market, sharesOwned*pricePerShare[n]*self.getCumScale(market)/2^64)
        self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare[n]/2^64)
        n+=1
    return(1)
    
def valueCalcEight(market, winningOutcome: arr, events: arr):
    outcomeOne = self.getOutcome(events[0])
    minValueOne = self.getMinValue(events[0])
    maxValueOne = self.getMaxValue(events[0])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[1])
    minValueTwo = self.getMinValue(events[1])
    maxValueTwo = self.getMaxValue(events[1])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo
    outcomeThree = self.getOutcome(events[2])
    minValueThree = self.getMinValue(events[2])
    maxValueThree = self.getMaxValue(events[0])
    if(outcomeThree>maxValueThree):
        outcomeThree = maxValueThree
    elif(outcomeThree<minValueThree):
        outcomeThree = minValueThree

    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent
    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)
    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent
            
    # price is in fixed point
    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
    pricePerShare = array(7)
    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)
    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
    
    cumScale = self.getCumScale(market)
    sharesTotal1 = self.getSharesPurchased(market, winningOutcome[0]) - self.initialLiquidityAmount(market, winningOutcome[0])
    sharesTotal2 = self.getSharesPurchased(market, winningOutcome[1]) - self.initialLiquidityAmount(market, winningOutcome[1])
    sharesTotal3 = self.getSharesPurchased(market, winningOutcome[2]) - self.initialLiquidityAmount(market, winningOutcome[2])
    sharesTotal4 = self.getSharesPurchased(market, winningOutcome[3]) - self.initialLiquidityAmount(market, winningOutcome[3])
    sharesTotal5 = self.getSharesPurchased(market, winningOutcome[4]) - self.initialLiquidityAmount(market, winningOutcome[4])
    sharesTotal6 = self.getSharesPurchased(market, winningOutcome[5]) - self.initialLiquidityAmount(market, winningOutcome[5])
    sharesTotal7 = self.getSharesPurchased(market, winningOutcome[6]) - self.initialLiquidityAmount(market, winningOutcome[6])
    sharesTotal8 = self.getSharesPurchased(market, winningOutcome[7]) - self.initialLiquidityAmount(market, winningOutcome[7])

    value = sharesTotal1*cumScale*pricePerShare[0]/2**64 + sharesTotal2*cumScale*pricePerShare[1]/2**64 + sharesTotal3*cumScale*pricePerShare[2]/2**64 + sharesTotal4*cumScale*pricePerShare[3]/2**64 + sharesTotal5*cumScale*pricePerShare[4]/2**64 + sharesTotal6*cumScale*pricePerShare[5]/2**64 + sharesTotal7*cumScale*pricePerShare[6]/2**64 + sharesTotal8*cumScale*pricePerShare[7]/2**64
    return(value)
# Error -1: Hey, you're not broke!
def cashFaucet():
    if self.balance(tx.origin) > 5*2**64:
        return(-1)
    self.setCash(tx.origin, 10000*2**64)
    return(1)

def reputationFaucet(branch):
    if self.repIDToIndex(branch, tx.origin) != 0 or self.getReporterID(branch, 0) == tx.origin:
        index = self.repIDToIndex(branch, tx.origin)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, tx.origin)
    self.setRep(branch, index, 47*2**64)
    return(1)

# four winning outcomes
def fourOutcomes(market, winningOutcome: arr, events: arr):
    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
    scalarOne = -1
    scalarTwo = -1
    if(((self.getMaxValue(events[0])!=2 || self.getMinValue(events[0])!=1) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*2^63):
        scalarOne = 0
    if(((self.getMaxValue(events[1])!=2 || self.getMinValue(events[1])!=1) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*2^63):
        if(scalarOne == -1):
            scalarOne = 1
        else:
            scalarTwo = 1
    elif(((self.getMaxValue(events[2])!=2 || self.getMinValue(events[2])!=1) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*2^63):
        scalarTwo = 2
    outcomeOne = self.getOutcome(events[scalarOne])
    minValueOne = self.getMinValue(events[scalarOne])
    maxValueOne = self.getMaxValue(events[scalarOne])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[scalarTwo])
    minValueTwo = self.getMinValue(events[scalarTwo])
    maxValueTwo = self.getMaxValue(events[scalarTwo])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo

    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent

    # price is in fixed point
    # share four goes with the high-high side
    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64
    # share three goes with the low-high side
    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64
    # share two goes with the high-low side
    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64
    # share one goes with the low-low
    # both fixed point so div by 2^64 to keep in fixed point
    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, tx.origin)
    if(participantNumber == -1):
        return(-1)
    participant = self.getParticipantID(market, participantNumber)
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(self.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)
        # low-low
        if(n==0):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare1/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare1/2^64)
        # high-low
        elif(n==1):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare2/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare2/2^64)
        # low-high
        elif(n==2):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare3/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare3/2^64)
        # high-high
        elif(n==3):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare4/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare4/2^64)
        n+=1
    return(1)

def valueCalcFour(market, winningOutcome: arr, events: arr):
    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
    scalarOne = -1
    scalarTwo = -1
    if(((self.getMaxValue(events[0])!=2 || self.getMinValue(events[0])!=1) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*2^63):
        scalarOne = 0
    if(((self.getMaxValue(events[1])!=2 || self.getMinValue(events[1])!=1) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*2^63):
        if(scalarOne == -1):
            scalarOne = 1
        else:
            scalarTwo = 1
    elif(((self.getMaxValue(events[2])!=2 || self.getMinValue(events[2])!=1) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*2^63):
        scalarTwo = 2
    outcomeOne = self.getOutcome(events[scalarOne])
    minValueOne = self.getMinValue(events[scalarOne])
    maxValueOne = self.getMaxValue(events[scalarOne])
    if(outcomeOne>maxValueOne):
        outcomeOne = maxValueOne
    elif(outcomeOne<minValueOne):
        outcomeOne = minValueOne
    outcomeTwo = self.getOutcome(events[scalarTwo])
    minValueTwo = self.getMinValue(events[scalarTwo])
    maxValueTwo = self.getMaxValue(events[scalarTwo])
    if(outcomeTwo>maxValueTwo):
        outcomeTwo = maxValueTwo
    elif(outcomeTwo<minValueTwo):
        outcomeTwo = minValueTwo

    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent

    # price is in fixed point
    # share four goes with the high-high side
    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64
    # share three goes with the low-high side
    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64
    # share two goes with the high-low side
    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64
    # share one goes with the low-low
    # both fixed point so div by 2^64 to keep in fixed point
    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64

    cumScale = self.getCumScale(market)
    sharesTotal1 = self.getSharesPurchased(market, winningOutcome[0]) - self.initialLiquidityAmount(market, winningOutcome[0])
    sharesTotal2 = self.getSharesPurchased(market, winningOutcome[1]) - self.initialLiquidityAmount(market, winningOutcome[1])
    sharesTotal3 = self.getSharesPurchased(market, winningOutcome[2]) - self.initialLiquidityAmount(market, winningOutcome[2])
    sharesTotal4 = self.getSharesPurchased(market, winningOutcome[3]) - self.initialLiquidityAmount(market, winningOutcome[3])
    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64 + sharesTotal3*cumScale*pricePerShare3/2**64 + sharesTotal4*cumScale*pricePerShare4/2**64
    return(value)
event updatePrice(user:indexed, market:indexed, outcome:indexed, price, cost)

# market, reporter
data trades[][](hash, block)

def commitTrade(market, hash):
    self.trades[market][tx.origin].hash = hash
    self.trades[market][tx.origin].block = block.number
    return(1)
    
def makeMarketHash(market, outcome, amount, limit):
    buyInfo = array(4)
    buyInfo[0] = market
    buyInfo[1] = outcome
    buyInfo[2] = amount
    buyInfo[3] = limit
    buyHash = sha256(buyInfo, items=4)
    return(buyHash)

# amount of shares should be fixed point
# @return return price + fee to buy shares
# Error messages otherwise
    # -1: invalid outcome or trading closed
    # -2: entered a -amt of shares
    # -3: not enough money / limit order too low
    # -4: invalid outcome
    # -5: bad commitment or no commitment
    # -6: oracle only branch, no trading
def buyShares(branch, market, outcome, amount, limit):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)

    if(self.getOracleOnly(branch)):
        return(-6)

    buyInfo = array(4)
    buyInfo[0] = market
    buyInfo[1] = outcome
    buyInfo[2] = amount
    buyInfo[3] = limit
    buyHash = sha256(buyInfo, items=4)
    if(self.trades[market][tx.origin].hash != buyHash || block.number == self.trades[market][tx.origin].block):
        return(-5)
    self.trades[market][tx.origin].hash = 0
    # make it so trader has locked in fee from buy, so if they sell and they bought when fee was low, they can sell with that low fee as opposed to a high one
    numEvents = self.getNumEvents(market)
    events = self.getMarketEvents(market, outitems=numEvents)
    if(outcome > self.getMarketNumOutcomes(market) or outcome < 1):
        return(-4)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(self.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(self.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    ### TODO: check for .99 market here
    if (outcome==0 || (self.getVotePeriod(branch)>self.getTradingPeriod(market) && !pushedBack) || self.getBranchID(market) != branch):
        return(-1)
    # lmsr cost calcs
    oldCost = self.lsLmsr(market)
    self.modifyShares(market, outcome, amount)
    newCost = self.lsLmsr(market)
    if newCost <= oldCost:
        self.modifyShares(market, outcome, -amount)
        return(0)
    price = (newCost - oldCost)

    if(self.balance(tx.origin) < price*(self.getTradingFee(market) + 2^64)/2^64 or (limit!=0 and (price*2^64/amount)>limit)):
        self.modifyShares(market, outcome, -amount)
        return(-3)

    participantNumber = self.getParticipantNumber(market, tx.origin)

    # if participant doesn't exist in market, add them
    if(tx.origin != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, tx.origin)

    self.modifyParticipantShares(branch, market, participantNumber, outcome, amount)
    # send shares of the event to user address
    # if user doesn't have enough money, revert
    # send money from user acc. to market address/account
    # cost for shares
    self.send(market, price)
    # half of fees to market creator
    fee = self.getTradingFee(market)*price/2^64
    self.send(self.getCreator(market), fee/2)
    # other half go to branch
    self.send(branch, fee/2)
    # log new price & avg price paid/share
    log(type=updatePrice, tx.origin, market, outcome, self.price(market, outcome), -(price+fee)*2^64/amount)
    return(1)

# amount is amount of shares to sell
# instead of inputting particip. num could just loop through array if dont have it
# @return error msg if fail, returns amount you get paid if success
# Error messages otherwise
    # -1: invalid outcome, trading closed, or you haven't traded in this market
    # -2: entered a -amt of shares
    # -3: you own no shares / limit price too high
    
    # -5: bad commitment or no commitment
    # -6: oracle only branch, no trading
def sellShares(branch, market, outcome, amount, limit):
    if(self.getOracleOnly(branch)):
        return(-6)
    sellInfo = array(4)
    sellInfo[0] = market
    sellInfo[1] = outcome
    sellInfo[2] = amount
    sellInfo[3] = limit
    sellHash = sha256(sellInfo, items=4)
    if(self.trades[market][tx.origin].hash != sellHash || block.number == self.trades[market][tx.origin].block):
        return(-5)
        
    self.trades[market][tx.origin].hash = 0

    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    participantNumber = self.getParticipantNumber(market, tx.origin)
    numEvents = self.getNumEvents(market)
    events = self.getMarketEvents(market, outitems=numEvents)
    if(outcome > self.getMarketNumOutcomes(market) or outcome < 1):
        return(-4)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(self.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(self.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    if (self.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (self.getVotePeriod(branch)>self.getTradingPeriod(market) && !pushedBack) || self.getBranchID(market) != branch):
        return(-1)
    # lmsr cost calcs
    oldCost = self.lsLmsr(market)
    self.modifyShares(market, outcome, -amount)
    newCost = self.lsLmsr(market)
    if oldCost <= newCost:
        self.modifyShares(market, outcome, amount)
        return(-2)
    # these prices are in fixed point
    price = oldCost - newCost
    # remove shares from the user's account
    # if user actually doesn't have the shares, revert
    if (self.getParticipantSharesPurchased(market, participantNumber, outcome) < amount or (limit!=0 and (price*2^64/amount)<limit)):
        self.modifyShares(market, outcome, amount)
        return(-3)
    else:
        # send bitcoin from the market to the user acc.
        self.subtractCash(market, price)
        fee = self.getTradingFee(market)*price/2^64
        # half of fees go to market creator
        self.addCash(self.getCreator(market), fee/2)
        # half go to branch
        self.addCash(branch, fee/2)
        price -= fee
        self.addCash(tx.origin, price)
        self.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)
        # log new price and avg. price sold / share
        log(type=updatePrice, tx.origin, market, outcome, self.price(market, outcome), (price)*2^64/amount)
        return(1)
# mutex result non scalar not .5
# one winning outcome
def oneOutcome(market, winningOutcome):
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, tx.origin)
    if(participantNumber == -1):
        return(-1)
    sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome)
    participant = self.getParticipantID(market, participantNumber)
    self.modifyParticipantShares(self.getBranchID(market), market, participantNumber, winningOutcome, -sharesOwned)
    self.subtractCash(market, sharesOwned*self.getCumScale(market))
    self.addCash(participant, sharesOwned*self.getCumScale(market))
    return(1)

def valueCalcOne(market, winningOutcome):
    sharesTotal = self.getSharesPurchased(market, winningOutcome) - self.initialLiquidityAmount(market, winningOutcome)
    return(sharesTotal*self.getCumScale(market))
# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63

macro CATCH_TOLERANCE: 2^64 / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < 2^63):
        0
    elif($x > 2^63):
        2^64
    else:
        0

# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome
    # -4: Outcome .5 once, pushback and retry
    # -6: bonded pushed forward market not ready to be resolved
    # -7: event not reportable >.99
#Use consistent 1 and 2 fixed point numbers as min and max for close market, make market, make event, buy/sell shares, and consensus on binary events - really, just use base 64 fixed point everywhere
def closeMarket(branch, market):
    if(self.balance(market)<=0):
        return(-1)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 0
    resolved = 1
    while i < numberEvents:
        if(self.getOutcome(events[i])==0 && self.getMedian(events[i])==0):
            resolved = 0
            i = numberEvents
        i += 1
    i = 0
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(numReports == numExpected && numReports!=0 && numExpected!=0):
            reportingDone = 1
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && !resolved):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        outcomeFour = 0
        outcomeSix = 0
        while n < numberEvents:
            votingPeriodEvent = self.getExpiration(events[n])/self.getPeriodLength(branch)
            fxpOutcome = self.getOutcome(events[n])
            resolution = 1
            if(self.getReportable(votingPeriodEvent, events[n])==-1):
                return(-7)
            if(self.getUncaughtOutcome(events[n])==0):
                return(-2)
            # TODO: if round 2 event && notFinal return 0
            if(binary(events[n]) && fxpOutcome==0):
                    resolution = self.resolveBinary(events[n], market, branch, votingPeriodEvent, period)
            elif(scalar(events[n]) && self.getMedian(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(2^64*self.getMinValue(events[n]), 2^64*self.getMaxValue(events[n]), event, market, branch, votingPeriodEvent, period)
            elif(categorical(events[n]) && self.getMedian(events[n])==0):
                    resolution = self.resolveCategoricalOrScalar(2^64, 2^64*self.getNumOutcomes(events[n]), event, market, branch, votingPeriodEvent, period)
            if(resolution==-4):
                outcomeFour = 1
            elif(resolution==-6):
                outcomeSix = 1
            n += 1
        if(outcomeFour):
            return(-4)
        elif(outcomeSix):
            return(-6)
        winningOutcomes = array(8)
        winningOutcomes = self.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)
        self.setWinningOutcomes(market, winningOutcomes)
        
        self.returnLiquidity(branch, market)
        return(1)
    else:
        return(0)

# @return 1 if success        
# Errors:
    # 0: reporting not done
    # -1: trader doesn't exist
def claimProceeds(branch, market):
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    events = array(3)
    events = self.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 1
    resolved = 1
    while i < numberEvents:
        numReports = self.getNumReportsEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(events[i])/self.getPeriodLength(branch), events[i])
        if(self.getOutcome(events[i])==0 && self.getMedian(events[i])==0):
            resolved = 0
        if(numReports != numExpected && numReports!=0 and numExpected!=0):
            reportingDone = 0
            i = numberEvents
        i += 1
    if((period > tradingPeriod || reportingDone) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = self.getWinningOutcomes(market, outitems=8)
        outcome = 0
        if(winningOutcomes[1]==0):
            outcome = self.oneOutcome(market, winningOutcomes[0])
        elif(winningOutcomes[7]):
            outcome = self.eightOutcomes(market, winningOutcomes, events)
        elif(winningOutcomes[3]):
            outcome = self.fourOutcomes(market, winningOutcomes, events)
        elif(winningOutcomes[1]):
            outcome = self.twoOutcomes(market, winningOutcomes, events)
        return(outcome)
    else:
        return(0)
        
### Helper functions
def returnLiquidity(branch, market):
    # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)
    # refund left over initial liquidity in market - half to market creator, other half to voters
    # *unless* it's a scaled decision, refund all initial liquidity left over to market creator
    # rest of money available in market + the additional trading fees divy up amongst reporters and market creator
    initialLiquidity = self.getCreationFee(market)
    winningOutcomes = array(8)
    winningOutcomes = self.getWinningOutcomes(market, outitems=8)
    valueOfShares = 0
    creator = self.getCreator(market)
    if(winningOutcomes[1]==0):
        valueOfShares = self.valueCalcOne(market, winningOutcomes[0])
    elif(winningOutcomes[7]):
        valueOfShares = self.valueCalcEight(market, winningOutcomes, events)
    elif(winningOutcomes[3]):
        valueOfShares = self.valueCalcFour(market, winningOutcomes, events)
    elif(winningOutcomes[1]):
        valueOfShares = self.valueCalcTwo(market, winningOutcomes, events)

    liquidityRemaining = self.balance(market) - valueOfShares
    if(liquidityRemaining<0):
        return(-1)
    # some scalar involved
    if(winningOutcomes[1]):
        if(liquidityRemaining > initialLiquidity):
            # pay back liquidity, split up excess profits
            self.addCash(creator, initialLiquidity)
            self.subtractCash(market, initialLiquidity)
            liquidityRemaining -= initialLiquidity
            self.addCash(branch, liquidityRemaining/2)
            self.addCash(creator, liquidityRemaining/2)
            self.subtractCash(market, liquidityRemaining)
        # send whatever's left of the initial liquidity to the creator
        else:
            self.addCash(creator, liquidityRemaining)
            self.subtractCash(market, liquidityRemaining)
    # no scalars
    else:
        # split up excess profits & liquidity
        self.addCash(branch, liquidityRemaining/2)
        self.addCash(creator, liquidityRemaining/2)
        self.subtractCash(market, liquidityRemaining)
    return(1)
    
macro scalar($event):
    ((self.getMaxValue($event)!=2 || self.getMinValue($event)!=1) && self.getNumOutcomes($event)==2)
    
macro binary($event):
    (self.getNumOutcomes($event)==2 and 2**64*self.getMaxValue($event)==2**65 and self.getMinValue($event)==1)
    
macro categorical($event):
    (self.getNumOutcomes($event)>2)
# # of winningOutcomes is 2
def twoOutcomes(market, winningOutcome: arr, events: arr):
    # look for the scalar
    scalar = 0
    if(((self.getMaxValue(events[0])!=2 || self.getMinValue(events[0])!=1) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*2^63):
        scalar = 0
    elif(((self.getMaxValue(events[1])!=2 || self.getMinValue(events[1])!=1) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*2^63):
        scalar = 1
    elif(((self.getMaxValue(events[2])!=2 || self.getMinValue(events[2])!=1) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*2^63):
        scalar = 2
    outcome = self.getOutcome(events[scalar])
    minValue = self.getMinValue(events[scalar])
    maxValue = self.getMaxValue(events[scalar])
    if(outcome>maxValue):
        outcome = maxValue
    elif(outcome<minValue):
        outcome = minValue
    # price is in fixed point
    # share two goes with the high side
    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)
    #share one goes with the low side of the calc
    pricePerShare1 = 2^64 - pricePerShare1
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, tx.origin)
    if(participantNumber == -1):
        return(-1)
    participant = self.getParticipantID(market, participantNumber)
    # for each winning outcome do...
    n = 0
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(self.getBranchID(market), market, participantNumber, winningOutcome[n], -sharesOwned)
        # low side
        if(n==0):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare1/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare1/2^64)
        # high side (of the scalar part)
        elif(n==1):
            self.subtractCash(market, sharesOwned*self.getCumScale(market)*pricePerShare2/2^64)
            self.addCash(participant, sharesOwned*self.getCumScale(market)*pricePerShare2/2^64)
        n+=1
    return(1)
    
def valueCalcTwo(market, winningOutcome: arr, events: arr):
    # look for the scalar
    scalar = 0
    if(((self.getMaxValue(events[0])!=2 || self.getMinValue(events[0])!=1) && self.getNumOutcomes(events[0])==2) || self.getOutcome(events[0])==3*2^63):
        scalar = 0
    elif(((self.getMaxValue(events[1])!=2 || self.getMinValue(events[1])!=1) && self.getNumOutcomes(events[1])==2) || self.getOutcome(events[1])==3*2^63):
        scalar = 1
    elif(((self.getMaxValue(events[2])!=2 || self.getMinValue(events[2])!=1) && self.getNumOutcomes(events[2])==2) || self.getOutcome(events[2])==3*2^63):
        scalar = 2
    outcome = self.getOutcome(events[scalar])
    minValue = self.getMinValue(events[scalar])
    maxValue = self.getMaxValue(events[scalar])
    if(outcome>maxValue):
        outcome = maxValue
    elif(outcome<minValue):
        outcome = minValue
    # price is in fixed point
    # share two goes with the high side
    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)
    #share one goes with the low side of the calc
    pricePerShare1 = 2^64 - pricePerShare1
    cumScale = self.getCumScale(market)
    sharesTotal1 = self.getSharesPurchased(market, winningOutcome[0]) - self.initialLiquidityAmount(market, winningOutcome[0])
    sharesTotal2 = self.getSharesPurchased(market, winningOutcome[1]) - self.initialLiquidityAmount(market, winningOutcome[1])
    value = sharesTotal1*cumScale*pricePerShare1/2**64 + sharesTotal2*cumScale*pricePerShare2/2**64
    return(value)
def quicksort(stuff: arr):
	if(len(stuff)<=1):
		return(stuff: arr)
	else:
		less = array(len(stuff))
		lsz = 0
		more = array(len(stuff))
		msz = 0
		equal = array(len(stuff))
		esz = 0
		i = 0
		while i < len(stuff):
			if stuff[i] < stuff[0]:
				less[lsz] = stuff[i]
				lsz += 1
			elif stuff[i] > stuff[0]:
				more[msz] = stuff[i]
				msz += 1
			else:
				equal[esz] = stuff[i]
				esz += 1
			i += 1
		less = self.quicksort(slice(less, items=0, items=lsz), outitems=lsz)
		more = self.quicksort(slice(more, items=0, items=msz), outitems=msz)
		newArr = array(lsz+esz+msz)
		n = 0
		while n < lsz:
			newArr[n] = less[n]
			n += 1
		z = 0
		while n < lsz+esz:
			newArr[n] = equal[z]
			z += 1
			n += 1
		z = 0
		while n < msz+lsz+esz:
			newArr[n] = more[z]
			z += 1
			n += 1
		return(newArr: arr)
# branches: votePeriod, reporterID (for both num hash submitted and num actual reports submitted) --- votePeriod, EventID --- eventID
data branches[](submittedHash[][], numReportsActual[][], hasReported[][](reported[]), beforeRep[][], afterRep[][], report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], reportedPeriod[][], firstReport[])
data reportable[][]

# need to finish this req. events stuff for round 2 pushback _and_:
    # what _if_ there are actually <30 events in augur?
        # perhaps we should have all reporters in that period report on all of them

data requiredEvents[]
#self.Events[event].threshold = 2**256
# branch, period as params
data numReqEvents[][]
data upToDateOnRR[]

def getReportedPeriod(branch, period, reporter):
    return(self.branches[branch].reportedPeriod[period][reporter])

def getReportable(votePeriod, eventID):
    return(self.reportable[votePeriod][eventID])

def setReportable(votePeriod, eventID):
    self.reportable[votePeriod][eventID] = 1
    return(1)

# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)
    
def getRRUpToDate():
    return(self.upToDateOnRR[msg.sender])
    
def setRRUpToDate():
    self.upToDateOnRR[msg.sender] = 1
    return(1)

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)

def getReport(branch, period, event):
    return(self.branches[branch].report[period][tx.origin].event[event])

def getBeforeRep(branch,period):
    return(self.branches[branch].beforeRep[period][tx.origin])

def getAfterRep(branch, period):
    return(self.branches[branch].afterRep[period][tx.origin])

def setBeforeRep(branch, period, rep):
    self.branches[branch].beforeRep[period][tx.origin] = rep
    return(rep)

def setAfterRep(branch, period, rep):
    self.branches[branch].afterRep[period][tx.origin] = rep
    return(rep)
    
def getNumReportsActual(branch, votePeriod):
    return(self.branches[branch].numReportsActual[tx.origin][votePeriod])

def getSubmittedHash(branch, period, reporter):
    return(self.branches[branch].submittedHash[period][reporter])

def makeHash(salt, report, eventID):
    hashInfo = array(4)
    hashInfo[0] = tx.origin
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Error 0: couldn't set report hash
# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
# Error -2: not in hash submitting timeframe or event doesn't exist / not a valid event expiring then
# Error -4: already resolved
# Error -5: .99 market
# Error -6: no markets
def submitReportHash(branch, reportHash, votePeriod, eventID, eventIndex):
    if(self.getVotePeriod(branch)!=votePeriod):
        return(-1)
    # make sure event is in the given branch...
    eventsID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventsID!=eventID || eventID == 0 || eventsID == 0):
        return(-2)
    if(self.getOutcome(eventID)!=0):
        return(-4)
    if(self.reportable[votePeriod][eventID]==-1):
        return(-5)
    if(!self.upToDateOnRR[msg.sender]):
        # TODO: calls to consensus functions and in send rep
        #doIt()
        self.upToDateOnRR[msg.sender] = 1
    #todo: if period isn't incremented, do it

    repIndex = self.repIDToIndex(branch, tx.origin)
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    currentExpPeriod = (block.number / periodLength)

    if(self.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
        return(-1)

    if(self.getNumEventsToReportOn(branch, votePeriod)==0):
        self.setNumEventsToReportOn(branch, votePeriod)

    # Whoever the first person to try to submit a report for period x on market y with events events checks if it needs to be reported on or not.
    if(self.reportable[votePeriod][eventID]==0):
        needsReportingOn = self.needsReportingOn(eventID)
        # if yes, the value is 1 and everything proceeds normally
        if(self.getOracleOnly(branch)):
            needsReportingOn = 1
        self.reportable[votePeriod][eventID] = needsReportingOn
        # If not, then no one can report on this market's event(s) and the event is "removed" from expEvents.
        if(needsReportingOn==-1):
            self.removeEvent(branch, votePeriod)
            return(-5)

    reportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)
    if(reportingThreshold==-6):
        return(-6)
    x = array(1)
    x[0] = tx.origin + eventID
    shaHash = sha3(x, items=1)/2**64
    if(residual < periodLength/2 && (shaHash < reportingThreshold || shaHash<self.getReportingThreshold(eventID))):
        # don't increment num reports expected or numreportshash per reporter for updated commitment, just the first time
        if(self.getReportHash(branch, votePeriod, msg.sender, eventID)==0):
            self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
        # submit hash of (tx.origin, salt, Votes[])
        if(self.setReportHash(branch, votePeriod, tx.origin, reportHash, eventID)):
            # if first report commitment this period
            if(self.branches[branch].submittedHash[period][msg.sender]==0):
                self.branches[branch].submittedHash[period][msg.sender] = 1
            return(1)
        else:
            return(0)
    else:
        return(-2)

# @return 1 if success
# Error messages
    # -1: has already reported
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
    # -3: hash doesn't match
    # -4: no rep
    # -5: bad report
    # -6: hash not low enough
    # -8: invalid event
    # -9: already resolved
    # -10: <24 hr left in period, too late to report, able to put up readj. bonds though
def submitReport(branch, votePeriod, eventIndex, salt, report, eventID, ethics):
    if(self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod]==1):
        return(-1)
    # if currentExpPeriod is more than 2 periods past the current vote period
    # then there can be no more voting for that voting period
    # (reasoning being: >=1 period past means all the events in that period have expired)
    # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
    # currently requires events to expire to vote
    periodLength = self.getPeriodLength(branch)
    currentExpPeriod = (block.number / periodLength)
    repIndex = self.repIDToIndex(branch, tx.origin)
    if (self.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1) || self.getVotePeriod(branch)!=votePeriod):
        return(-2)
    if(self.getRepBalance(branch, tx.origin)<10*2**64):
        return(-4)
    # make sure event is in the given branch and vote period...
    event = self.getEvent(branch, votePeriod, eventIndex)
    if(event==0 || eventID!=event):
        return(-8)
    if(self.getOutcome(eventID)!=0):
        return(-9)
    #if(block.number/self.getPeriodLength(branch)!=((block.number + 4800)/self.getPeriodLength(branch))):
    #    return(-10)
    if(!self.upToDateOnRR[msg.sender]):
        # TODO: calls to consensus functions and in send rep
        #doIt()
        self.upToDateOnRR[msg.sender] = 1
    x = array(1)
    x[0] = tx.origin + eventID
    reportingThreshold = self.calculateReportingThreshold(branch, eventID, votePeriod)
    # in fxp (2**192) == 2**256 / 2**64
    # TODO / need:
        # coefficient for reporting minimum based off of appeals
        #Base Reporter Amount = 3+(200*Appeal_Ratio)^3
        #This keeps the base reporter amount 3-10 until it starts getting over 1%, it makes 2% 67 and 3% 219
        #Calculated as opposed to a global variable that slowly changes over time that is.
        #I think perhaps the target number of reports per reporter could be something like   150+Base_Reporter_Amount
    shaHash = sha3(x, items=1)/2**64
    if(shaHash < reportingThreshold || shaHash<self.getReportingThreshold(eventID)):
        residual = block.number % periodLength
        if(residual > periodLength/2):
            realHash = self.getReportHash(branch, votePeriod, msg.sender, eventID)
            reportHash = self.makeHash(salt, report, eventID)
            if(reportHash!=realHash):
                (return(-3))
            if(self.branches[branch].firstReport[votePeriod]==0):
                self.setInitialBalance(branch, votePeriod, self.balance(branch))
                self.branches[branch].firstReport[votePeriod] = 1
            report = self.validateReport(eventID, branch, votePeriod, report)
            if(report == -5):
                return(-5)
            # reporter has reported for 1 more event
            self.branches[branch].numReportsActual[tx.origin][votePeriod] += 1
            # record that reporter has reported for this event
            self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod] = 1
            # set report value for event
            self.branches[branch].report[period][tx.origin].event[eventID] = report
            # set ethics value for event
            if(ethics!=2**64 || ethics!=0):
                ethics = 2**64
            ethics = (self.getEthics(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            self.setEthics(eventID, ethics)
            # add 1 report to the event
            self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
            # if 1st report of the period for a reporter
            if(!self.branches[branch].reportedPeriod[votePeriod][tx.origin]):
                repReported = self.getTotalRepReported(branch)
                balance = self.getRepBalance(branch, tx.origin)
                repReported += balance
                self.setTotalRepReported(branch, votePeriod, repReported)
                #Record rep at start of report period
                self.branches[branch].beforeRep[votePeriod][tx.origin] = balance
                self.branches[branch].afterRep[votePeriod][tx.origin] = balance
                self.branches[branch].reportedPeriod[votePeriod][tx.origin] = 1
            return(1)
        return(-2)
    else:
        return(-6)

### Helper functions:
def calculateReportingThreshold(branch, eventID, votePeriod):
    numMarkets = self.getNumMarkets(eventID)
    if(numMarkets==0):
        return(-6)
    if(numMarkets>100):
        numMarkets = 100
    markets = array(numMarkets)
    markets = self.getMarkets(eventID, outitems=numMarkets)
    volume = 0
    i = 0
    while i < numMarkets:
        # may be best to store vol here
        volume += self.getVolume(markets[i])
        i += 1
    totalVol = self.getPeriodVolume(branch, votePeriod)
    # if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64
    logOutput = self.fx_log(self.getRepBalance(branch, tx.origin)*2**64/self.getTotalRep(branch))
    repConstant = self.fx_exp(22136092888451461120*logOutput/2**64)
    repConstant += 18446744073709552
    volFraction = 0
    if(totalVol!=0):
        volFraction = volume*2**64/totalVol
    numEvents = self.getNumEventsToReport(branch, votePeriod)
    if(numEvents < 30*2**64):
        repConstant = 30*2**128/numEvents
    # in fxp (2**128) == 2**192 / 2**64
    reportingThreshold = 40*((-(267*volFraction**2)/(2*2**64) + (533*volFraction)/2 + 1*2**64)*repConstant/2**64) * (2**128)
    return(reportingThreshold)

#a^b=exp(b*ln(a))=e^(b*ln(a)).
#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
# returns num events to report on in fxp
def getNumEventsToReport(branch, votePeriod):
    prelim = self.getNumEventsToReportOn(branch, votePeriod)
    repConstant = self.getRepBalance(branch, tx.origin)*2**64/self.getTotalRep(branch)
    logOutput = self.fx_log(repConstant)
    exp = self.fx_exp(22136092888451461120*logOutput/2**64)
    exp += 18446744073709552
    total = exp*prelim + self.numReqEvents[branch][votePeriod]*2**64
    return(total)

def needsReportingOn(event):
    # This only works for categorical and binary markets, not scalar
    if((2^64*self.getMaxValue(events[n]) != 2*2**64 || 2^64*self.getMinValue(events[n]) != 2**64) and self.getNumOutcomes(events[n]) == 2):
        return(1)
    # To determine whether a market needs to be resolved or not, the events can only have one market associated with them or all markets associated with the event fulfill the .99 qualification.
    numMarkets = self.getNumMarkets(event)
    markets = array(numMarkets)
    markets = self.getMarkets(event, outitems=numMarkets)
    if(numMarkets>100):
        return(1)
    i = 0
    # todo optimize perf. here
    while i < numMarkets:
        numOutcomes = self.getMarketNumOutcomes(markets[i])
        n = 1
        ninetynine = 0
        while n <= numOutcomes:
            if(self.price(markets[i], n) > 18262276632972456099):
                ninetynine = 1
                n = numOutcomes+1
            n += 1
        if(ninetynine == 0):
            return(1)
        i += 1
    # doesn't need reporting on, meets the .99 qualification
    return(-1)

def validateReport(eventID, branch, votePeriod, report):
    # check report validity
    numOutcomes = self.getNumOutcomes(eventID)
    maxValue = self.getMaxValue(eventID)
    minValue = self.getMinValue(eventID)
    # binary
    if(numOutcomes==2 and maxValue==2 && minValue==1):
        if(report>2*2^64 or report<2^64 or report==0):
            return(-5)
        # submit report
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        outcome = (self.getUncaughtOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
        self.setUncaughtOutcome(eventID, outcome)
    # categorical
    elif(numOutcomes>2):
        minValue = 2^64
        range = numOutcomes*2^64 - minValue
        if(report<0):
            return(-5)
        if((report*range/2^64 + minValue)>numOutcomes*2^64):
            report = 2^64
        # submit report
        # outcome (uncaught and median) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way
        # returns -5 until we add support for median calcs
        return(-5)
    # scalar
    else:
        if(report<0):
            return(-5)
        range = maxValue*2^64 - minValue*2^64
        if((report*range/2^64 + minValue*2^64) > maxValue*2^64):
            report = 2^64
        if((report*range/2^64 + minValue*2^64) < minValue*2^64):
            report = 0
        # submit report
        # outcome should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way
        # returns -5 until we add support for median calcs
        return(-5)
    return(report)
# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# @return eventID if success
# error messages otherwise
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # 0: not enough money to pay fees or event already exists
    # -2: max value < min value
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
    periodLength = self.getPeriodLength(branch)
    if(maxValue < minValue):
        return(-2)
    if periodLength && description != 0 && expDate > block.number:
        eventinfo = string(8*32 + len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo + 8*32, description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(-1)
    if(numOutcomes < 2 || numOutcomes > 50):
        return(0)
    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)
    currentVotePeriod = self.getVotePeriod(branch)
    participationFactor = (self.getTotalRepReported(branch, currentVotePeriod-2) * 2^64) / self.getTotalRepReported(branch, currentVotePeriod-1)
    if participationFactor == 0:
        participationFactor = 1
    self.initiateOwner(eventID)
    # send fee and bond
    if self.balance(tx.origin) >= (42*2^64 + participationFactor*45):
        if !self.getCreator(eventID) && !self.getEventBranch(eventID) && self.send(eventID, 42*2^64) && self.send(branch, participationFactor*45):
            # see which future period it expires in && put the event in that bin
            # event voting periods - expDate / periodLength gives you the voting period #
            futurePeriod = expDate / periodLength
            if self.setInfo(eventID, description, tx.origin, participationFactor*45) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes):
                return(eventID)
            else:
                return(0)
        else:
            return(0)
    else:
        return(0)

def insertionSort(stuff: arr):
	i = 1
	while i < len(stuff):
		j = i-1
		key = stuff[i]
		while (stuff[j] > key and j>=0):
			stuff[j+1] = stuff[j]
			j -= 1
		i += 1
		stuff[j+1] = key
	return(stuff: arr)
# round two consensus data
data bondPaid[]
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)

# branch takes a branchID
    # denominator takes a vote period
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
data branch[](denominator[], penalized[][](event[], num, notEnoughReportsPenalized), penalizedUpTo[], feesCollected[][])

#1. Record rep at start of report period [before rep in make reports]
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
#5. If you don't do it for all events or don't penalize for not reporting enough, autolose 20% rep each period one does this (b/c they're trying to cheat)
# Errors:
    # -1: pushed back event already resolved, so can't redistribute rep based off of its original expected expiration period
    # -2: already past first half of new period and needed to penalize before then
    # -3: need to do not enough reports penalization [or lackthereof]
def penalizeWrong(branch, event):
    lastPeriod = self.getVotePeriod(branch)-1
    if(!self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized):
        return(-3)
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    if(residual > periodLength/2):
        return(-2)
    if(self.getOriginalExpiration(event)!=self.getExpiration(event) && self.getPushedForward(market)):
        if(lastPeriod==self.getOriginalExpiration(event)/self.getPeriodLength(branch)):
            return(-1)
    outcome = self.getOutcome(event)
    reportValue = self.getReport(branch, lastPeriod, event)
    p = self.proportionCorrect(event)
    oldRep = self.getBeforeRep(branch, period)                               # hmmmm
    if(!self.branch[branch].penalized[lastPeriod][tx.origin].event[event] && self.getVotePeriod(branch) > period && reportValue && outcome!=0):
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):
            #if(scalar(event) or categorical(event) or outcome==3*2**64):
                #p = -(abs(reportValue - self.getMedian(event))/2) + 2**64
            newRep = oldRep*(2*p - 2**64)/2**64
        # right
        else:
            #if(scalar(event) or categorical(event) or outcome==3*2**64):
                #p = -(abs(reportValue - self.getMedian(event))/2) + 2**64
            newRep = oldRep*(2*(2**64-p)**2 / p + 2**64)
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/2**64 + newRep * 3689348814741910528/2**64
        self.setAfterRep(branch, lastPeriod, smoothedRep)
        repChange = smoothedRep - oldRep
        self.branch[branch].denominator[period] += smoothedRep
        if(repChange < 0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, tx.origin), repChange)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        if(self.getNumReportsActual(branch, lastPeriod)==self.branch[branch].penalized[lastPeriod][tx.origin].num):
            self.branch[branch].penalizedUpTo[tx.origin] = lastPeriod
        self.branch[branch].penalized[lastPeriod][tx.origin].event[event] = 1
        self.branch[branch].penalized[lastPeriod][tx.origin].num += 1
        return(1)
    else:
        return(0)

# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account and distributed like trading fees.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
# Errors:
    # -1: already done
    # -2: hasn't reported this period
def penalizeNotEnoughReports(branch):
    lastPeriod = self.getVotePeriod(branch)-1
    if(self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized):
        return(-1)
    if(!hasReported(branch, lastPeriod)):
        return(-2)
    numEvents = self.getNumEventsToReport(branch, lastPeriod)
    # min. of 30 events no matter how little rep you have
    if(numEvents < 30*2**64):
        numEvents = 30*2**64
    repConstant = self.getRepBalance(branch, tx.origin)*2**64/self.getTotalRep(branch)
    logOutput = self.fx_log(repConstant)
    exp = self.fx_exp(22136092888451461120*logOutput/2**64)
    exp += 18446744073709552
    total = exp*40
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)
    if(total > 2**64):
        numEvents = (self.getNumEventsToReportOn(branch, votePeriod)/40)*2**64
    # what _if_ there are actually <30 events in augur?
        # perhaps we should have all reporters in that period report on all of them
    numReportsActual = self.getNumReportsActual(branch, lastPeriod)
    if(numEvents/(2*2**64) > self.getNumReportsActual(branch, lastPeriod)):
        originalRep = self.getRepBalance(branch, tx.origin)
        # penalize people
        newRep = 3689348814741910528*numReportsActual*originalRep / self.getNumEventsToReport(branch, lastPeriod)
        oldRep = self.getRepBalance(branch, tx.origin)*14757395258967642112 / 2**64
        repChange = (oldRep+newRep) - originalRep
        # removes rep from reporter who lost it
        self.addRep(branch, self.repIDToIndex(branch, tx.origin), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        self.setBeforeRep(branch, lastPeriod, oldRep+newRep)
    self.branch[branch].penalized[lastPeriod][tx.origin].notEnoughReportsPenalized = 1
    return(1)

# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
    # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
def collectFees(branch):
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    if(residual < periodLength/2):
        return(-2)
    if(!repRedistributionDone(branch, tx.origin)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    lastPeriod = self.getVotePeriod(branch) - 1
    repReported = self.getTotalRepReported(branch, lastPeriod)
    return(self.branch[branch].feesCollected[lastPeriod][tx.origin])
    if(!self.branch[branch].feesCollected[lastPeriod][tx.origin] && hasReported(branch, lastPeriod)):
        newRep = self.getAfterRep(branch, lastPeriod)
        denominator = self.branch[branch].denominator[lastPeriod]
        gainedRep = newRep * 2**64 / denominator * self.getRepBalance(branch, branch) / 2**64
        #if(lostRep) newRep should be == self.getAfterRep(branch, period) + gainedRep
        #if(gainedRep) newRep should be == self.getBeforeRep(branch, period) + gainedRep
        self.addRep(branch, self.repIDToIndex(branch, tx.origin), gainedRep)
        self.subtractRep(branch, self.repIDToIndex(branch, branch), gainedRep)
        cash = self.getInitialBalance(branch, lastPeriod) * newRep / denominator
        self.addCash(tx.origin, cash)
        self.subtractCash(branch, cash)
        self.branch[branch].feesCollected[lastPeriod][tx.origin] = 1
        return(1)
    else:
        return(0)

# call when a user who hasn't reported for a while wants to start again and needs to catch up on penalizations
# should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then
def penalizationCatchup(branch):
    # find delta between this last period and last penalized up to
    lastPeriodPenalized = self.branch[branch].penalizedUpTo[tx.origin]
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    oldRep = self.getRepBalance(branch, tx.origin)
    if(lastPeriodPenalized!=lastPeriod && !hasReported(branch, lastPeriod)):
        # dock 10% for each period they didn't penalize on
        smoothedRep = oldRep*(14757395258967642112/2)/2**64
        i = 0
        while i < delta:
            smoothedRep = smoothedRep*(14757395258967642112/2)/2**64
            i += 1
        # and send it to branch for penalty rep collection
        repChange = oldRep - smoothedRep
        # removes rep from reporter who lost it
        self.subtractRep(branch, self.repIDToIndex(branch, tx.origin), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), repChange)
        self.branch[branch].penalizedUpTo[tx.origin] = lastPeriod
        return(1)
    else:
        return(0)


# anti cheat provide ballot and randomNum mechanism steal deposit
# Returns:
    # 0: not a valid claim
    # -2: reporter doesn't exist
def slashRep(branch, votePeriod, salt, report, reporter, eventID):
    realHash = self.getReportHash(branch, votePeriod, reporter, eventID)
    hashInfo = array(4)
    hashInfo[0] = reporter
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    if(reportHash!=realHash):
        return(0)
    else:
        reporterIndex = self.repIDToIndex(branch, reporter)
        trutherIndex = self.repIDToIndex(branch, tx.origin)
        trutherBalance = self.getRepBalance(branch, tx.origin)
        # if the truther's rep. account doesn't exist, make one
        if(self.getReporterID(branch, trutherIndex)!=tx.origin):
            trutherIndex = self.getNumberReporters(branch)
            self.addReporter(branch, tx.origin)
        if(self.getReporterID(branch, reporterIndex)!=reporter):
            return(-2)
        reporterBalance = self.getRepBalance(branch, reporter)
        self.setRep(branch, reporterIndex, 0)
        self.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*2**63 / 2**64))
    return(reporterBalance)

def incrementPeriodAfterReporting(branch):
    # do this after reporting is finished
    if(periodOver(branch)):
        self.incrementPeriod(branch)
        return(1)
    else:
        return(0)
        
### Helper functions:

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
def proportionCorrect(event, branch, period):
    p = 0
    outcome = self.getOutcome(event)
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and 2**64*self.getMaxValue(event)==2**65 and 2**64*self.getMinValue(event)==2**64):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getUncaughtOutcome(event) - 2**64
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == 2**64):
                p = 2**64 - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * 2**64):
                p = avgOutcome
            if(outcome == 3 * 2**63):
                return(0)
        return(p)
    else:
        return(0)

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.number / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
    
macro hasReported($branch, $period):
    self.getReportedPeriod($branch, $period, tx.origin)

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0


macro scalar($event):
    ((self.getMaxValue($event)!=2 || self.getMinValue($event)!=1) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and 2**64*self.getMaxValue($event)==2**65 and self.getMinValue($event)==1)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)

# test bonded pushed forward event/market though not ready to be resolved
    # code in penalize for that:
        #elif(rejected && rejectedPeriodOver && && actuallyrejected && self.getReport(branch, lastPeriodperiod, event) && !self.penalized[lastPeriod][tx.origin].event[event] && outcome):
        #  outcome = 2**63
        #  median = 2**63
        #   p = self.proportionCorrect(event, rejected)
        #   oldRep = self.getBeforeRep(branch, period)
        #   # wrong
        #   if(reportValue > outcome+.01 or reportValue < outcome-.01):
        #       if(scalar or categorical or .5):
        #         # scalar/cat are 0 - 1, binary .5 are 1-2 and 1.5
        #     # should be outcome since median is the same
        #           p = -(abs(reportValue - median)/2) + 1
        #       newRep = oldRep*(2*p -1)
        #   # right
        #   else:
        #       if(scalar or categorical or .5):
        #           p = -(abs(reportValue - median)/2) + 1
        #       newRep = oldRep*(2*(1-p)**2 / p + 1)
        #   smoothedRep = oldRep*.8 + newRep*.2
        #   self.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))
        # repChange = smoothedRep - oldRep
        # if(repChange < 0):
        #   sendToRedistribPool
        # # need to except round two events from this when added
        # if(self.getNumReportsActual(branch, lastPeriod)==self.penalized[lastPeriod][tx.origin].num):
        #   self.totalRepPenalized[period] += oldRep
        #   self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)
        # self.penalized[lastPeriod][tx.origin].event[event] = 1
        # self.penalized[lastPeriod][tx.origin].num += 1
        #   return(1)
# test .99 resolve push forward
event comment(market: indexed, ipfsHash)

def addComment(market, ipfsHash):
    log(type=comment, market, ipfsHash)
    return(1)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    # Rep cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.getVotePeriod(branch)
    #if(value<=0 || !self.send(branch, 5*2^64) || self.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || self.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || self.getReport(branch, currentVotePeriod, recver, 0) != 0):
    #    return(0)
    # need to check all this for the person it's being sent to as well
    #if(self.getRRUpToDate()!=1):
    #    doIt()
    #    self.RRDone = true
    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees):
    #    self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractRep(branch, senderIndex, value) && self.addRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendDormantRep(branch, recver, value):
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0 || !self.send(branch, 5*2^64)):
        return(0)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getDormantRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# error messages
    # -1: not in first half of reporting period
def convertToDormantRep(branch, value):
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    if(residual > periodLength/2):
      return(-1)
		# benny comment:
            #```Maybe still have this sort-of variable "power" to it, but REP initially doesn't have "full-power", or REP that hasn't been used to report over the past week has now let it's "power-meter" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch "on" or switch "off" the self. If a user knows, "I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power", well that's pretty good incentive to keep the user active, without actually taking it from them.```

    if(value<=0 || !self.send(branch, 5*2^64) || self.getSubmittedHash(branch, period, msg.sender)):
        return(0)

    #if(self.getRRUpToDate()!=1):
    #    doIt()

    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        return(-1)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractRep(branch, senderIndex, value) && self.addDormantRep(branch, senderIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# error messages
    # -1: not in first half of reporting period
def convertToActiveRep(branch, value):
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.number % periodLength
    if(residual > periodLength/2):
      return(-1)

    if(value<=0 || !self.send(branch, 5*2^64) || self.getSubmittedHash(branch, period, msg.sender)):
        return(0)

    #if(self.getRRUpToDate()):
        #doIt()
    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        return(-1)

    senderBalance = self.getDormantRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addRep(branch, senderIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, numberRemoved, events[], totalRepReported, numEventsToReportOn, reportHash[][], periodVolume)

data EventIDToIndex[][]

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
	return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch, expDateIndex):
	# after voting has started
	if(expDateIndex==self.getVotePeriod(branch)):
		numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
		numberToReportOnEstimate = (numEvents-self.EventsExpDates[branch][expDateIndex].numberRemoved)*40
		self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = numberToReportOnEstimate
		return(1)
	else:
		return(-1)


def getNumEventsToReportOn(branch, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getPeriodVolume(branch, expIndex):
	return(self.EventsExpDates[branch][expIndex].periodVolume)

def getNumberEvents(branch, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
	return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getTotalRepReported(branch, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].totalRepReported)

def getReportHash(branch, expDateIndex, reporter, event):
	return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
	self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
	self.EventsExpDates[branch][futurePeriod].numberEvents += 1
	return(1)

def removeEvent(branch, period):
	self.EventsExpDates[branch][period].numberRemoved += 1
	return(1)

def setTotalRepReported(branch, expDateIndex, repReported):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	self.EventsExpDates[branch][expDateIndex].totalRepReported = repReported
	return(1)

def addPeriodVolume(branch, expIndex, volume):
	self.EventsExpDates[branch][expIndex].periodVolume += volume
	return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
	return(1)

def moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    x = 0
    while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):
        self.EventsExpDates[branch][currentPeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]
        self.EventIDToIndex[currentPeriod][self.EventsExpDates[branch][currentVotePeriod-1].events[x]] = self.EventsExpDates[branch][futurePeriod].numberEvents
        self.EventsExpDates[branch][currentPeriod].numberEvents += 1
        # sub and set old period event to 0 poss.?
        x += 1
    return(1)
# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)
# period parameter for reporting
# currentExpPeriod = (block.number / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# should add a min initial liquidity property, for non pm branches it'd be low and .5*minInitialLiquidity is == fee for event
# could also add an event fee parameter
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod)

# first param is the branch, second param is the subcurrency contract
data cash[][]

data branchList[]

data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    return(self.initiateOwner(1010101))

def getOracleOnly(branch):
	return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
	return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
	return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
	self.Branches[branch].balance[period] = balance
	return(balance)

def getInitialBalance(branch, period):
	return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
	return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
	return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
	return(self.branchListCount)

def getBranch(branchNumber):
	return(self.branchList[branchNumber])

def getCreationDate(ID):
	return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	if(self.Branches[ID].periodLength==0):
		self.Branches[ID].currentVotePeriod = currentVotePeriod
		self.Branches[ID].periodLength = periodLength
		self.Branches[ID].minTradingFee = minTradingFee
		self.branchList[self.branchListCount] = ID
		self.branchListCount += 1
		self.Branches[ID].creationDate = block.number
		self.Branches[ID].parentPeriod = parentPeriod
		self.Branches[ID].oracleOnly = oracleOnly
		self.initiateOwner(ID)
		return(1)
	else:
		return(0)

def getParentPeriod(branch):
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	self.Branches[branch].currentVotePeriod += 1
	return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	numMarkets = self.Branches[branch].numMarkets
	self.Branches[branch].markets[numMarkets] = market
	self.Branches[branch].numMarkets += 1
	return(1)

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

def fx_exp(x):
	return(fx_exp(x))

def fx_log(x):
	return(fx_log(x))

def sqrt(n):
    val = n
    i = 0
    while i < 11:
        val = (val + n*2^64/val)/2
        i += 1
    return val
# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value, but consensus will return 2^64 and 2^65 respectively
# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1
# S&P 500 scalar would be say 0 && 4700, respectively
# categorical markets have fixed point min and max
 # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, numReports, median, uncaughtOutcome, final, ethical, originalExp, rejected, rejectedPeriod, rejectedUncaught, pushedBack)

def getEventInfo(event):
    info = array(6)
    info[0] = self.Events[event].branch
    info[1] = self.Events[event].expirationDate
    info[2] = self.Events[event].outcome
    info[3] = self.Events[event].minValue
    info[4] = self.Events[event].maxValue
    info[5] = self.Events[event].numOutcomes
    return(info: arr)

def getEventBranch(event):
	return(self.Events[event].branch)

def getPushedBack(event):
	return(self.Events[event].pushedBack)

def getExpiration(event):
	return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
	return(self.Events[event].originalExp)

def setExpiration(event, date):
	self.Events[event].expirationDate = date
	return(1)

def getOutcome(event):
	# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
	return(self.Events[event].outcome)

def getEthics(event):
	return(self.Events[event].ethical)

def setEthics(event, ethicality):
	self.Events[event].ethical = ethicality
	return(ethicality)

def getEthical(event):
	return(self.Events[event].ethical)

def getFinal(event):
	return(self.Events[event].final)

def getMinValue(event):
	return(self.Events[event].minValue)

def getMaxValue(event):
	return(self.Events[event].maxValue)

def getNumOutcomes(event):
	return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
	self.Events[event].uncaughtOutcome = outcome
	return(1)

def getUncaughtOutcome(event):
	# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
	return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes):
	# check that msg.sender is one of our function contracts
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	if(self.Events[ID].expirationDate==0):
		self.Events[ID].branch = branch
		self.Events[ID].expirationDate = expirationDate
		self.Events[ID].originalExp = originalExp
		self.Events[ID].minValue = minValue
		self.Events[ID].maxValue = maxValue
		self.Events[ID].numOutcomes = numOutcomes
		return(1)
	else:
		return(0)

def addMarket(event, marketID):
	self.Events[event].markets[self.Events[event].numMarkets] = marketID
	self.Events[event].numMarkets += 1
	return(1)

def getMarkets(event):
	i = 0
	markets = array(self.Events[event].numMarkets)
	while i < self.Events[event].numMarkets:
		markets[i] = self.Events[event].markets[i]
		i += 1
	return(markets: arr)
	
def getMarket(event, marketIndex):
	return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
	return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	self.Events[ID].outcome = outcome
	return(1)

#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
	# first check is if event expDate is in the current vote period and second is if blockNum is near expiration of voting period (within 7200 blocks or 24 hr.)
	# final check is if < 25 reports so far
	# (block.number+7200) / self.getPeriodLength(branch) -1 is what we're reporting on in 24 hr
	# vote period + 1 is the next vote period
	# so if in 24 hr we'd be in the next vote period, we're within 24 hr of the end of this one
	if(self.getVotePeriod(self.Events[event].branch)==self.Events[event].expirationDate/self.getPeriodLength(self.Events[event].branch) and (((block.number+7200) / self.getPeriodLength(branch)) - 1)==(self.getVotePeriod(self.Events[event].branch)+1) and self.Events[event].numReports<25):
		self.Events[event].threshold = 2**192
		return(1)
	else:
		return(0)

def getNumReports(event):
	return(self.Events[event].numReports)

def addNumReports(event):
	self.Events[event].numReports += 1
	return(1)

def getReportingThreshold(event):
	return(self.Events[event].threshold)

def getMedian(event):
	# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
	return(self.Events[event].median)

def setMedian(event, median):
	self.Events[event].median = median
	return(1)

def setFinal(event, final):
	self.Events[event].final = 1
	return(1)

def setRejected(event, period, uncaughtOutcome):
	self.Events[event].rejected = 1
	self.Events[event].rejectedPeriod = period
	self.Events[event].rejectedUncaught = uncaughtOutcome
	return(1)
	
def setPushedBack(event):
	self.Events[event].pushedBack = 1
	return(1)

def getRejected(event):
	return(self.Events[event].rejected)

def getRejectedPeriod(event):
	return(self.Events[event].rejectedPeriod)

def getRejectedUncaught(event):
	return(self.Events[event].rejectedUncaught)
# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID))

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    return(self.whitelists[msg.sender].addresses[address])

def checkContractWhitelist(contract, address):
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
def getDormantRepBalance(branch, address):
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

def getReporterID(branch, index):
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = tx.origin
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    return(self.Reporting[branch].repIDtoIndex[repID])

def hashReport(report: arr, salt):
    hashInfo = array(len(report) + 2)
    hashInfo[0] = tx.origin
    hashInfo[1] = salt
    i = 2
    while i < (len(report) + 2):
        hashInfo[i] = report[i-2]
        i += 1
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

#def claimInitialRep(parent, branchID):
    # have 1 month to claim
#    if(self.repIDToIndex(branchID, msg.sender)==0 && block.number < (self.getCreationDate(branchID) + 216000)):
#        i = self.Reporting[branchID].numberReporters
 #       rep = self.getBeforeRep(parent, self.getParentPeriod(branchID))
  #      reporterID = msg.sender
   #     self.Reporting[branchID].reputation[i].reporterID = reporterID
    #    self.Reporting[branchID].reputation[i].repValue = rep
     #   self.Reporting[branchID].repIDtoIndex[reporterID] = i
      #  self.Reporting[branchID].dormantRep[i].reporterID = reporterID
       # self.Reporting[branchID].dormantRep[i].repValue = self.getDormantRep(parent, self.getParentPeriod(branchID))
        #self.Reporting[branchID].numberReporters += 1
        #self.Reporting[branchID].totalRep += rep
        #return(1)
    #else:
        # already claimed or too late
     #   return(0)

def addReporter(branch, sender):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = 0
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

data cashcoinBalances[]

data owners[]


# @return: cash balance of address
def balance(address):
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
# @return: value sent, 0 if fails
# If you've never used cash in augur, to initiate your account call this with value as 0
def send(recver, value):
    if(self.owners[tx.origin]==0):
        self.owners[tx.origin] = tx.origin
    if(self.owners[recver]==0):
        return(0)
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from]):
        return(0)
    if(self.owners[recver]==0):
        return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
        return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
        return(0)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    if(msg.sender!=self.owners[address] && tx.origin!=self.owners[ID]):
        return(0)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * 2^64 / 10^18
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * 2^64 / 10^18:
        self.cashcoinBalances[msg.sender] -= value * 2^64 / 10^18
        send(to, value)
        return 1
    else:
        return 0

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, forkSelection, pushingForward, bondsMan, originalPeriod, initialLiquidity[])

def getTotalSharesPurchased(market):
    total = 0
    n = self.Markets[market].numOutcomes
    i = 0
    while i < n:
      total += self.Markets[market].sharesPurchased[i]
      i += 1
    return(total)

def getMarketEvent(market, index):
    return(self.Markets[market].events[index])

macro TRADER_FIELDS: 3
macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro FIELDS: 12

def getMarketInfo(marketID):
    index = FIELDS
    participantNumber = self.Markets[marketID].addr2participant[tx.origin]
    descriptionLength = self.getDescriptionLength(marketID)
    with info = array(FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):
        numEvents = self.Markets[marketID].lenEvents
        info[0] = marketID
        info[1] = self.Markets[marketID].currentParticipant
        info[2] = self.Markets[marketID].alpha
        info[3] = participantNumber
        info[4] = self.Markets[marketID].numOutcomes
        info[5] = self.Markets[marketID].tradingPeriod
        info[6] = self.Markets[marketID].tradingFee
        info[7] = self.Markets[marketID].branch
        info[8] = numEvents
        info[9] = self.Markets[marketID].cumulativeScale
        info[10] = self.getCreationFee(marketID)
        info[11] = self.getCreator(marketID)

        # gather trader(s) info: [trader ID, yes shares, no shares]
        t = 0
        while t < self.Markets[marketID].currentParticipant:
            info[index + t*TRADER_FIELDS] = self.Markets[marketID].participants[t].participantID
            info[index + t*TRADER_FIELDS + 1] = self.Markets[marketID].participants[t].shares[1]
            info[index + t*TRADER_FIELDS + 2] = self.Markets[marketID].participants[t].shares[2]
            t += 1
        index += self.Markets[marketID].currentParticipant*TRADER_FIELDS

        # gather event(s) info:
        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
        with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):
            i = 0
            while i < numEvents:
                with eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS):
                    info[index + i*EVENTS_FIELDS] = events[i]
                    j = 1
                    while j < EVENTS_FIELDS:
                        info[index + i*EVENTS_FIELDS + j] = eventInfo[j]
                        j += 1
                i += 1
        index += numEvents*EVENTS_FIELDS

        # gather outcomes info:
        # [sharesPurchased, price, winningOutcomes...]
        k = 0
        while k < self.Markets[marketID].numOutcomes:
            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]
            info[index + k*OUTCOMES_FIELDS + 1] = self.price(marketID, k + 1)
            k += 1
        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS
        k = 0
        while k < WINNING_OUTCOMES_FIELDS:
            info[index + k] = self.Markets[marketID].winningOutcomes[k]
            k += 1
        index += WINNING_OUTCOMES_FIELDS

        # append description character codes
        info[index] = descriptionLength
        index += 1
        with description = self.getDescription(marketID, outchars=descriptionLength):
            c = 0
            while c < descriptionLength:
                info[index + c] = getch(description, c)
                c += 1
        return(info: arr)

# Gets all information about all markets on the specified branch and
# returns it as a giant array.  getMarketsInfo requires a great deal of gas.
# Invoke using eth_call with gas=9999999999999 (or other very large number).
# @param {int} branch Branch ID that we're retrieving markets on.
# @param {int} offset Starting market index (0=full load).
# @param {int} numMarketsToLoad How many markets to load (0=all markets).
# @return array Array containing all data for all markets:
#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]
#           where length_j is the number of elements stored for market j,
#           info_j is the information array for market j, and N is the total
#           number of markets in this branch.
def getMarketsInfo(branch, offset, numMarketsToLoad):
    numMarkets = self.getNumMarketsBranch(branch)
    with marketIDs = self.getMarketsInBranch(branch, outitems=numMarkets):
        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:
            numMarkets = numMarketsToLoad
        with marketsMatrix = array(numMarkets):
            with marketArrayLength = array(numMarkets):
                m = 0
                while m < numMarkets:
                    marketID = marketIDs[m + offset]
                    participantNumber = self.Markets[marketID].addr2participant[tx.origin]
                    descriptionLength = self.getDescriptionLength(marketID)
                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1
                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])
                    m += 1

                # flatten the markets info matrix so it can be returned
                # (data offset by 1+numMarkets so length data can be prepended)
                totalFlatLength = 1 + numMarkets
                m = 0
                while m < numMarkets:
                    totalFlatLength += marketArrayLength[m]
                    m += 1
                with flattened = array(totalFlatLength):
                    flattened[0] = numMarkets
                    m = 0
                    while m < numMarkets:
                        flattened[m + 1] = marketArrayLength[m]
                        m += 1
                    currentFlatLength = 1 + numMarkets
                    row = 0
                    while row < numMarkets:
                        col = 0
                        while col < marketArrayLength[row]:
                            flattened[currentFlatLength + col] = marketsMatrix[row][col]
                            col += 1
                        currentFlatLength += col
                        row += 1
                    return(flattened: arr)

def getForkSelection(market):
    return(self.Markets[market].forkSelection)

def getMarketEvents(market):
    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
    return(self.Markets[market].sharesPurchased[outcome])

def getVolume(market):
    return(self.Markets[market].volume)

def getParticipantNumber(market, address):
    participantNumber = self.Markets[market].addr2participant[address]
    if(self.Markets[market].participants[participantNumber].participantID != tx.origin):
        return(-1)
    else:
        return(participantNumber)

def getParticipantID(market, participantNumber):
    return(self.Markets[market].participants[participantNumber].participantID)

def getParticipantSharesPurchased(market, participantNumber, outcome):
    return(self.Markets[market].participants[participantNumber].shares[outcome])

def getNumEvents(market):
    return(self.Markets[market].lenEvents)

def getCurrentParticipantNumber(market):
    return(self.Markets[market].currentParticipant)

def getAlpha(market):
    return(self.Markets[market].alpha)

def getCumScale(market):
    return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
    return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
    return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
    return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
    self.Markets[market].tradingPeriod = period
    return(1)

def getTradingFee(market):
    return(self.Markets[market].tradingFee)

def getBranchID(market):
    return(self.Markets[market].branch)

# alpha is equal to v/(n*log(n)) where v is the max percent commission
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
# todo: sum trick
macro lsLmsr($marketID):
    with $bq = Bq($marketID):
        with $i = 1:
            with $sumExp = 0:
                while $i <= numOutcomes($marketID):
                    $sumExp += self.fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)
                    $i += 1
                $bq*cumScale($marketID)*self.fx_log($sumExp)/2**64
                
# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

macro sumList($q, $a, $b):
    $i = $a + 1
    $result = $q[$a]
    while $i <= $b:
        $result += $q[$i]
        $i += 1
    $result

macro market($marketID):
    self.Markets[$marketID]

macro alpha($marketID):
    market($marketID).alpha

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

macro particpant($marketID, $addr):
    market($marketID).participants[$addr]

macro Bq($marketID):
   alpha($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64

def lsLmsr(marketID):
    return(lsLmsr(marketID))

def price(market, outcome):
    a = lsLmsr(market)
    sharesPurchased(market)[outcome] += 2**50
    b = lsLmsr(market)
    sharesPurchased(market)[outcome] -= 2**50
    return(((b - a) * 2**64)/2**50)

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, forkSelection):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add event list to the market
    save(self.Markets[marketID].events[0], events, items=len(events))
    self.Markets[marketID].lenEvents = len(events)
    self.Markets[marketID].tradingPeriod = tradingPeriod
    self.Markets[marketID].originalPeriod = tradingPeriod
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].branch = branch
    self.Markets[marketID].forkSelection = forkSelection
    return(1)

def addParticipant(market, address):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    participantNumber = self.Markets[market].currentParticipant
    self.Markets[market].participants[participantNumber].participantID = address
    self.Markets[market].addr2participant[address] = participantNumber
    self.Markets[market].currentParticipant += 1
    return(participantNumber)

def modifyShares(marketID, outcome, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    sharesPurchased(marketID)[outcome] += amount
    return(1)

def modifyParticipantShares(branch, marketID, participantNumber, outcome, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount
    if(block.number/100>=self.getTradingPeriod(marketID)):
        return(1)
    else:
        if(amount<0):
            amount = amount*-1
        self.Markets[marketID].volume += amount
        self.addPeriodVolume(branch, self.getTradingPeriod(marketID), amount)
        return(1)
        
def initialLiquidityAmount(market, outcome):
    return(self.Markets[market].initialLiquidity[outcome])

def setInitialLiquidityAmount(market, outcome, amount):
    self.Markets[market].initialLiquidity[outcome] = amount
    return(1)
    
def setWinningOutcomes(market, outcomes: arr):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
    return(1)

def getWinningOutcomes(market):
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)

def initialLiquiditySetup(marketID, alpha, cumScale, numOutcomes):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[marketID].alpha = alpha
    self.Markets[marketID].cumulativeScale = cumScale
    self.Markets[marketID].numOutcomes = numOutcomes
    return(1)

def setTradingFee(market, fee):
    self.Markets[market].tradingFee = fee
    return(fee)

def setPushedForward(market, bool):
    self.Markets[market].pushingForward = bool
    self.Markets[market].bondsMan = msg.sender
    return(1)

def getPushedForward(market):
    return(self.Markets[market].pushingForward)

def getBondsMan(market):
    return(self.Markets[market].bondsMan)
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
	length=self.Info[ID].descriptionLength
	return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
	return(self.Info[ID].descriptionLength)

def getCreator(ID):
	return(self.Info[ID].creator)

def getCreationFee(ID):
	return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	# check that msg.sender is one of our function contracts
	if(self.Info[ID].creator == 0):
		save(self.Info[ID].description[0], description, chars=len(description))
		self.Info[ID].descriptionLength = len(description)
		self.Info[ID].creationFee = fee
		self.Info[ID].creator = creator
		return(1)
	else:
		return(0)

