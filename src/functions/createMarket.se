# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import info as INFO
import cash as CASH
import reporting as REPORTING
import makeReports as MAKEREPORTS
import fxpFunctions as FXP
import markets as MARKETS
import events as EVENTS
import expiringEvents as EXPEVENTS

event creationBlock(market:indexed)


# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
    # n is num outcomes
# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
# @return marketID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money or market already exists
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired

# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr, forkSelection):
    periodLength = BRANCHES.getPeriodLength(branch)
    # liquidity is just buying complete sets then selling at diff. prices
    # minimum fee 2% with initial liquidity >= $50 and < $100
    if(initialLiquidity<100*2**64):
        if(tradingFee<368934881474191032):
            return(-5)
    # minimum fee 1% with initial liquidity >= $100 and < $1000
    if(initialLiquidity<1000*2**64):
        if(tradingFee<184467440737095516):
            return(-5)
    # minimum fee 0.5% with initial liquidity < $2000
    if(initialLiquidity<2000*2**64):
        if(tradingFee<92233720368547758):
            return(-5)
    # minimum fee 0.4% with initial liquidity < $3000
    if(initialLiquidity<3000*2**64):
        if(tradingFee<73786976294838206):
            return(-5)
    # minimum fee 0.3% with initial liquidity < $4000
    if(initialLiquidity<4000*2**64):
        if(tradingFee<55340232221128654):
            return(-5)
    # minimum fee 0.2% with initial liquidity < $5000
    if(initialLiquidity<5000*2**64):
        if(tradingFee<36893488147419103):
            return(-5)
    # minimum fee 0.1% with initial liquidity >= $5000
    if(initialLiquidity>=5000*2**64):
        if(tradingFee<18446744073709551):
            return(-5)

    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 or (initialLiquidity<50*2**64 and !BRANCHES.getOracleOnly(branch)) || alpha <= 2^57 || tradingFee < BRANCHES.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
    # minimum initial liquidity for "oracle only" branches is less (half is a fee, half returned)
    if(initialLiquidity<2*2**64):
        return(-1)
    event = events[0]

    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)

    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(-2)

    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(i!=0):
            if(event==events[i-1]):
                return(-6)
        expirationDate = EVENTS.getExpiration(event)
        futurePeriod = expirationDate / periodLength
        if(expirationDate < block.number):
            return(-7)    
        EXPEVENTS.addEvent(branch, futurePeriod, event)
        if(expirationDate > tradingPeriod):
            tradingPeriod = expirationDate
        eventsConcat += event
        if (EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):
            return(-1)
        #scalars
        maxValue = EVENTS.getMaxValue(event)
        minValue = EVENTS.getMinValue(event)
        if((maxValue!=2 || minValue !=1) && EVENTS.getNumOutcomes(event)==2):
            # is a valid scalar
            cumulativeScale += maxValue - EVENTS.getMinValue(event)
        eventNumOutcomes = EVENTS.getNumOutcomes(event)
        if(i==0):
            numOutcomes += eventNumOutcomes
        else:
            numOutcomes *= eventNumOutcomes
        i += 1
    if(numOutcomes > 80):
        return(-3)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / periodLength)

    # formation of marketID (hash)
    marketinfo = string(11*32 + len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo + 11*32, description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))
    log(type=creationBlock, marketID)
    CASH.initiateOwner(marketID)
    # pay numOutcomes fee
    # if it's already been created return 0
    if(!CASH.send(branch, numOutcomes*2^63) || INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):
        return(-4)

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    z = initialLiquidity * 2**64 / (cumulativeScale*2**64 + alpha*numOutcomes*cumulativeScale*FXP.fx_log(numOutcomes*2**64)/2**64)
    MARKETS.initialLiquiditySetup(marketID, alpha, cumulativeScale, numOutcomes)
    while y <= numOutcomes:
        MARKETS.modifyShares(marketID, y, z)
        MARKETS.setInitialLiquidityAmount(marketID, y, z)
        y += 1
    if(INFO.setInfo(marketID, description, tx.origin, initialLiquidity) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, forkSelection) && CASH.send(marketID, initialLiquidity)):
        i = 0
        while i < len(events):
            EVENTS.addMarket(events[i], marketID)
            i += 1
        return(marketID)

    # revert shares bought and other variables
    else:
        v = 1
        while v <= numOutcomes:
            MARKETS.modifyShares(marketID, v, -z)
            v += 1
        MARKETS.initialLiquiditySetup(marketID, 0, 0, 0)
        return(-4)

# todo: needs to comply w/ new trading fee rules
# perhaps don't allow raising of trading fee
def updateTradingFee(branch, market, tradingFee):
    if(tradingFee < BRANCHES.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
    return(MARKETS.setTradingFee(market, tradingFee))

#Add def moveMarket(market, newBranch, marketAuthor) in case of a fork or some other issue
#In event of fork:
#1) Market Maker chooses the fork
#2) Market is closed at current prices
#3) The market is unable to go to adjudication upon close date and closes at final prices.
#4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
#5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
#6) market is moved to the fork with a higher market cap as defined by centralized exchange y
def moveMarketAndAssocEvents(market, fork):
    #if(self.stuffForked()):
    if(1):
        forkChoice = MARKETS.getForkSelection(market)

        # set market branch
        # move event
        # move market as well to whichever fork

        #1) Market Maker chooses the fork
        if(forkChoice==1):
            if(INFO.getCreator(market)==msg.sender):
                return(0)
        #2) Market is closed at current prices
        elif(forkChoice==2):
            return(0)
        #3) The market is unable to go to adjudication upon close date and closes at final prices.
        elif(forkChoice==3):
            return(0)
        #4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
        # should this be weighted by capital in the market? hmm
        elif(forkChoice==4):
            return(0)
        #5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
        elif(forkChoice==5):
            return(0)
        #6) market is moved to the fork with a higher market cap as defined by centralized exchange y
        elif(forkChoice==6):
            return(0)
        #7) autonocoin style bet which fork it should go on and that's the one (like futarchy, except you don't get a refund)
        elif(forkChoice==7):
            return(0)
    else:
        return(0)


# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    # todo: if has been pushed forward in the past (see close market) don't allow it again
    numEvents = MARKETS.getNumEvents(market)
    if(marketClosed):
        return(0)
    if(CASH.send(market, numEvents*MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))==0):
        return(0)
    i = 0
    # for each event in market
    while i < numEvents:
        if(eventNotResolved && eventNotInRound2Adj):
            event = MARKETS.getMarketEvent(market, i)
            # push into next vote period
            period = BRANCHES.getVotePeriod(branch)
            EXPEVENTS.addEvent(branch, period+1, event)
            # set event expiration date to be after the current reporting period ends
            EVENTS.setExpiration(event, block.number)
            MARKETS.setTradingPeriod(market, period+1)
            MARKETS.setPushedForward(market, 1)
            #MAKEREPORTS.setReportable(period+1, event)
        i += 1
    return(1)


# - If at anytime after expiry an event's market's odds are <.99, someone can prove it and push it into next reporting period
# (and don't allow rbrr for original exp period of this market, actually, don't allow this regardless)
# - Should probably still have an option to pay to resolve in case something somehow goes wrong here or people really want a market resolved.
#def resolve99Market(branch, market, resolveRegardless):
#    if(eventIsScalar || marketClosed):
#      return(-1)
#    if(marketNotExpired):
#      return(-2)
#    numOutcomes = MARKETS.getMarketNumOutcomes(market)
#    n = 0
#    ninetynine = 0
#    while n < numOutcomes:
#      if(MARKETS.price(markets, n) > 18262276632972456099):
#        ninetynine = 1
#        n = numOutcomes
#        n += 1

#    if(ninetynine==0 || resolveRegardless):
#      if(resolveRegardless):
#        if(CASH.send(branch, 100*2**64)==0):
#            return(0)

#    numEvents = MARKETS.getNumEvents(market)
#    i = 0
#    # for each event in market
#    while i < numEvents:
#      if(eventNotResolved && eventNotInRound2Adj):
#        event = MARKETS.getMarketEvent(market, i)
        # push into next vote period
#        period = BRANCHES.getVotePeriod(branch)
#        EXPEVENTS.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
#        EVENTS.setExpiration(event, block.number)
#        MARKETS.setTradingPeriod(market, period+1)
#        MAKEREPORTS.setReportable(period+1, event)
#      i += 1
#    return(1)


macro save_trade($type, $amount, $price, $market_id):
    trade = [$type, $market_id, $amount, $price, msg.sender, block.number]
    trade_id = sha3(trade:arr)

    # Save trade
    if !self.trades[trade_id].id:
        self.trades[trade_id].id = trade_id
        self.trades[trade_id].type = $type
        self.trades[trade_id].market = $market_id
        self.trades[trade_id].amount = $amount
        self.trades[trade_id].price = $price
        self.trades[trade_id].owner = msg.sender
        self.trades[trade_id].block = block.number
        self.trades[trade_id].refhash = ref(self.trades[trade_id].id)

        # Update market
        last_id = self.markets[$market_id].last_trade
        self.markets[$market_id].trade_ids[last_id].next_id = trade_id
        self.markets[$market_id].trade_ids[trade_id].prev_id = last_id
        self.markets[$market_id].trade_ids[trade_id].id = trade_id
        self.markets[$market_id].last_trade = trade_id
        self.markets[$market_id].total_trades += 1

        # Update available and trading amounts for asks
        if $type == ASK:
            self.balances[msg.sender][$market_id].available -= $amount
            self.balances[msg.sender][$market_id].trading += $amount
    else:
        return(TRADE_ALREADY_EXISTS)

    # Log transaction
    log(type=log_add_tx, $market_id, msg.sender, $type, $price, $amount, trade_id)
    log(type=log_add_tx, $market_id, msg.sender, $type, $price, $amount, $outcome, trade_id)

    return(trade_id)

macro remove_trade($trade_id, $market_id):
    self.trades[$trade_id].id = 0
    self.trades[$trade_id].type = 0
    self.trades[$trade_id].market = 0
    self.trades[$trade_id].amount = 0
    self.trades[$trade_id].price = 0
    self.trades[$trade_id].owner = 0
    self.trades[$trade_id].block = 0
    self.trades[$trade_id].refhash = 0

    prev_id = self.markets[$market_id].trade_ids[$trade_id].prev_id
    next_id = self.markets[$market_id].trade_ids[$trade_id].next_id
    if prev_id and next_id:
        self.markets[$market_id].trade_ids[prev_id].next_id = next_id
        self.markets[$market_id].trade_ids[next_id].prev_id = prev_id
    elif prev_id:
        self.markets[$market_id].last_trade = prev_id
        self.markets[$market_id].trade_ids[prev_id].next_id = 0

    if next_id:
        self.markets[$market_id].trade_ids[$trade_id].next_id = 0
    if prev_id:
        self.markets[$market_id].trade_ids[$trade_id].prev_id = 0
    self.markets[$market_id].trade_ids[$trade_id].id = 0
    self.markets[$market_id].total_trades -= 1


#
# Buy / Sell actions
#
def buy(amount, price, market_id):
    check_trade(amount, price, market_id)

    # Calculate ETH value
    value = ((amount * price) / (self.markets[market_id].precision * 10 ^ self.markets[market_id].decimals)) * 10 ^ 18

    #
    # Check buy value
    #
    if msg.value < self.markets[market_id].minimum:
        refund()
        return(INSUFFICIENT_TRADE_AMOUNT)

    # Check msg.value and value match
    if msg.value < value:
        refund()
        return(TRADE_AMOUNT_MISMATCH)

    # Refund excess value
    if msg.value > value:
        send(msg.sender, msg.value - value)

    save_trade(BID, amount, price, market_id)

    return(FAILURE)


def sell(amount, price, market_id):
    check_trade(amount, price, market_id)

    # Calculate ETH value
    value = ((amount * price) / (self.markets[market_id].precision * 10 ^ self.markets[market_id].decimals)) * 10 ^ 18

    #
    # Check sell value
    #
    if value < self.markets[market_id].minimum:
        refund()
        return(INSUFFICIENT_TRADE_AMOUNT)

    # Check balance of subcurrency
    balance = self.balances[msg.sender][market_id].available
    if balance >= amount:
        save_trade(ASK, amount, price, market_id)

    return(FAILURE)

#
# Trade
#
#Exchange(Market, outcome, sender, amount, receiver, payment) â€“ transfers amount shares from sender to receiver for payment amount
def trade(max_amount, trade_ids:arr):
    # Set max_value from initial msg.value
    max_value = msg.value

    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]

        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= self.trades[trade_id].block:
            return(TRADE_SAME_BLOCK_PROHIBITED)

        # Get market
        market_id = self.trades[trade_id].market
        contract = self.markets[market_id].contract
        decimals = self.markets[market_id].decimals
        precision = self.markets[market_id].precision
        minimum = self.markets[market_id].minimum

        # Get trade
        type = self.trades[trade_id].type
        amount = self.trades[trade_id].amount
        price = self.trades[trade_id].price
        owner = self.trades[trade_id].owner

        # Fill buy order
        if type == BID:

            # Get available balance
            balance = self.balances[msg.sender][market_id].available

            if balance > 0:

                # Determine fill amount
                fill = min(amount, min(balance, max_amount))

                # Calculate value
                value = ((fill * price) * 10 ^ 18) / (precision * 10 ^ decimals)

                # Check buy value
                if value < minimum:
                    if max_value > 0:
                        send(msg.sender, max_value)
                    return(INSUFFICIENT_VALUE)

                # Update trade amount or remove
                if fill < amount:
                    self.trades[trade_id].amount -= fill
                else:
                    remove_trade(trade_id, market_id)

                # Update balances
                self.balances[msg.sender][market_id].available -= fill
                self.balances[owner][market_id].available += fill

                # Transfer ETH
                send(msg.sender, value)

                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, ASK, price, fill, trade_id)
            else:
                return(INSUFFICIENT_BALANCE)

        elif type == ASK:

            if max_value > 0:

                # Check sell value
                if max_value < minimum:
                    if max_value > 0:
                        send(msg.sender, max_value)
                    return(INSUFFICIENT_VALUE)

                # Calculate value of trade
                trade_value = ((amount * price) * 10 ^ 18) / (precision * 10 ^ decimals)

                # Determine fill value
                value = min(max_value, trade_value)

                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = ((value * (precision * 10 ^ decimals)) / price) / 10 ^ 18
                    self.trades[trade_id].amount -= fill
                else:
                    fill = amount
                    remove_trade(trade_id, market_id)

                # Update balances
                self.balances[owner][market_id].trading -= fill
                self.balances[msg.sender][market_id].available += fill

                # Transfer ETH
                send(owner, value)

                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, BID, price, fill, trade_id)
            else:
                return(INSUFFICIENT_BALANCE)

        # Update market last price
        self.markets[market_id].last_price = price

        # Log price, fill amount, type and timestamp
        log(type=log_price, market_id, type, price, fill, block.timestamp)

        # Update max_amount and max_value
        max_amount -= fill
        max_value -= value

        # Next trade
        t += 1

    # Refund excess value
    if max_value:
        send(msg.sender, max_value)

    return(SUCCESS)
    return(amountUnfilled)

#
# Cancellation
#
def cancel(trade_id):
    # Get trade
    type = self.trades[trade_id].type
    amount = self.trades[trade_id].amount
    price = self.trades[trade_id].price
    owner = self.trades[trade_id].owner

    # Get market
    market_id = self.trades[trade_id].market
    contract = self.markets[market_id].contract
    decimals = self.markets[market_id].decimals
    precision = self.markets[market_id].precision

    # Check the owner
    if msg.sender == owner:

        # Clear the trade first
        remove_trade(trade_id, market_id)

        # Issue refunds
        if type == BID:
            # ETH refund
            value = ((amount * price) / (precision * 10 ^ decimals)) * 10 ^ 18
            send(msg.sender, value)

        elif type == ASK:
            # Subcurrency refund
            self.balances[msg.sender][market_id].trading -= amount
            self.balances[msg.sender][market_id].available += amount

        # Log cancellation
        log(type=log_cancel, market_id, msg.sender, price, amount, trade_id)

        return(SUCCESS)

    return(FAILURE)

def get_trade_ids(market_id):
    trades_count = self.markets[market_id].total_trades
    trade_id = self.markets[market_id].last_trade
    trade_ids = array(trades_count)

    i = 0
    while i < trades_count:
        trade_ids[i] = self.markets[market_id].trade_ids[trade_id].id
        trade_id = self.markets[market_id].trade_ids[trade_id].prev_id
        i = i + 1

    if trade_ids:
        return(trade_ids:arr)
    return([FAILURE]:arr)

def get_trade(id):
    trade = array(TRADE_FIELDS)

    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].refhash
    trade[8] = self.trades[id].outcome

    if trade:
        return(trade:arr)
    return([FAILURE]:arr)

# useful
# @return amount of shares transferred
# Error messages otherwise
    # -1: invalid outcome or you haven't traded in this market (or market doesn't exist)
    # -2: user actually doesn't have the shares
    # -3: not enough money to transfer the shares
def transferShares(branch, market, outcome, amount, to):
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    receiverNumber = MARKETS.getParticipantNumber(market, to)
    # make sure outcome exists
    if (outcome==0 || MARKETS.getParticipantID(market, participantNumber) != tx.origin):
        return(-1)
    if(to != MARKETS.getParticipantID(market, receiverNumber)):
        receiverNumber = MARKETS.addParticipant(market, to)
    # remove shares from the user's account
    # if user actually doesn't have the shares, return -2
    if(MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-2)
    MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, -amount)
    MARKETS.modifyParticipantShares(branch, market, receiverNumber, outcome, amount)

    # half of fees to market creator
    # other half go to branch
    oldCost = MARKETS.lsLmsr(market)
    MARKETS.modifyShares(market, outcome, 2^32)
    newCost = MARKETS.lsLmsr(market)
    price = 2^32*(newCost - oldCost)
    fee = MARKETS.getTradingFee(market)*price/2^64
    MARKETS.modifyShares(market, outcome, -2^32)
    if((CASH.balance(tx.origin) >= fee) && CASH.send(INFO.getCreator(market), fee/2) && CASH.send(branch, fee/2)):
        return(amount)
    else:
        return(-3)
