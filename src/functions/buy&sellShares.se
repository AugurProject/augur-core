# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import reporting as REPORTING
import fxpFunctions as FXP
import markets as MARKETS
import events as EVENTS

# market, reporter
data trades[][](hash, block)
data trades[2^160](id, type, market, amount, price, owner, block, refhash, outcome)

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)
event log_cancel(market:indexed, sender, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

def commitTrade(market, hash):
    self.trades[market][tx.origin].hash = hash
    self.trades[market][tx.origin].block = block.number
    return(1)
    
def makeMarketHash(max_amount, trade_ids: arr):
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(2)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeHash = sha256(tradeInfo, items=2)
    return(tradeHash)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber):
    trade = [$type, $market, $amount, $price, msg.sender, block.number, $outcome]
    trade_id = sha3(trade:arr)

    # Save trade
    if !self.trades[trade_id].id:
        self.trades[trade_id].id = trade_id
        self.trades[trade_id].type = $type
        self.trades[trade_id].market = $market
        self.trades[trade_id].amount = $amount
        self.trades[trade_id].price = $price
        self.trades[trade_id].owner = msg.sender
        self.trades[trade_id].block = block.number
        self.trades[trade_id].outcome = $outcome
        self.trades[trade_id].refhash = ref(self.trades[trade_id].id)

        # Update market
        # todo
        last_id = self.markets[$market_id].last_trade
        self.markets[$market_id].trade_ids[last_id].next_id = trade_id
        self.markets[$market_id].trade_ids[trade_id].prev_id = last_id
        self.markets[$market_id].trade_ids[trade_id].id = trade_id
        self.markets[$market_id].last_trade = trade_id
        self.markets[$market_id].total_trades += 1

        # Update available and trading amounts for asks
        if $type == ASK:
            MARKETS.modifyParticipantShares($branch, $market, $participantNumber, $outcome, -$amount)
        # Send / escrow cash for bids
        if $type == BID:
            CASH.send($market, $amount * $price / 2**64)

    else:
        return(TRADE_ALREADY_EXISTS)

    log(type=log_add_tx, $market_id, msg.sender, $type, $price, $amount, $outcome, trade_id)

    return(trade_id)

#
# Cancellation
#
def cancel(trade_id):
    # user can cancel anytime
    # Get trade
    type = self.trades[trade_id].type
    amount = self.trades[trade_id].amount
    price = self.trades[trade_id].price
    owner = self.trades[trade_id].owner
    # Get market
    market = self.trades[trade_id].market

    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)

        # Issue refunds
        if type == BID:
            # cash refund
            CASH.subtractCash(market, amount * price / 2**64)
            CASH.addCash(msg.sender, amount * price / 2**64)
        elif type == ASK:
            # shares refund
            MARKETS.modifyParticipantShares(branch, market, participantNumber, outcome, amount)
        
        # Log cancellation
        log(type=log_cancel, market_id, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market_id):
    self.trades[$trade_id].id = 0
    self.trades[$trade_id].type = 0
    self.trades[$trade_id].market = 0
    self.trades[$trade_id].amount = 0
    self.trades[$trade_id].price = 0
    self.trades[$trade_id].owner = 0
    self.trades[$trade_id].block = 0
    self.trades[$trade_id].refhash = 0

    prev_id = self.markets[$market_id].trade_ids[$trade_id].prev_id
    next_id = self.markets[$market_id].trade_ids[$trade_id].next_id
    if prev_id and next_id:
        self.markets[$market_id].trade_ids[prev_id].next_id = next_id
        self.markets[$market_id].trade_ids[next_id].prev_id = prev_id
    elif prev_id:
        self.markets[$market_id].last_trade = prev_id
        self.markets[$market_id].trade_ids[prev_id].next_id = 0

    if next_id:
        self.markets[$market_id].trade_ids[$trade_id].next_id = 0
    if prev_id:
        self.markets[$market_id].trade_ids[$trade_id].prev_id = 0
    self.markets[$market_id].trade_ids[$trade_id].id = 0
    self.markets[$market_id].total_trades -= 1


#
# Buy / Sell actions
# Errors:
    # -1: amount/price bad or no market
    # -2: oracle only branch
    # -3: trading not allowed
    # -4: bad outcome to trade
    # -5: not enough money or shares
#
def buy(branch, amount, price, market, outcome):
    if(amount <= 0 or price <= 0 or market==0):
        return(-1)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)

    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    # if participant doesn't exist in market, add them
    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):
        participantNumber = MARKETS.addParticipant(market, tx.origin)
    numEvents = MARKETS.getNumEvents(market)
    events = MARKETS.getMarketEvents(market, outitems=numEvents)
    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):
        return(-4)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(EVENTS.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(EVENTS.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    ### TODO: check for .99 market here
    if (outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):
        return(-3)
    if(CASH.balance(tx.origin) < (amount * price / 2**64 *(MARKETS.getTradingFee(market) + 2^64)/2^64)):
        return(-5)

    save_trade(BID, amount, price, market, outcome, branch, participantNumber)
    return(FAILURE)

def sell(branch, amount, price, market_id, outcome):
    if(amount <= 0 or price <= 0 or market_id==0):
        return(-1)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)

    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    numEvents = MARKETS.getNumEvents(market)
    events = MARKETS.getMarketEvents(market, outitems=numEvents)
    if(outcome > MARKETS.getMarketNumOutcomes(market) or outcome < 1):
        return(-4)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(EVENTS.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(EVENTS.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    ### TODO: check for .99 market here
    if (MARKETS.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):
        return(-3)
    if (MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-5)
    
    save_trade(ASK, amount, price, market_id, outcome, branch, participantNumber)
    return(FAILURE)


#
# Trade
#
# Errors:
    # -1: oracle only branch
    # -2: bad trade hash
#Exchange(Market, outcome, sender, amount, receiver, payment) â€“ transfers amount shares from sender to receiver for payment amount
#max amount is max shares to sell
#max value is max amount to spend to buy
def trade(max_value, max_amount, trade_ids:arr):
    if(BRANCHES.getOracleOnly(branch)):
        return(-1)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(2)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeHash = sha256(tradeInfo, items=2)
    if(self.trades[market][tx.origin].hash != tradeHash || block.number == self.trades[market][tx.origin].block):
        return(-2)
    self.trades[market][tx.origin].hash = 0
    max_value = max_value
    max_amount = max_amount
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= self.trades[trade_id].block:
            return(TRADE_SAME_BLOCK_PROHIBITED)
        # Get market
        market_id = self.trades[trade_id].market
        # Get trade
        type = self.trades[trade_id].type
        amount = self.trades[trade_id].amount
        price = self.trades[trade_id].price
        owner = self.trades[trade_id].owner
        outcome = self.trades[trade_id].outcome
        branch = MARKETS.getBranchID(market_id)

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
            balance = MARKETS.getParticipantSharesPurchased(market_id, participantNumber, outcome)
            if balance > 0:
                participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
                if (MARKETS.getParticipantID(market_id, participantNumber) != tx.origin):
                    return(INSUFFICIENT_BALANCE)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/2**64
                # Update trade amount or remove
                if fill < amount:
                    self.trades[trade_id].amount -= fill
                else:
                    remove_trade(trade_id, market_id)
                # Update balances
                MARKETS.modifyParticipantShares(branch, market_id, msg.sender, outcome, -fill)
                MARKETS.modifyParticipantShares(branch, market_id, owner, outcome, fill)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                CASH.addCash(msg.sender, value)
                CASH.subtractCash(market_id, value)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, ASK, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)

        elif type == ASK:
            max_value = min(CASH.balance(msg.sender), max_value)
            if max_value > 0:
                # Calculate value of trade
                trade_value = amount * price / 2**64
                # Determine fill value
                value = min(max_value, trade_value)
                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = value*2**64 / price
                    self.trades[trade_id].amount -= fill
                else:
                    fill = amount
                    remove_trade(trade_id, market_id)
                participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
                # if participant doesn't exist in market, add them
                if(tx.origin != MARKETS.getParticipantID(market_id, participantNumber)):
                    participantNumber = MARKETS.addParticipant(market_id, tx.origin)
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                MARKETS.modifyParticipantShares(branch, market_id, msg.sender, outcome, fill)
                # Transfer cash from user to person who has ask order
                CASH.addCash(owner, value)
                CASH.subtractCash(msg.sender, value)
                # Update max_value
                max_value -= value
                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, BID, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)

        # Update market last price
        self.markets[market_id].last_price = price
        # Log price, fill amount, type and timestamp
        log(type=log_price, market_id, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1

    return([SUCCESS, max_value, max_amount]: arr)



def get_trade_ids(market_id):
    trades_count = self.markets[market_id].total_trades
    trade_id = self.markets[market_id].last_trade
    trade_ids = array(trades_count)

    i = 0
    while i < trades_count:
        trade_ids[i] = self.markets[market_id].trade_ids[trade_id].id
        trade_id = self.markets[market_id].trade_ids[trade_id].prev_id
        i = i + 1

    if trade_ids:
        return(trade_ids:arr)
    return([FAILURE]:arr)

def get_trade(id):
    trade = array(TRADE_FIELDS)

    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].refhash
    trade[8] = self.trades[id].outcome

    if trade:
        return(trade:arr)
    return([FAILURE]:arr)







# buys amount of every outcome
def buyCompleteSets(branch, market, amount):
    if(BRANCHES.getOracleOnly(branch)):
        return(-6)
    # make it so trader has locked in fee from buy, so if they sell and they bought when fee was low, they can sell with that low fee as opposed to a high one
    numEvents = MARKETS.getNumEvents(market)
    events = MARKETS.getMarketEvents(market, outitems=numEvents)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(EVENTS.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(EVENTS.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    ### TODO: check for .99 market here
    if (outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):
        return(-1)
    price = amount
    if(CASH.balance(tx.origin) < price*(MARKETS.getTradingFee(market) + 2^64)/2^64):
        return(-3)

    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)

    # if participant doesn't exist in market, add them
    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):
        participantNumber = MARKETS.addParticipant(market, tx.origin)

    i = 0
    # send shares of the event to user address
    while i <= numOutcomes:
        MARKETS.modifyShares(market, i, amount)
        MARKETS.modifyParticipantShares(branch, market, participantNumber, i, amount)
        i += 1
    # send money from user acc. to market address/account
    # cost for shares
    CASH.send(market, price)
    # half of fees to market creator
    fee = MARKETS.getTradingFee(market)*price/2^64
    CASH.send(INFO.getCreator(market), fee/2)
    # other half go to branch
    CASH.send(branch, fee/2)
    return(1)

    
# sells amount of every outcome [if user owns it]
def sellCompleteSets(branch, market, amount):
    if(BRANCHES.getOracleOnly(branch)):
        return(-6)
    # lockin fee
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    numEvents = MARKETS.getNumEvents(market)
    events = MARKETS.getMarketEvents(market, outitems=numEvents)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    n = 0
    #if event gets pushed back people can still buy / sell
    pushedBack = 0
    while n < numEvents:
        #if(EVENTS.getPushedBack(events[n])==0):
        if(1):
            n += 1
        # pushed back and not resolved
        elif(EVENTS.getOutcome(events[n])==0):
            pushedBack = 1
            n = numEvents
        else:
          n += 1
    if (MARKETS.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (BRANCHES.getVotePeriod(branch)>MARKETS.getTradingPeriod(market) && !pushedBack) || MARKETS.getBranchID(market) != branch):
        return(-1)

    # these prices are in fixed point
    price = amount
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    # remove shares from the user's account
    i = 0
    while i <= numOutcomes:
        if(MARKETS.getParticipantSharesPurchased(market, participantNumber, i) < amount):
            return(-3)
        i += 1
    i = 0
    # send shares of the event to user address
    while i <= numOutcomes:
        MARKETS.modifyShares(market, i, -amount)
        MARKETS.modifyParticipantShares(branch, market, participantNumber, i, -amount)
        i += 1
    
    # send bitcoin from the market to the user acc.
    CASH.subtractCash(market, price)
    fee = MARKETS.getTradingFee(market)*price/2^64
    # half of fees go to market creator
    CASH.addCash(INFO.getCreator(market), fee/2)
    # half go to branch
    CASH.addCash(branch, fee/2)
    price -= fee
    CASH.addCash(tx.origin, price)
    return(1)