# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)
data Branches[](currentVotePeriod, periodLength, step, markets[], numMarkets)

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value (ditto for categorical even though not actually true) - a no is 1, yes is 2
# this is just for events array we do 0 and 1
# S&P 500 would be say 0 && 4700, respectively
# should min and max be fxp?
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# [branchID][votingPeriod]
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
data EventsExpDates[][](numberEvents, events[], totalRepReported, reporters[][], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

# 0th item in branchList is the length of the branch list
data branchList[]

data branchListCount

def init():
    # test initial funds
    self.cashcoinBalances[tx.origin] = 100000*2^64
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 470*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1
    self.Info[1010101].description[] = "initial branch"
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Branches[1010101].currentVotePeriod = (block.number / 403200) - 1 
    self.Branches[1010101].periodLength = 403200
    self.branchList[0] = 1
    self.branchList[1] = 1010101

# string chunks
macro chunks($l):
    $l + if(l%32 != 0, 1, 0)

# @return: cash balance of address
def balance(address):
    return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
# so cashcoin fees could just go to root branch, or we could not have fees besides 
# gas fee to do a send transaction
# @return: value sent, 0 if fails
def send(recver, value):
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

def faucet():
    sender = tx.origin
    self.cashcoinBalances[sender] = 10000*2^64
    index = self.Reporting[1010101].numberReporters
    self.Reporting[1010101].repIDtoIndex[tx.origin] = index
    self.Reporting[1010101].reputation[index].repValue = 47*2^64
    self.Reporting[1010101].reputation[index].reporterID = tx.origin
    self.Reporting[1010101].numberReporters += 1
    return(1)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    if(from!=tx.origin):
        return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    # VoteCoins cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.Branches[branch].currentVotePeriod
    if(value<=0 || !self.send(branch, 5*2^64) || self.EventsExpDates[branch][currentVotePeriod].reporters[tx.origin][0] != 0 || self.EventsExpDates[branch][currentVotePeriod].reporters[recver][0] != 0):
        return(0)
    sender = tx.origin
    senderIndex = self.Reporting[branch].repIDtoIndex[sender]
    receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
        reporterIndex = self.Reporting[branch].numberReporters
        self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
        self.Reporting[branch].reputation[reporterIndex].repValue = 0
        self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
        self.Reporting[branch].numberReporters += 1
        return(-1)

    if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
        return(-2)
        
    senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
    if(senderBalance >= value):
        self.Reporting[branch].reputation[senderIndex].repValue -= value
        self.Reporting[branch].reputation[receiverIndex].repValue += value
        return(value)
    else:
        return(0)

# @return reputation value        
def getRepBalance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
# @return branchID if success, else 0
def createSubbranch(description:str, periodLength, parent):
    if(periodLength<=0 || !self.Branches[parent].periodLength || description==0):
        return(0)

    #upcomingDecisions = 0
    #a = (block.number / self.Branches[branch].periodLength)
    #b = a
    #while b < (a+100):
    #    upcomingDecisions += self.EventsExpDates[parent][a].numberEvents
    #    b += 1
    # turned off for testing
    #if(upcomingDecisions < 500):
    #    return(0)

    branchInfo = string((items=6)+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*2^64                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.number                                #current block number
    branchInfo[5] = parent                                      #branchID of parent branch
    mcopy(branchInfo+(items=6), description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha256(branchinfo, chars=len(branchInfo))

    if(self.Branches[parent].periodLength && self.Info[parent].creator && self.send(parent, 47*2^64) && self.Branches[branchID].periodLength==0):
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = 47*2^64
        self.Info[branchID].descriptionLength = len(description)
        save(self.Info[branchID].description[0], description, chars=len(description))
        self.Branches[branchID].periodLength = periodLength
        # first vote period won't be until after the current (in this case first) basket of things has expired
        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]
        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)
        # then once blockNum / periodLength is say 6 and eventsExpDates[6]
        # votePeriod 4 should close and the currentVotePeriod should be from
        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)
        self.Branches[branchID].currentVotePeriod = (block.number / periodLength) - 1
        i = 0
        while i < self.Reporting[parent].numberReporters:
            self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
            self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
            self.Reporting[branchID].repIDtoIndex[reporterID] = i
            i+=1
        self.Reporting[branchID].numberReporters = i
        self.branchList[0] += 1
        self.branchList[self.branchList[0]] = branchID
        return(branchID)
    else:
        return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# need to make sure these values are ok
# @return 0 as fail state, eventID if success
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
    if(self.Branches[branch].periodLength && description!=0 && expDate>block.number):
        eventinfo = string((items=8)+len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo+(items=8), description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(0)

    # can't have a scalar && categorical event in one
    # you can make a market like that though!
    if(numOutcomes!=2 && maxValue!=1):
        return(0)

    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)
    participationFactor = (self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-2].totalRepReported * 2^64) / self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-1].totalRepReported
    if(participationFactor==0):
        participationFactor = 1
    # send fee and bond
    if(self.balance(tx.origin)>=(42*2^64 + participationFactor*45)):
        if (!self.Info[eventID].creator && !self.Events[eventID].branch && self.send(eventID, 42*2^64) && self.send(branch, participationFactor*45)):
            self.Info[eventID].creator = tx.origin
            self.Info[eventID].creationFee = participationFactor*45 # this is not the bond
            self.Info[eventID].descriptionLength = len(description)
            save(self.Info[eventID].description[0], description, chars=len(description))
            self.Events[eventID].branch = branch
            self.Events[eventID].expirationDate = expDate
            self.Events[eventID].minValue = minValue
            self.Events[eventID].maxValue = maxValue
            self.Events[eventID].numOutcomes = numOutcomes
            # see which future period it expires in && put the event in that bin
            # event voting periods - expDate / periodLength gives you the voting period #
            futurePeriod = (expDate / self.Branches[branch].periodLength)
            self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
            self.EventsExpDates[branch][futurePeriod].numberEvents += 1
            return(eventID)
        else:
            return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
    with $alpha = self.Markets[$marketID].alpha:
        with $cumScale = self.Markets[$marketID].cumulativeScale:
            with $Bq = $alpha*$cumScale:
                with $sum = 0:
                    with $i = 1:
                        with $len = self.Markets[$marketID].numOutcomes:
                            with $sumexp = 0:
                                with $result = 0:
                                    while $i <= $len:
                                        $sum += self.Markets[$marketID].sharesPurchased[$i]
                                        $i += 1
                                    $Bq = $Bq * $sum / 2**64
                                    $i = 1
                                    while $i <= $len:
                                        $sumexp += fx_exp(self.Markets[$marketID].sharesPurchased[$i] * 2**64 / $Bq)
                                        $i += 1
                                    $result = $Bq * fx_log($sumexp) / 2**64
                                    $result

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
# initialLiquidity is initial number of shares of each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
# @return 0 as fail state, marketID if success
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr):
    if(self.Branches[branch].periodLength==0 or len(description)==0 or initialLiquidity==0 || alpha <= 2^57 || tradingFee < 2^57):
        return(0)
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(0)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(self.Events[event].expirationDate > tradingPeriod):
            tradingPeriod = self.Events[event].expirationDate
        eventsConcat += event
        if (self.Events[event].branch != branch || !self.Info[event].creator):
            return(0)
        #scalars
        if(self.Events[event].maxValue!=1):
            # not a scalar but also not categorical or binary - invalid event
            if(self.Events[event].numOutcomes!=2):
                return(0)
            # is a valid scalar
            cumulativeScale += self.Events[event].maxValue - self.Events[event].minValue
        if(i==0):
            numOutcomes += self.Events[event].numOutcomes
        else:
            numOutcomes *= self.Events[event].numOutcomes
        i += 1
    if(numOutcomes > 200):
        return(0)
    log(cumulativeScale)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / self.Branches[branch].periodLength)
    # formation of marketID (hash)
    marketinfo = string((items=11)+len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo+(items=11), description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))

    # pay numOutcomes fee
    # if it's already been created return 0
    if(!self.send(branch, numOutcomes*2^63) || self.Info[marketID].creator || self.Markets[marketID].numOutcomes):
        return(0)

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    z = initialLiquidity * 2**64 / (2**64 + alpha*cumulativeScale*fx_log(initialLiquidity)/2**64)
    log(z)
    while y <= numOutcomes:
        self.Markets[marketID].sharesPurchased[y] += z
        y += 1
    self.Markets[marketID].alpha = alpha
    self.Markets[marketID].cumulativeScale = cumulativeScale
    self.Markets[marketID].numOutcomes = numOutcomes
    cost = lsLmsr(marketID)
    if(self.send(marketID, cost)):
        # add event list to the market
        save(self.Markets[marketID].events[0], events, items=eventNum)
        self.Info[marketID].creator = tx.origin
        self.Info[marketID].creationFee = initialLiquidity
        self.Info[marketID].descriptionLength = len(description)
        save(self.Info[marketID].description[0], description, chars=len(description))
        self.Markets[marketID].alpha = alpha
        self.Markets[marketID].lenEvents = len(events)
        self.Markets[marketID].cumulativeScale = cumulativeScale
        self.Markets[marketID].numOutcomes = numOutcomes
        self.Markets[marketID].tradingPeriod = tradingPeriod
        self.Markets[marketID].tradingFee = tradingFee
        self.Branches[branch].markets[self.Branches[branch].numMarkets] = marketID
        self.Branches[branch].numMarkets += 1
        return(marketID)
    else:
        # revert shares bought and other variables
        y = 1
        while y <= numOutcomes:
            self.Markets[marketID].sharesPurchased[y] -= z
        self.Markets[marketID].alpha = 0
        self.Markets[marketID].cumulativeScale = 0
        self.Markets[marketID].numOutcomes = 0
        return(0)

# amount of shares should be an integer
# @return 0 if fail, else return price + fee to buy shares
def buyShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)  
    # if we have 3-4 cycles in a row of events getting pushed back market would already be closed even though events up to be decided on for a while yet never decided
    # technically this is a stalled branch and market should be open
    # if(currentPeriod + 3 >= currentVotePeriod) we're stalled
    #the question is though --- are these events part of the set that were stalled?
    #if above && the event outcomes aren't determined (0), then yes
    #then set a stalled boolean 
    stalled = 0
    if (outcome==0 || (self.Branches[branch].currentVotePeriod>=self.Markets[market].tradingPeriod && !stalled)):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] += amount
    newCost = lsLmsr(market)
    if newCost < oldCost:
        self.Markets[market].sharesPurchased[outcome] -= amount
        return(0)
    price = (newCost - oldCost)
    
    if(self.cashcoinBalances[tx.origin] < price*(self.Markets[market].tradingFee + 2^64)/2^64):
        self.Markets[market].sharesPurchased[outcome] -= amount
        return(0)

    participantNumber = self.Markets[market].addr2participant[tx.origin]

    if(tx.origin != self.Markets[market].participants[participantNumber].participantID):
        participantNumber = self.Markets[market].currentParticipant
        self.Markets[market].participants[participantNumber].participantID = tx.origin
        self.Markets[market].addr2participant[tx.origin] = participantNumber
        self.Markets[market].currentParticipant += 1

    self.Markets[market].participants[participantNumber].shares[outcome] += amount
    # send shares of the event to user address
    # if user doesn't have enough money, revert
    # send money from user acc. to market address/account
    # cost for shares
    self.send(market, price)
    # half of fees to market creator
    fee = self.Markets[market].tradingFee*price/2^64
    self.send(self.Info[market].creator, fee/2)
    # other half go to branch
    self.send(branch, fee/2)
    return(price+fee)

# amount is amount of shares to sell
# instead of inputting particip. num could just loop through array if dont have it
# @return 0 if fail, returns amount you get paid if success
def sellShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    participantNumber = self.Markets[market].addr2participant[tx.origin]
    if (self.Markets[market].participants[participantNumber].participantID != tx.origin || outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[market].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] -= amount
    newCost = lsLmsr(market)
    # these prices are in fixed point
    price = oldCost - newCost
    # remove shares from the user's account
    # if user actually doesn't have the shares, revert
    if(self.Markets[market].participants[participantNumber].shares[outcome] < amount):
        self.Markets[market].sharesPurchased[outcome] += amount
        return(0)
    else:
        # send bitcoin from the market to the user acc.
        self.cashcoinBalances[market] -= price
        fee = self.Markets[market].tradingFee*price/2^64
        # half of fees go to market creator
        self.cashcoinBalances[self.Info[market].creator] += fee/2
        # half go to branch
        self.cashcoinBalances[branch] += fee/2
        self.cashcoinBalances[tx.origin] += (price - fee)
        self.Markets[market].participants[participantNumber].shares[outcome] -= amount
        return(price - fee)

# @return amount of shares transferred
def transferShares(branch, market, outcome, amount, to):
    participantNumber = self.Markets[market].addr2participant[tx.origin]
    receiverNumber = self.Markets[market].addr2participant[to]
    if (outcome==0 || self.Markets[market].participants[participantNumber].participantID != tx.origin):
        return(0)
    if(to != self.Markets[market].participants[receiverNumber].participantID):
        receiverNumber = self.Markets[market].currentParticipant
        self.Markets[market].participants[receiverNumber].participantID = to
        self.Markets[market].addr2participant[to] = receiverNumber
        self.Markets[market].currentParticipant += 1
    # remove shares from the user's account
    # if user actually doesn't have the shares, return 0
    if(self.Markets[market].participants[participantNumber].shares[outcome] < amount):
        return(0)
    self.Markets[market].participants[participantNumber].shares[outcome] -= amount
    self.Markets[market].participants[receiverNumber].shares[outcome] += amount

    # needs msrPrice macro implemented to send fees
    # half of fees to market creator
    #fee = self.Markets[market].tradingFee*msrPrice(market, outcome)/2^64
    #self.send(self.Info[market].creator, fee/2)
    # other half go to branch
    #self.send(branch, fee/2)

    return(amount)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
    # && loop through the events[] array fr2om 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called) 
    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods
    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))
# @return 0 if fail, 1 if success
def vote(branch, report:arr, votePeriod):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    if(votePeriod):
        # need report length to be same as number of items in the current eventexpdates voting period events!
        if(len(report)!=self.EventsExpDates[branch][votePeriod].numberEvents):
            return(0)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / self.Branches[branch].periodLength)
        if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(0)

        reputation = self.Reporting[branch].reputation[repIndex].repValue
        # need to update stuff for quorem
        # && store the report && the rep value
        save(self.EventsExpDates[branch][votePeriod].reporters[tx.origin][0], report, items=len(report))
        self.EventsExpDates[branch][votePeriod].totalRepReported += reputation
        return(1)

    else:
        # need report length to be same as number of items in the current eventexpdates voting period events!
        if(len(report)!=self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents):
            return(0)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / self.Branches[branch].periodLength)
        if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin || currentExpPeriod >= (self.Branches[branch].currentVotePeriod+2) || currentExpPeriod < (self.Branches[branch].currentVotePeriod+1)):
            return(0)

        reputation = self.Reporting[branch].reputation[repIndex].repValue
        # need to update stuff for quorem
        # && store the report && the rep value
        save(self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].reporters[tx.origin][0], report, items=len(report))
        self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].totalRepReported += reputation
        return(1)

# returns whether a quorem has a matured event
# if there aren't enough events in a vote period eventsexpdate, push them to the current period and increment the vote period
# @return 0 if fail, 1 if success
def checkQuorum(branch):
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    currentPeriod = (block.number / self.Branches[branch].periodLength)
    # provided the currentPeriod is >=2 periods past the things we're going to rbcr on
    # we can then conclude it has matured && people have had time to vote
    matured = false
    enoughEvents = false
    enoughUpcoming = false
    if (currentPeriod >= (currentVotePeriod+2)):
        matured = true

    # min future decisions at stake - 200 - else branch stalls (do same thing we do if min ballot/event size isn't met,
    # push events into current voting period and hopefully more people will create decisions so it can actually be voted on, else repeat)
    upcomingDecisions = 0
    b = currentPeriod
    while b < (currentPeriod+100):
        upcomingDecisions += self.EventsExpDates[parent][a].numberEvents
        b += 1

    if ((self.EventsExpDates[branch][currentVotePeriod].numberEvents < 30 || upcomingDecisions < 500) && matured):
        self.Branches[branchID].currentVotePeriod += 1
        x = 0
        while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):
            self.EventsExpDates[branch][currentVotePeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]
            self.EventsExpDates[branch][currentPeriod].numberEvents += 1
            x += 1
    else:
        enoughEvents = true
        enoughUpcoming = true
    # for testing!
    enoughUpcoming = true
    enoughEvents = true
    if(matured && enoughEvents && enoughUpcoming):
        return(1)
    else:
        return(0)
      
# 25% of fees already distributed to market creators
# so 2/3 of remaining fees to voters = 50%
# && 1/3 of remaining fees to event creators = 25%
# what if not enough consensus or not enough events expiring upcoming
# @return step we're on of redeem function, for final call return new voting period
# Error: -1: "quorem not satisfied"
def redeem(branch):
    if(!self.checkQuorum(branch)):
        return(-1)
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    step = self.Branches[branch].step
    if(step==0):
        # loop through reputation && check if in reporters, if so use their report, if not use the fillin / not reported report (all zeroes)
        # use this to make a giant array of votes to pass to self.consensus
        # want to pass votes for each 0 indexed event in order (so we get votes from an actual reporter)
        # (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
        numReporters = self.Reporting[branch].numberReporters
        reputation = array(numReporters)
        numberEvents = self.EventsExpDates[branch][currentvotePeriod].numberEvents
        votes = array(numReporters * numberEvents)

        i = 0
        while i < numReporters:
            reporterID = self.Reporting[branch].reputation[i].reporterID
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            # checks to see if each reporter actually voted on events
            # if they didn't vote (simply check if they voted on first event) do nothing (these values will be 0 by default due to Serpent array styles)
            # else if the reporter did report on events put their ballot into the votes array
            if(self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][0] != 0):
                x = 0
                while x < numberEvents:
                    votes[x + i*numberEvents] = self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][x]
                    x += 1
            i += 1
        vSize = len(votes)

        j = 0
        scaled = array(numberEvents)
        scaledMaxFixed = array(numberEvents)
        scaledMinFixed = array(numberEvents)
        while j < numberEvents:
            if(self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue!=1):
                scaled[j] = 1
                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
            else:
                scaled[j] = 0
                scaledMinFixed[j] = 1*2^64
                scaledMaxFixed[j] = 2*2^64
            j+=1
        result = self.interpolate(votes, reputation, scaled, scaledMaxFixed, scaledMinFixed, outsz=2*vSize)
        self.EventsExpDates[branch][currentVotePeriod].vSize = vSize
        save(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], result, items=vSize)
        save(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], slice(result, items=vSize, items=2*vSize), items=vSize)
        #def array_saveload():
        #a = [1,2,3,4,5]
        #save(self.a[0], a, items=5)
        #a = load(self.a[0], items=4)
        #log(len(a))
        #return(load(self.a[0], items=4):arr)
        # we're on step one nowâ€
        self.Branches[branch].step = 1
        return(1)
    elif(step==1):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReporters = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReporters)
        i = 0
        while i < numReporters:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i += 1
        j = 0
        scaled = array(numEvents)
        scaledMaxFixed = array(numEvents)
        scaledMinFixed = array(numEvents)
        while j < numEvents:
            if(self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue!=1):
                scaled[j] = 1
                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
            else:
                scaled[j] = 0
                scaledMinFixed[j] = -1*2^64
                scaledMaxFixed[j] = 1*2^64
            j+=1
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        result = self.center(reportsFilled, reputation, scaled, scaledMaxFixed, scaledMinFixed, 5, outsz=vSize+numEvents+1)
        save(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], result, items=vSize)
        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], slice(result, items=vSize, items=len(result)), items=(len(result)-vSize))
        self.Branches[branch].step = 2
        return(2)
    elif(step==2):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        if(self.EventsExpDates[branch][currentVotePeriod].loadingVector[numEvents]==0):
            return(0)
        loadingVector = array(numEvents+1)
        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        # multistep pca
        # call this 5 times
        loadingVector = self.pca_loadings(loadingVector, weightedCenteredData, reputation, numReports, numEvents, outsz=numEvents+1)
        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], loadingVector, items=len(loadingVector))
        self.Branches[branch].step = 3
        return(3)
    elif(step==3):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        loadingVector = array(numEvents+1)
        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        scores = self.pca_scores(loadingVector, weightedCenteredData, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].scores[0], scores, items=len(scores))
        self.Branches[branch].step = 4
        return(4)
    elif(step==4):
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        scores = array(numReports)
        scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=len(numReports))
        result = self.calibrate_sets(scores, numReports, numEvents, outsz=3*numReports)
        # loads the first set of numReports items from result
        save(self.EventsExpDates[branch][currentVotePeriod].set1[0], result, items=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].set2[0], slice(result, items=numReports, items=2*numReports), items=numReports)
        self.Branches[branch].step = 5
        return(5)
    elif(step==5):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
         # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        set1 = array(numReports)
        set2 = array(numReports)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        result = self.calibrate_wsets(set1, set2, reputation, reportsFilled, numReports, numEvents, outsz=3*numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].old[0], result, items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new1[0], slice(result, items=numEvents, items=2*numEvents), items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new2[0], slice(result, items=2*numEvents, items=3*numEvents), items=numEvents)
        self.Branches[branch].step = 6
        return(6)
    elif(step==6):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        old = array(numEvents)
        new1 = array(numEvents)
        new2 = array(numEvents)
        set1 = array(numReports)
        set2 = array(numReports)
        scores = array(numReports)
        old = load(self.EventsExpDates[branch][currentVotePeriod].old[0], items=numEvents)
        new1 = load(self.EventsExpDates[branch][currentVotePeriod].new1[0], items=numEvents)
        new2 = load(self.EventsExpDates[branch][currentVotePeriod].new2[0], items=numEvents)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=numReports)
        adjPrinComp = self.pca_adjust(old, new1, new2, set1, set2, scores, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], adjPrinComp, items=len(adjPrinComp))
        self.Branches[branch].step = 7
        return(7)
    elif(step==7):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        adjPrinComp = array(numReports)
        adjPrinComp = load(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], items=numReports)
        smoothRep = self.smooth(adjPrinComp, reputation, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], smoothRep, items=len(smoothRep))
        self.Branches[branch].step = 8
        return(8)
    elif(step==8):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        result = self.consensus(smoothRep, reputation, reportsFilled, numReports, numEvents, outsz=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], result, items=numEvents)
        self.Branches[branch].step = 9
        return(9)
    elif(step==9):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        reportsMask = array(vSize)
        reportsMask = load(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], items=vSize)
        outcomesFinal = array(numEvents)
        outcomesFinal = load(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], items=numEvents)
        reporterBonus = self.participation(outcomesFinal, smoothRep, reportsMask, numReports, numEvents, outsz=numReports)

        # get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
        # && getting the cooresponding ID
        n = 0
        while n < numEvents:
            eventID = self.EventsExpDates[branch][currentVotePeriod].events[n]
            # then take outcomes_final && set each event outcome
            self.Events[eventID].outcome = outcomesFinal[n]
            if(outcomesFinal[n]!=2^63):
                # return bond
                self.cashcoinBalances[eventID] -= 42*2^64
                self.cashcoinBalances[self.Info[eventID].creator] += 42*2^64
        # need to loop through rep holders && distribute 50% of branch fees to reporters' cashcoin addresses 
        # also need to take reporterBonus && redistribute reputation in the Reporting structure accordingly
        z = 0
        while z < numReports:
            self.Reporting[branch].reputation[z].repValue = (reporterBonus[z]*21000000)/2^64
            self.cashcoinBalances[self.Reporting[branch].reputation[z].reporterID] += self.cashcoinBalances[branch]*reporterBonus[z] / 2^64
        self.Branches[branch].currentVotePeriod += 1
        self.cashcoinBalances[branch] -= self.cashcoinBalances[branch]
        self.Branches[branch].step = 0
        return(self.Branches[branch].currentVotePeriod)


# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# when multidimen fancy payouts we report on the events separately per usual, but combine them to determine winning state of a fancy market && then payout that state
# @return 0 if fail, if success 1
def closeMarket(branch, market):
    if(self.cashcoinBalances[market]<=0):
        return(0)
    numberEvents = self.Markets[market].lenEvents
    tradingPeriod = self.Markets[market].tradingPeriod
    # check if any events in the market were pushed back and that market has expired
    # (as long as the latest expiring event wasn't pushed back, we know they all got reported on)
    # if it *was* pushed back, we'll just get an outcome of 0, return 0 until the event is actually reported on, then we can resolve the market
    if(self.Branches[branch].currentVotePeriod > tradingPeriod):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        # (max poss. winning outcomes is 200 outcomes total all scalar multidimensional)
        winningOutcomes = array(200)
        while n < numberEvents:
            outcome = self.Events[self.Markets[market].events[n]].outcome
            if(outcome==2^63):
                # return all t3h $$$ - (@ 50 cents a share i presume)
                # give event bond money to reporters
                return(0)
            elif(outcome==0):
                return(0)
            if(n==0):
                #scalar
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    winningOutcomes[0] = 1
                    winningOutcomes[1] = 2
                # anything besides scalar
                else:
                    winningOutcomes[0] += outcome
            elif(n==1):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    # scalar, scalar
                    if(winningOutcomes[1]):
                        winningOutcomes[2] = 3
                        winningOutcomes[3] = 4
                    # nonscalar, scalar
                    else:
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] = winningOutcomes[0] + self.Events[self.Markets[market].events[n-1]].numOutcomes
                # scalar, nonscalar
                elif(winningOutcomes[1] && self.Events[self.Markets[market].events[n]].maxValue==1):
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                # nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
            elif(n==2):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    #scalar, scalar, scalar
                    if(winningOutcomes[3]):
                        winningOutcomes[4] = 5
                        winningOutcomes[5] = 6
                        winningOutcomes[6] = 7
                        winningOutcomes[7] = 8
                    #scalar, nonscalar, scalar
                    #nonscalar, scalar, scalar
                    elif(winningOutcomes[1]):
                      # winningOutcomes[0] = winningOutcomes[0]
                      # winningOutcomes[1] = winningOutcomes[1]
                        winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                        winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                    #nonscalar, nonscalar, scalar
                    elif(winningOutcomes[1]==0):
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes 
                else:
                    #scalar, scalar, nonscalar
                    if(winningOutcomes[3]):
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1) 
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    #scalar, nonscalar, nonscalar
                    #nonscalar, scalar, nonscalar
                    elif(winningOutcomes[1]):
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    #nonscalar, nonscalar, nonscalar
                    else:
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
            n+=1

        pricePerShare1 = 0
        pricePerShare2 = 0
        pricePerShare3 = 0
        pricePerShare4 = 0
        pricePerShare5 = 0
        pricePerShare6 = 0
        pricePerShare7 = 0
        pricePerShare8 = 0

        if(winningOutcomes[1]==0):
            pricePerShare1 = 2^64

        elif(winningOutcomes[7]):
            outcomeOne = self.Events[self.Markets[market].events[0]].outcome
            minValueOne = self.Events[self.Markets[market].events[0]].minValue
            maxValueOne = self.Events[self.Markets[market].events[0]].maxValue
            if(outcomeOne>maxValueOne):
                outcomeOne = maxValueOne
            elif(outcomeOne<minValueOne):
                outcomeOne = minValueOne
            outcomeTwo = self.Events[self.Markets[market].events[1]].outcome
            minValueTwo = self.Events[self.Markets[market].events[1]].minValue
            maxValueTwo = self.Events[self.Markets[market].events[1]].maxValue
            if(outcomeTwo>maxValueTwo):
                outcomeTwo = maxValueTwo
            elif(outcomeTwo<minValueTwo):
                outcomeTwo = minValueTwo
            outcomeThree = self.Events[self.Markets[market].events[2]].outcome
            minValueThree = self.Events[self.Markets[market].events[2]].minValue
            maxValueThree = self.Events[self.Markets[market].events[2]].maxValue
            if(outcomeThree>maxValueThree):
                outcomeThree = maxValueThree
            elif(outcomeThree<minValueThree):
                outcomeThree = minValueThree

            outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
            outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
            outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
            outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent
            outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)
            outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent
            
            # price is in fixed point
            # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
            pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)
            pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare5 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare6 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare7 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare8 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)

            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                sharesOwned = array(8)
                while(winningOutcome[n]!=0):
                    sharesOwned[n] = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    n+=1
                participant = self.Markets[market].participants[i].participantID
                self.cashcoinBalances[market] -= sharesOwned[0]*pricePerShare1/2^64
                self.cashcoinBalances[participant] += sharesOwned[0]*pricePerShare1/2^64
                self.cashcoinBalances[market] -= sharesOwned[1]*pricePerShare2/2^64
                self.cashcoinBalances[participant] += sharesOwned[1]*pricePerShare2/2^64
                self.cashcoinBalances[market] -= sharesOwned[2]*pricePerShare3/2^64
                self.cashcoinBalances[participant] += sharesOwned[2]*pricePerShare3/2^64
                self.cashcoinBalances[market] -= sharesOwned[3]*pricePerShare4/2^64
                self.cashcoinBalances[participant] += sharesOwned[3]*pricePerShare4/2^64
                self.cashcoinBalances[market] -= sharesOwned[4]*pricePerShare5/2^64
                self.cashcoinBalances[participant] += sharesOwned[4]*pricePerShare5/2^64
                self.cashcoinBalances[market] -= sharesOwned[5]*pricePerShare6/2^64
                self.cashcoinBalances[participant] += sharesOwned[5]*pricePerShare6/2^64
                self.cashcoinBalances[market] -= sharesOwned[6]*pricePerShare7/2^64
                self.cashcoinBalances[participant] += sharesOwned[6]*pricePerShare7/2^64
                self.cashcoinBalances[market] -= sharesOwned[7]*pricePerShare8/2^64
                self.cashcoinBalances[participant] += sharesOwned[7]*pricePerShare8/2^64
                i+=1

        elif(winningOutcomes[3]):
            # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
            scalarOne = -1
            scalarTwo = -1
            if(self.Events[self.Markets[market].events[0]].maxValue!=1):
                scalarOne = 0
            if(self.Events[self.Markets[market].events[1]].maxValue!=1):
                if(scalarOne == -1):
                    scalarOne = 0
                else:
                    scalarTwo = 1
            elif(self.Events[self.Markets[market].events[2]].maxValue!=1):
                scalarTwo = 2
            outcomeOne = self.Events[self.Markets[market].events[scalarOne]].outcome
            minValueOne = self.Events[self.Markets[market].events[scalarOne]].minValue
            maxValueOne = self.Events[self.Markets[market].events[scalarOne]].maxValue
            if(outcomeOne>maxValueOne):
                outcomeOne = maxValueOne
            elif(outcomeOne<minValueOne):
                outcomeOne = minValueOne
            outcomeTwo = self.Events[self.Markets[market].events[scalarTwo]].outcome
            minValueTwo = self.Events[self.Markets[market].events[scalarTwo]].minValue
            maxValueTwo = self.Events[self.Markets[market].events[scalarTwo]].maxValue
            if(outcomeTwo>maxValueTwo):
                outcomeTwo = maxValueTwo
            elif(outcomeTwo<minValueTwo):
                outcomeTwo = minValueTwo

            outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
            outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
            outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
            outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent

            # price is in fixed point
            # share four goes with the high-high side 
            pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64
            # share three goes with the low-high side
            pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64
            # share two goes with the high-low side
            pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64
            # share one goes with the low-low
             # both fixed point so div by 2^64 to keep in fixed point
            pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64
            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                n = 0
                while(winningOutcome[n]!=0):
                    sharesOwned = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    participant = self.Markets[market].participants[i].participantID
                    # low-low
                    if(n==0):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare1/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare1/2^64
                    # high-low
                    elif(n==1):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare2/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare2/2^64
                    # low-high
                    elif(n==2):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare3/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare3/2^64
                    # high-high
                    elif(n==3):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare4/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare4/2^64
                    n+=1
                i+=1

        elif(winningOutcomes[1]):
            # look for the scalar
            scalar = 0
            if(self.Events[self.Markets[market].events[0]].maxValue!=1):
                scalar = 0
            elif(self.Events[self.Markets[market].events[1]].maxValue!=1):
                scalar = 1
            elif(self.Events[self.Markets[market].events[2]].maxValue!=1):
                scalar = 2
            outcome = self.Events[self.Markets[market].events[scalar]].outcome
            minValue = self.Events[self.Markets[market].events[scalar]].minValue
            maxValue = self.Events[self.Markets[market].events[scalar]].maxValue
            if(outcome>maxValue):
                outcome = maxValue
            elif(outcome<minValue):
                outcome = minValue
            # price is in fixed point
            #share two goes with the high side
            pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)
            #share one goes with the low side of the calc
            pricePerShare1 = 2^64 - pricePerShare1
            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                n = 0
                while(winningOutcome[n]!=0):
                    sharesOwned = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    participant = self.Markets[market].participants[i].participantID
                    # low side
                    if(n==0):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare1/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare1/2^64
                    # high side (of the scalar part)
                    elif(n==1):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare2/2^64
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare2/2^64
                    n+=1
                i += 1

        # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)
        # refund left over initial liquidity in market - half to market creator, other half to voters
        # *unless* it's a scaled decision, refund all initial liquidity left over to market creator
        # rest of money available in market + the additional trading fees divy up amongst reporters and market creator
        initialLiquidity = self.Info[marketID].creationFee
        # some scalar involved
        if(winningOutcome[1]):
            if(self.cashcoinBalances[market] > initialLiquidity):
                # pay back liquidity, split up excess profits
                self.cashcoinBalances[self.Info[market].creator] += initialLiquidity
                self.cashcoinBalances[market] -= initialLiquidity
                self.cashcoinBalances[branch] += self.cashcoinBalances[market] / 2
                self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market] / 2
                self.cashcoinBalances[market] -= self.cashcoinBalances[market]
            # send whatever's left of the initial liquidity to the creator
            else:
                self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market]
                self.cashcoinBalances[market] -= self.cashcoinBalances[market]

        # no scalars
        else:
            if(self.cashcoinBalances[market] > initialLiquidity):
                # split up excess profits & liquidity
                self.cashcoinBalances[branch] += self.cashcoinBalances[market] / 2
                self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market] / 2
                self.cashcoinBalances[market] -= self.cashcoinBalances[market]

        q = 0
        while(winningOutcomes[q]!=0):
            self.Markets[market].winningOutcomes[q] = winningOutcomes[q]
            q += 1
        return(1)

### P2P parimutuel betting
# @return betID
def makeBet(eventID, amtToBet):
    betData = array(3)
    betData[0] = eventID
    betData[1] = block.number
    betData[2] = tx.origin
    betID = sha256(branchinfo, items=3)
    self.p2pBets[betID].eventID = betData[0]
    self.p2pBets[betID].amtToBet = amtToBet
    return(betID)

# should add a fee to market
# outcome is 0 or 1
# @return 0 if fail, 1 if success
def sendMoneytoBet(betID, outcome):
    if(self.cashcoinBalances[betID+outcome]==0):
        self.send(betID+outcome, self.p2pBets[betID].amtToBet)
    else:
        return(0)
    if(outcome):
        self.p2pBets[betID].outcomeOneBettor = tx.origin
    else:
        self.p2pBets[betID].outcomeZeroBettor = tx.origin
    return(1)

# add support for a .5 outcome
# @return 0 if fail, 1 if success
def closeBet(betID):
    # outcome not determined yet
    if(self.Events[self.p2pBets[betID].eventID].outcome == 0):
        return(0)
    # pay out depending on outcome
    if(self.cashcoinBalances[betID+0]==self.p2pBets[betID].amtToBet && self.cashcoinBalances[betID+1]==self.p2pBets[betID].amtToBet):
        self.cashcoinBalances[betID+0] -= self.cashcoinBalances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoinBalances[betID+1]
        if(self.Events[self.p2pBets[betID].eventID].outcome):
            self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.p2pBets[betID].amtToBet*2
        elif(self.Events[self.p2pBets[betID].eventID].outcome == -1):
            self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.p2pBets[betID].amtToBet*2
    # someone didn't pay their side of the bet, refund funds
    else:
        self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.cashcoinBalances[betID+0]
        self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.cashcoinBalances[betID+1]
        self.cashcoinBalances[betID+0] -= self.cashcoinBalances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoinBalances[betID+1]
    return(1)

### API (for UI)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up && report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
# voteperiod is an optional parameter only used in the scenario that we get behind on voting periods - ui will want to alert users of this and say hey we're behind but atm you should really be voting on this voting period (anything meeting the req. of vote if we were caught up)
# @returns a ballot of events (UI needs to vote w/ a ballot of reports in this order per corresponding event)
def makeBallot(branch, votePeriod):
    if(votePeriod):
        numEvents = self.EventsExpDates[branch][votePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][votePeriod].events[numEvents]
            eventArray[i] = eventID
    else:
        numEvents = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].events[numEvents]
            eventArray[i] = eventID
    return(eventArray: arr)

# arrayIndex only matters if array
# Error: -3: "Please call the eventsExpApi function"
       # -4: "Please call the reputation api function"
       # -5: "Please call the participants api function"
def api(dataStructure, itemNumber, arrayIndex, ID):
    if(dataStructure==0):
        if(itemNumber==0):
            length=self.Info[ID].descriptionLength
            return(load(self.Info[ID].description[0], chars=length))
        elif(itemNumber==1):
            return(self.Info[ID].descriptionLength)
        elif(itemNumber==2):
            return(self.Info[ID].creator)
        elif(itemNumber==3):
            return(self.Info[ID].creationFee)
    elif(dataStructure==1):
        if(itemNumber==0):
            return(self.Branches[ID].currentVotePeriod)
        elif(itemNumber==1):
            return(self.Branches[ID].periodLength)
        elif(itemNumber==2):
            return(self.Branches[ID].step)
    elif(dataStructure==2):
        if(itemNumber==0):
            return(self.Events[ID].branch)
        elif(itemNumber==1):
            return(self.Events[ID].expirationDate)
        elif(itemNumber==2):
            return(self.Events[ID].outcome)
        elif(itemNumber==3):
            return(self.Events[ID].minValue)
        elif(itemNumber==4):
            return(self.Events[ID].maxValue)
        elif(itemNumber==5):
            return(self.Events[ID].numOutcomes)
    elif(dataStructure==3):
        if(itemNumber==0):
            return(-3)
        elif(itemNumber==1):
            return(-4)
        elif(itemNumber==2):
            return(self.Reporting[ID].numberReporters)
        elif(itemNumber==3):
            return(self.Reporting[ID].repIDtoIndex[arrayIndex])
    elif(dataStructure==4):
        if(itemNumber==0):
            return(self.Markets[ID].events[arrayIndex])
        elif(itemNumber==1):
            return(self.Markets[ID].sharesPurchased[arrayIndex])
        elif(itemNumber==2):
            return(-5)
        elif(itemNumber==3):
            return(self.Markets[ID].lenEvents)
        elif(itemNumber==4):
            return(self.Markets[ID].currentParticipant)
        elif(itemNumber==5):
            return(self.Markets[ID].winningOutcomes[arrayIndex])
        elif(itemNumber==6):
            return(self.Markets[ID].alpha)
        elif(itemNumber==7):
            return(self.Markets[ID].cumulativeScale)
        elif(itemNumber==8):
            return(self.Markets[ID].numOutcomes)
        elif(itemNumber==9):
            return(self.Markets[ID].tradingPeriod)
        elif(itemNumber==10):
            return(self.Markets[ID].tradingFee)
    elif(dataStructure==5):
        if(itemNumber==0):
            return(self.p2pBets[ID].eventID)
        elif(itemNumber==1):
            return(self.p2pBets[ID].amtToBet)
        elif(itemNumber==2):
            return(self.p2pBets[ID].outcomeOneBettor)
        elif(itemNumber==3):
            return(self.p2pBets[ID].outcomeZeroBettor)

def eventsExpApi(expDateIndex, itemNumber, arrayIndexOne, arrayIndexTwo, ID):
    if(itemNumber==0):
        return(self.EventsExpDates[ID][expDateIndex].numberEvents)
    elif(itemNumber==1):
        return(self.EventsExpDates[ID][expDateIndex].events[arrayIndexOne])
    elif(itemNumber==2):
        return(self.EventsExpDates[ID][expDateIndex].totalRepReported)
    elif(itemNumber==3):
        return(self.EventsExpDates[ID][expDateIndex].reporters[arrayIndexOne][ArrayIndexTwo])
    elif(itemNumber==4):
        return(self.EventsExpDates[ID][expDateIndex].vSize)
    elif(itemNumber==5):
        return(self.EventsExpDates[ID][expDateIndex].reportsFilled[arrayIndexOne])
    elif(itemNumber==6):
        return(self.EventsExpDates[ID][expDateIndex].reportsMask[arrayIndexOne])
    elif(itemNumber==7):
        return(self.EventsExpDates[ID][expDateIndex].weightedCenteredData[arrayIndexOne])
    elif(itemNumber==8):
        return(self.EventsExpDates[ID][expDateIndex].loadingVector[arrayIndexOne])
    elif(itemNumber==9):
        return(self.EventsExpDates[ID][expDateIndex].scores[arrayIndexOne])
    elif(itemNumber==10):
        return(self.EventsExpDates[ID][expDateIndex].set1[arrayIndexOne])
    elif(itemNumber==11):
        return(self.EventsExpDates[ID][expDateIndex].set2[arrayIndexOne])
    elif(itemNumber==12):
        return(self.EventsExpDates[ID][expDateIndex].old[arrayIndexOne])
    elif(itemNumber==13):
        return(self.EventsExpDates[ID][expDateIndex].new1[arrayIndexOne])
    elif(itemNumber==14):
        return(self.EventsExpDates[ID][expDateIndex].new2[arrayIndexOne])
    elif(itemNumber==15):
        return(self.EventsExpDates[ID][expDateIndex].adjPrinComp[arrayIndexOne])
    elif(itemNumber==16):
        return(self.EventsExpDates[ID][expDateIndex].smoothRep[arrayIndexOne])
    elif(itemNumber==17):
        return(self.EventsExpDates[ID][expDateIndex].outcomesFinal[arrayIndexOne])

def reputationApi(reputationIndex, itemNumber, branchID):
    if(itemNumber==0):
        return(self.Reporting[branchID].reputation[reputationIndex].repValue)
    elif(itemNumber==1):
        return(self.Reporting[branchID].reputation[reputationIndex].reporterID)

# eventID && outcomeNumber only needed if itemNumber is 1
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
    if(itemNumber==0):
        return(self.Markets[marketID].participants[participantIndex].participantID)
    elif(itemNumber==1):
        return(self.Markets[marketID].participants[participantIndex].shares[outcomeNumber])

# @return all markets in a branch
def getMarkets(branch):
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)

# @return all events in a branch and expiration period
def getEvents(branch, expPeriod):
    numEvents = self.EventsExpDates[branch][expPeriod].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expPeriod].events[i]
        i += 1
    return(events: arr)

# @return all branches
# takes 1 if you want to use tx.origin default address
# or you can pass a real address in, or 0 to just return all branches
def getBranches(address):
    if(address==1):
        address = tx.origin
        branches = array(2*self.branchList[0])
        i = 1
        b = 0
        while i <= self.branchList[0]:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    elif(address):
        branches = array(2*self.branchList[0])
        i = 1
        b = 0
        while i <= self.branchList[0]:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:    
        i = 1
        b = 0
        numBranches = self.branchList[0]
        branches = array(numBranches)
        while i <= numBranches:
            branches[b] = self.branchList[i]
            i += 1
            b += 1
    return(branches: arr)

def getBranchDesc(branch):
    return(load(self.Info[branch].description[0], chars=2048))

def getEventDesc(event):
    return(load(self.Info[event].description[0], chars=2048))

def getMarketDesc(market):
    return(load(self.Info[market].description[0], chars=2048))

def getMarketEvents(market):
    i = 0
    lenEvents = self.Markets[market].lenEvents
    events = array(lenEvents)
    while i < lenEvents:
        events[i] = self.Markets[market].events[i]
        i += 1
    return(events: arr)

def getMarketInfo(market):
    info = array(8)
    info[0] = self.Info[market].creator
    info[1] = self.Info[market].creationFee
    info[2] = self.Markets[market].currentParticipant
    info[3] = self.Markets[market].alpha
    info[4] = self.Markets[market].cumulativeScale
    info[5] = self.Markets[market].numOutcomes
    info[6] = self.Markets[market].tradingPeriod
    info[7] = self.Markets[market].tradingFee
    return(info: arr)

def getEventInfo(event):
    info = array(8)
    info[0] = self.Info[event].creator
    info[1] = self.Info[event].creationFee
    info[2] = self.Events[event].branch
    info[3] = self.Events[event].expirationDate
    info[4] = self.Events[event].outcome
    info[5] = self.Events[event].minValue
    info[6] = self.Events[event].maxValue
    info[7] = self.Events[event].numOutcomes
    return(info: arr)

def getBranchInfo(branch):
    info = array(6)
    info[0] = self.Info[branch].creator
    info[1] = self.Info[branch].creationFee
    info[2] = self.Branches[branch].currentVotePeriod
    info[3] = self.Branches[branch].periodLength
    info[4] = self.Branches[branch].step
    info[5] = self.Branches[branch].numMarkets
    return(info: arr)

inset('fx_macros.se')
inset('consensus.se')